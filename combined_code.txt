Current Branch: dev
----------------------------------------
File: ./nodemon.json
----------------------------------------
{
  "ignore": [".git", "node_modules", "dist", "build"],
  "watch": ["./src"],
  "exec": "ts-node src/index.ts",
  "ext": "ts"
}



File: ./package.json
----------------------------------------
{
  "name": "credex-core-express",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "nodemon": "nodemon",
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc",
    "watch:build": "tsc --watch"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/cors": "^2.8.17",
    "@types/jsonwebtoken": "^9.0.6",
    "axios": "^1.6.8",
    "bcrypt": "^5.1.1",
    "body-parser": "^1.20.2",
    "cheerio": "^1.0.0-rc.12",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "moment-timezone": "^0.5.45",
    "neo4j-driver": "^5.20.0",
    "node-cron": "^3.0.3",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^10.0.0",
    "winston": "^3.14.2",
    "winston-daily-rotate-file": "^5.0.0"
  },
  "devDependencies": {
    "@types/body-parser": "^1.19.5",
    "@types/express": "^4.17.21",
    "@types/lodash": "^4.17.1",
    "@types/node-cron": "^3.0.11",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.6",
    "@types/uuid": "^10.0.0",
    "@types/winston": "^2.4.4",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5"
  }
}



File: ./config/swagger.ts
----------------------------------------
import swaggerJsdoc from "swagger-jsdoc";
import { config } from "./config";

const options: swaggerJsdoc.Options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "Credex Core API",
      version: "1.0.0",
      description:
        "API documentation for the Credex Core system. This API provides endpoints for managing members, accounts, Credex transactions, and recurring payments.",
    },
    servers: [
      {
        url: `http://localhost:${config.port}`,
        description: "Development server",
      },
      {
        url: "https://api.credex.example.com",
        description: "Production server",
      },
      {
        url: "https://staging-api.credex.example.com",
        description: "Staging server",
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
    tags: [
      { name: "Members", description: "Member management operations" },
      { name: "Accounts", description: "Account management operations" },
      { name: "Credex", description: "Credex transaction operations" },
      { name: "Recurring", description: "Recurring payment operations" },
      {
        name: "DevAdmin",
        description: "Development and administration operations",
      },
    ],
  },
  apis: ["./src/**/*.ts"], // Path to the API docs
};

export const swaggerSpec = swaggerJsdoc(options);



File: ./config/logger.ts
----------------------------------------
import winston from "winston";
import DailyRotateFile from "winston-daily-rotate-file";
import { config } from "./config";
import { v4 as uuidv4 } from 'uuid';

// Configure the logger
const logger = winston.createLogger({
  level: config.nodeEnv === "production" ? "info" : "debug",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    winston.format.json()
  ),
  defaultMeta: { service: "credex-core" },
  transports: [
    // Rotate error logs daily
    new DailyRotateFile({
      filename: "logs/error-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      zippedArchive: true,
      maxSize: "20m",
      maxFiles: "14d",
      level: "error",
    }),
    // Rotate combined logs daily
    new DailyRotateFile({
      filename: "logs/combined-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      zippedArchive: true,
      maxSize: "20m",
      maxFiles: "14d",
    }),
  ],
});

// Add console transport for non-production environments
if (config.nodeEnv !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

function sanitizeData(data: any): any {
  const sensitiveFields = ['password', 'token', 'apiKey', 'creditCard'];
  if (typeof data === 'object' && data !== null) {
    return Object.keys(data).reduce((acc: { [key: string]: any }, key: string) => {
      if (sensitiveFields.includes(key)) {
        acc[key] = '[REDACTED]';
      } else if (typeof data[key] === 'object') {
        acc[key] = sanitizeData(data[key]);
      } else {
        acc[key] = data[key];
      }
      return acc;
    }, {});
  }
  return data;
}

export default logger;

/**
 * Middleware for adding a unique request ID
 */
export const addRequestId = (req: any, res: any, next: any) => {
  req.id = uuidv4();
  res.setHeader('X-Request-ID', req.id);
  next();
};

/**
 * Middleware for logging Express requests
 */
export const expressLogger = (req: any, res: any, next: any) => {
  const start = Date.now();
  res.on("finish", () => {
    const duration = Date.now() - start;
    logger.info('User Input', {
      requestId: req.id,
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      body: sanitizeData(req.body),
      params: sanitizeData(req.params),
      query: sanitizeData(req.query),
      headers: sanitizeData(req.headers),
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });
  });
  next();
};

/**
 * Middleware for logging errors
 */
export const errorLogger = (err: Error, req: any, res: any, next: any) => {
  logger.error('Error', {
    requestId: req.id,
    message: err.message,
    stack: err.stack,
    method: req.method,
    url: req.originalUrl,
    body: sanitizeData(req.body),
    params: sanitizeData(req.params),
    query: sanitizeData(req.query),
    headers: sanitizeData(req.headers)
  });
  next(err);
};

/**
 * Function to log DCO rates
 */
export const logDCORates = (XAUrate: number, CXXrate: number, CXXmultiplier: number) => {
  logger.info('DCO Rates', { XAUrate, CXXrate, CXXmultiplier });
};

// TODO: Implement log aggregation and centralized logging for production environments
// TODO: Implement log retention policies based on compliance requirements
// TODO: Add performance monitoring for database queries and external API calls
// TODO: Implement log analysis tools to detect patterns, anomalies, and potential security threats



File: ./config/neo4j.ts
----------------------------------------
import * as neo4j from "neo4j-driver";

require("dotenv").config();

const ledgerSpace_url = `${process.env.NEO_4J_LEDGER_SPACE_BOLT_URL}`;
const ledgerSpace_user = `${process.env.NEO_4J_LEDGER_SPACE_USER}`;
const ledgerSpace_password = `${process.env.NEO_4J_LEDGER_SPACE_PASS}`;
const searchSpace_url = `${process.env.NEO_4J_SEARCH_SPACE_BOLT_URL}`;
const searchSpace_user = `${process.env.NEO_4J_SEARCH_SPACE_USER}`;
const searchSpace_password = `${process.env.NEO_4J_SEARCH_SPACE_PASS}`;

const createDriverWithRetry = (url: string, user: string, password: string) => {
  const driver = neo4j.driver(url, neo4j.auth.basic(user, password), {
    maxConnectionPoolSize: 50,
    connectionAcquisitionTimeout: 30000,
    maxTransactionRetryTime: 30000,
  });

  // Verify connectivity on first use
  driver.verifyConnectivity()
    .then(() => console.log(`Successfully connected to Neo4j at ${url}`))
    .catch(error => console.error(`Failed to connect to Neo4j at ${url}:`, error));

  return driver;
};

export const ledgerSpaceDriver = createDriverWithRetry(ledgerSpace_url, ledgerSpace_user, ledgerSpace_password);
export const searchSpaceDriver = createDriverWithRetry(searchSpace_url, searchSpace_user, searchSpace_password);

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Closing Neo4j drivers...');
  Promise.all([ledgerSpaceDriver.close(), searchSpaceDriver.close()])
    .then(() => {
      console.log('Neo4j drivers closed.');
      process.exit(0);
    })
    .catch(error => {
      console.error('Error closing Neo4j drivers:', error);
      process.exit(1);
    });
});



File: ./config/config.ts
----------------------------------------
import dotenv from 'dotenv';

dotenv.config();

export const config = {
  // Server configuration
  port: process.env.PORT || 5000,
  nodeEnv: process.env.NODE_ENV || 'development',
  deployment: process.env.DEPLOYMENT || 'dev',

  // WhatsApp Bot API configuration
  whatsappBotApiKey: process.env.WHATSAPP_BOT_API_KEY,

  // Neo4j database configuration
  neo4j: {
    ledgerSpace: {
      url: process.env.NEO_4J_LEDGER_SPACE_BOLT_URL,
      user: process.env.NEO_4J_LEDGER_SPACE_USER,
      password: process.env.NEO_4J_LEDGER_SPACE_PASS,
    },
    searchSpace: {
      url: process.env.NEO_4J_SEARCH_SPACE_BOLT_URL,
      user: process.env.NEO_4J_SEARCH_SPACE_USER,
      password: process.env.NEO_4J_SEARCH_SPACE_PASS,
    },
  },

  // External API configuration
  openExchangeRatesApiKey: process.env.OPEN_EXCHANGE_RATES_API,

  // Rate limiting configuration
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
  },

  // Cron job schedules
  cron: {
    dailyCredcoinOffering: '0 0 * * *', // Every day at midnight UTC
    minuteTransactionQueue: '* * * * *', // Every minute
  },
};

// TODO: Consider adding validation for required environment variables
// and throw meaningful errors if they're missing


File: ./config/authenticate.ts
----------------------------------------
import { Request, Response, NextFunction } from "express";
import crypto from "crypto";
import { config } from "./config";

interface UserRequest extends Request {
  user?: any;
}

/**
 * Middleware to authenticate API requests using a WhatsApp Bot API key.
 * This middleware should be applied to routes that require authentication.
 *
 * @param req - The Express request object
 * @param res - The Express response object
 * @param next - The next middleware function
 */
const authenticate = (req: UserRequest, res: Response, next: NextFunction) => {
  const apiKeySubmitted = req.header("whatsappBotAPIkey");
  const validApiKey = config.whatsappBotApiKey;

  if (!validApiKey) {
    console.error(
      "WHATSAPP_BOT_API_KEY is not defined in environment variables"
    );

    return res.status(500).json({ message: "Server configuration error" });
  }

  // Request was hanging if the header was empty or did'nt have whatsappBotAPIkey in it
  if (!apiKeySubmitted) {
    console.warn("Authentication failed: API key not provided.");
    return res.status(401).json({ message: "API key is required" });
  }

  if (apiKeySubmitted === validApiKey) {
    next();
  } else {
    return res.status(500).json({ message: "Internal Server Error" });
  }

  if (apiKeySubmitted) {
    // Use timing-safe comparison to prevent timing attacks
    if (crypto.timingSafeEqual(Buffer.from(apiKeySubmitted), Buffer.from(validApiKey))) {
      next();
    } else {
      return res.status(401).json({ message: "Unauthorized" });
    }
  } else {
    return res.status(401).json({ message: "API key is missing" });
  }
};

export default authenticate;

// TODO: Consider implementing a more robust authentication system,
// such as JWT or OAuth2, for enhanced security and flexibility



File: ./.devcontainer/devcontainer.json
----------------------------------------
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/typescript-node
{
  "name": "Node.js & TypeScript",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/typescript-node:1-22-bookworm",
  "customizations": {
    "vscode": {
      "extensions": [
        "esbenp.prettier-vscode",
        "Postman.postman-for-vscode",
        "saoudrizwan.claude-dev",
        "GitHub.copilot"
      ]
    }
  },
  // Features to add to the dev container. More info: https://containers.dev/features.
  "features": {
    "node": {
      "version": "18",
      "nodeGypDependencies": true
    }
  },
  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],

  // Use 'postCreateCommand' to run commands after the container is created.
  "postCreateCommand": [
    "/bin/sh",
    "-c",
    "npm install && npm install -g nodemon"
  ]

  // Configure tool-specific properties.
  // "customizations": {},

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}



File: ./middleware/errorHandler.ts
----------------------------------------
import { Request, Response, NextFunction } from 'express';
import logger from '../config/logger';
import { config } from '../config/config';

export interface AppError extends Error {
  statusCode?: number;
}

/**
 * Global error handling middleware
 * @param err - Error object
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Next middleware function
 */
export function errorHandler(err: AppError, req: Request, res: Response, next: NextFunction) {
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  // Log the error
  logger.error(`[Error] ${statusCode} - ${message}`, {
    error: err,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
  });
  
  // Send error response
  res.status(statusCode).json({
    status: 'error',
    statusCode,
    message: config.nodeEnv === 'production' ? message : `${message}\n${err.stack}`,
  });
}

/**
 * Middleware to handle 404 Not Found errors
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Next middleware function
 */
export function notFoundHandler(req: Request, res: Response, next: NextFunction) {
  const err: AppError = new Error(`Not Found - ${req.originalUrl}`);
  err.statusCode = 404;
  next(err);
}

// TODO: Implement custom error classes for different types of errors (e.g., ValidationError, DatabaseError)
// TODO: Consider adding a central error catalog for consistent error messages and codes


File: ./.github/dependabot.yml
----------------------------------------
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for more information:
# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates
# https://containers.dev/guide/dependabot

version: 2
updates:
  - package-ecosystem: "devcontainers"
    directory: "/"
    schedule:
      interval: weekly



File: ./.github/workflows/prod.yml
----------------------------------------
name: deploy_to_prod
run-name: ${{ github.actor }} pushed to prod_auto_deploy_setup with commit message '${{ github.event.head_commit.message }}'

on:
  push:
    branches:
      - prod

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: "18"

      - name: Install dependencies
        run: npm install
        working-directory: .

      - name: Set up SSH deploy keys
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Set ownership on remote server
        run: |
          echo "${{ secrets.SSH_KEY }}" > private_key.pem
          chmod 600 private_key.pem

          # Create known_hosts file if it doesn't exist
          mkdir -p /home/runner/.ssh
          touch /home/runner/.ssh/known_hosts
          # Clear old key from known_hosts
          ssh-keygen -R ${{ secrets.EC2_IP }} >> /home/runner/.ssh/known_hosts
          ssh-keyscan -H ${{ secrets.EC2_IP }} >> /home/runner/.ssh/known_hosts

          # Run the SSH command
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_IP }} \
          "cd credex-core &&
            git checkout prod &&
            docker-compose up --build"
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_KEY }}



File: ./.github/workflows/stage.yml
----------------------------------------
# Documentation https://github.com/appleboy/ssh-action
name: Credex Staging Deployment
on:
  push:
    branches: [stage]

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Executing remote ssh commands using key
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DEMO_SERVER_HOST }}
          username: ${{ secrets.DEMO_SERVER_USER }}
          password: ${{ secrets.DEMO_SERVER_SSH_PASSWORD }}
          port: ${{ secrets.SSH_PORT }}
          command_timeout: 25m
          script: |
            cd credex-core
            git checkout stage
            git pull
            docker compose up --build -d

  post:
    name: Slack Notification Sender
    runs-on: ubuntu-latest
    steps:
      - name: Send custom JSON data to Slack workflow
        id: slack
        uses: slackapi/slack-github-action@v1.23.0
        with:
          # This data can be any valid JSON from a previous step in the GitHub Action
          payload: |
            {
              "text": "${{ github.actor }} created commit.",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": ":desktop_computer:  ${{ github.actor }} created commit:  :desktop_computer:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": " :left_speech_bubble: *Commit Details* :left_speech_bubble:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Commit message: ${{ github.event.commits[0].message }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Repository: ${{ github.repository }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "GitHub Action build result: ${{ job.status }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "See changes: ${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
                  }
                },
                {
                  "type": "divider"
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK



File: ./README.md
----------------------------------------
# Credex Ecosystem Core API

The codebase in this credex-core repository actualizes two principles:

## Credex Principle

**If I owe you,**\
**and you owe them,**\
**and they owe me,**\
**we're square.**

## Credcoin Principle

**Every human is entitled to one equal share of the value of the natural wealth entering the organic economy.**\
**Every human is responsible to provide value equal to the amount of natural wealth that they consume.**

# Overview

The credex ecosystem actualizes the Credex Principle in the Minute Transaction Queue (MTQ), which tracks payable and receivable invoices for members' accounts, finds loops of value creation, and cancels payable and receivable invoices against each other in "credloops" in which every debt is reduced by an equal value. This is a GAAP-compliant accounting process that any person and any business can benefit from.

The ecosystem actualizes the Credcoin Principle in the Daily Credcoin Offering (DCO), which updates exchange rates across the ecosystem daily. Every 24h, the DCO makes this equation true: one credcoin today equals the number of members participating in the DCO today divided by the value of natural wealth entering the organic economy through the DCO today.

The organic economy is a subset of the credex ecosystem, which is a subset of the global economy, which is the human-enhanced subset of the world that is given to us by nature. The organic economy is an economy in which wealth circulates, profit accumulates, investment is made, and gifts are given in alignment and long-term harmony with the biological environment of our habitat and the physical laws that bind us.

The value of the natural wealth processed by the DCO is split into two portions: gift portion and market portion. Currently, in the mvp version we've developed in this repository, only the gift portion of the DCO is implemented. The market portion will be added later.

The credex ecosystem stores values in credcoin (CXX). In order to natively enable multi-denominational accounting, a CXXmultiplier value is stored alongside every CXX value. Both of these values are updated in every DCO so that the credex remains true to the face value in the denomination specified, and to other values stored in the ecosystem. A value expressed in CXX represents that value in relationship to every other value stored in the ecosystem. A value in CXX divided by its CXX multiplier expresses the value in the chosen denomination (face value).

The system manages the balance between local truth (preserving the face value of contracts in their specified denomination) and global truth (adjusting all values relative to credcoin) through the daily rate and value adjustments in the DCO. This implementation creates a robust ecosystem that manages accounting processes across any denomination, clears debts automatically, and adjusts values dynamically.

## express.js server

The express.js server is initialized with index.ts, which provides the cronjobs and endpoints that power the ecosystem and enable members and client apps to interact with its ledger.

## cronjobs

The Core module hosts the cronjobs.

DailyCredcoinOffering() runs every day at midnight UTC. First, DBinitialization() is run if there is no active daynode in the database. DCOexecute() then runs the Daily Credcoin Offering.

MinuteTransactionQueue() runs every minute, clearing credloops of value creation across the ecosystem.

## endpoints

Controllers for the endpoints are imported, and endpoints created for the various modules: Member, Account, Avatar, Admin, and DevAdmin.

# Daily Credcoin Offering (DCO)

Runs every 24h at midnight UTC, while most of the world's population centres are in darkness.

## DBinitialize.ts

The DBinitialization file sets up the initial state of the database for the Credex ecosystem.

1. Sets up database constraints and indexes for various entities (Daynode, Member, Account).
2. Establishes "day zero" and initializes exchange rates for various currencies against CXX (Credcoin).
3. Creates an initial "daynode" with the day zero exchange rates.
4. Creates an initial member (Ryan Watson) and updates their member tier.
5. Creates several initial accounts:
   - Ryan Watson's personal account
   - Credex Foundation account
   - Great Sun Financial (business account)
   - VimbisoPay (business account)
6. Establishes relationships between these accounts, particularly marking some as "CREDEX_FOUNDATION_AUDITED" to determine which accounts can originally issue secured credexes.
7. Creates an initial Credex transaction to fund the DCO for a year.

This initialization process sets up the basic structure and relationships needed for the Credex ecosystem to function, including the establishment of exchange rates and the creation of foundational accounts and transactions.

## DCOexecute.ts

The DCOexecute function implements the Daily Credcoin Offering (DCO) process.

1. Check if the Minute Transaction Queue (MTQ) is running and wait if it is and retry in a few seconds.
2. Set the DCOrunningNow flag and fetch the current and next date.
3. Perform an end-of-day backup.
4. Process defaulting unsecured credexes and expire pending offers/requests.
5. Fetch current exchange rates for various currencies.
6. Fetch declared DCO participants and filter them based on available secured balance.
7. Calculate new CXX (Credcoin) rates based on the total DCO amount and number of participants.
8. Create a new daynode with the updated CXX rates.
9. Create DCO give transactions from participants to the Credex Foundation.
10. Update credex and asset balances across the system to reflect the new exchange rates.
11. Create DCO receive transactions from the Credex Foundation to participants.
12. Perform a start-of-day backup for the new day.

This process implements the Credcoin Principle by:

- Allowing participants to contribute value to the ecosystem (DCO give transactions).
- Distributing an equal share of the new value to all participants (DCO receive transactions).
- Adjusting the value of Credcoin relative to other currencies based on the total contribution and number of participants.
- Updating all existing balances and transactions to maintain their relative value in the new exchange rate environment.

The DCO process ensures that the value of one Credcoin is always equal to the number of participants divided by the value of natural wealth entering the organic economy through the DCO, as stated in the Credcoin Principle.

This implementation allows for a dynamic, daily adjustment of the ecosystem's internal economy, reflecting the contributions and participation of its members while maintaining the relative value of existing transactions and balances.

# MinuteTransactionQueue (MTQ)

The Minute Transaction Queue is a crucial part of the Credex ecosystem that runs every minute. It links the main ledgerSpace database (the source of truth and full information) to a searchSpace database (optimized to find credloops). New accounts are first added to the searchSpace, then new credexes. After each new credex is added, the ecosystem finds and clears all possible loops created by the new credex.

1. Processing new accounts:

   - Finds accounts with "PENDING_ACCOUNT" status in the ledger space.
   - Creates corresponding accounts in the search space.
   - Updates the account status to "PROCESSED" in the ledger space.

2. Processing new Credexes:
   - Retrieves Credexes with "PENDING_CREDEX" status from the ledger space.
   - Sorts them by acceptance time.
   - For each Credex, it calls the LoopFinder function.

## LoopFinder.ts

Checks if the credex already exists in the search space. If not, it creates it.

1. Finds all loops starting and ending at the specified account.
   - Identifies the loop with the earliest due date.
   - For each node in the loop, it selects the Credex with the earliest due date (or largest amount if tied).
   - Identifies the minimum outstanding amount among all credexes in the loop.
2. If a loop is found:
   - Subtract the minimum amount from all Credexes in the loop.
   - Update the searchSpace, removing fully redeemed credexes and updating the earliest due dates.
   - Update the ledgerSpace, creating a LoopAnchor to represent the cleared loop, update the Credexes' outstanding and redeemed amounts, and create REDEEMED and CREDLOOP relationships.
   - For fully redeemed credexes, replace the OWES relationships with CLEARED relationships in ledgerSpace.
3. Go back to step one until no loop is found.
4. Once no more loops can be found, mark the original Credex as processed and exit the loop.

This implementation actualizes the Credex Principle by finding loops where "If I owe you, and you owe them, and they owe me, we're square." It automatically clears these loops, reducing the outstanding amounts of all involved credexes by the same amount (the minimum amount in the loop).

The LoopFinder is called by the MinuteTransactionQueue for each new Credex, ensuring that loops are found and cleared as soon as possible after new Credexes are created.

# Member

This module handles member-related operations in the Credex ecosystem. It exposes the following endpoints:

1. **onboardMember** (POST)

   - Function: Registers a new member in the Credex ecosystem and creates their personal consumption account.
   - Required variables:
     - firstname: string
     - lastname: string
     - phone: string
   - Optional variables:
     - DCOgiveInCXX: number (for setting up the DCO contribution)
     - DCOdenom: string (denomination for DCO contribution)

2. **getMemberDashboardByPhone** (GET)

   - Function: Retrieves a member's dashboard information and associated account dashboards using their phone number.
   - Required variables:
     - phone: string

3. **getMemberByHandle** (GET)

   - Function: Retrieves member information using their unique handle.
   - Required variables:
     - memberHandle: string

4. **updateMemberTier** (POST)

   - Function: Updates a member's tier status.
   - Required variables:
     - memberID: string
     - newTier: number

5. **securedCredexAuthForTier** (POST)
   - Function: Authorizes secured credex for a member's tier.
   - Required variables:
     - issuerAccountID: string
     - amount: number
     - denom: string

These endpoints allow for member registration, information retrieval, tier management, and secured credex authorization within the Credex ecosystem. All controllers now include improved input validation, error handling, and logging for better reliability and maintainability.

# Account

This module handles account-related operations in the Credex ecosystem. It exposes the following endpoints:

1. **createAccount** (POST)

   - Function: Creates a new account in the Credex ecosystem.
   - Required variables:
     - ownerID: string
     - accountType: string
     - accountName: string
     - accountHandle: string
     - defaultDenom: string
   - Optional variables:
     - DCOgiveInCXX: number
     - DCOdenom: string

2. **getAccountByHandle** (GET)

   - Function: Retrieves account information using the account handle.
   - Required variables:
     - accountHandle: string

3. **updateAccount** (PATCH)

   - Function: Updates an existing account's information.
   - Required variables:
     - ownerID: string
     - accountID: string
   - Optional variables:
     - accountName: string
     - accountHandle: string
     - defaultDenom: string

4. **authorizeForAccount** (POST)

   - Function: Authorizes a member to perform actions on behalf of an account.
   - Required variables:
     - memberHandleToBeAuthorized: string
     - accountID: string
     - ownerID: string

5. **unauthorizeForAccount** (POST)

   - Function: Removes authorization for a member to act on behalf of an account.
   - Required variables:
     - memberIDtoBeUnauthorized: string
     - accountID: string
     - ownerID: string

6. **updateSendOffersTo** (POST)
   - Function: Updates the account's preference for receiving offers.
   - Required variables:
     - memberIDtoSendOffers: string
     - accountID: string
     - ownerID: string

These endpoints provide comprehensive account management capabilities within the Credex ecosystem. All controllers now include improved input validation, error handling, and logging for better reliability and maintainability. The controllers ensure that all calls to Account services go through them, enforcing proper access control and data validation.

# Credex

This module handles Credex-related operations in the Credex ecosystem. It exposes the following endpoints:

1. **offerCredex** (POST)

   - Function: Creates a new Credex offer.
   - Required variables:
     - memberID: string
     - issuerAccountID: string
     - receiverAccountID: string
     - Denomination: string
     - InitialAmount: number

2. **acceptCredex** (PUT)

   - Function: Accepts a Credex offer.
   - Required variables:
     - credexID: string
     - signerID: string

3. **acceptCredexBulk** (PUT)

   - Function: Accepts multiple Credex offers in bulk.
   - Required variables:
     - credexIDs: string[] (Array of credex IDs to accept)
     - signerID: string

4. **declineCredex** (PUT)

   - Function: Declines a Credex offer.
   - Required variables:
     - credexID: string

5. **cancelCredex** (PUT)

   - Function: Cancels a Credex offer.
   - Required variables:
     - credexID: string

6. **getCredex** (GET)

   - Function: Retrieves information about a specific Credex.
   - Required variables:
     - credexID: string
     - accountID: string

7. **getLedger** (GET)
   - Function: Retrieves ledger information for an account.
   - Required variables:
     - accountID: string
   - Optional variables:
     - numRows: number
     - startRow: number

These endpoints provide comprehensive Credex management capabilities within the ecosystem. The offerCredex endpoint allows for the creation of new Credex offers, while acceptCredex and acceptCredexBulk facilitate the acceptance of these offers individually or in bulk. The declineCredex and cancelCredex endpoints provide options for rejecting or withdrawing Credex offers. The getCredex endpoint allows for retrieving detailed information about a specific Credex, and getLedger provides access to an account's transaction history. Together, these endpoints enable the full lifecycle management of Credexes within the ecosystem, from creation and acceptance to cancellation and historical tracking.

# Avatar

This module handles operations related to Avatars in the Credex ecosystem. Avatars are nodes that members can delegate signing authority to. Currently, the only Avatar implemented is a Recurring transaction. Once this Avatar is signed by the counterparties, it activates on the schedule agreed by the counterparties to create a Credex using the data agreed between the counterparties. The trail of accountability is maintained because the creation of an Avatar must be signed by the counterparties, and the Avatar signs every Credex it creates.

The Avatar module exposes the following endpoints:

1. **requestRecurring** (POST)

   - Function: Creates a new recurring transaction request.
   - Required variables:
     - signerMemberID: string
     - requestorAccountID: string
     - counterpartyAccountID: string
     - InitialAmount: number
     - Denomination: string
     - nextPayDate: string
     - daysBetweenPays: number
   - Optional variables:
     - securedCredex: boolean
     - credspan: number
     - remainingPays: number
   - Requires either securedCredex = true or a credspan between 7 and 35.
   - remainingPays is set when the avatar will run a specific number of times before completion, and not set when the avatar is to continue indefinitely.

2. **acceptRecurring** (POST)

   - Function: Accepts a recurring transaction request.
   - Required variables:
     - avatarID: string
     - signerID: string

3. **cancelRecurring** (POST)
   - Function: Cancels an active recurring transaction or declines a pending request.
   - Required variables:
     - signerID: string
     - cancelerAccountID: string
     - avatarID: string

These endpoints provide functionality for managing recurring transactions within the Credex ecosystem:

- The requestRecurring endpoint allows for the creation of new recurring transaction requests. It sets up the details of the recurring transaction, including the accounts involved, the amount, denomination, frequency, and duration.

- The acceptRecurring endpoint facilitates the acceptance of these requests. When a recurring transaction is accepted, it becomes active and will automatically create Credex transactions according to the specified schedule.

- The cancelRecurring endpoint enables the cancellation of an active recurring transaction or the declination of a pending request. This provides flexibility for users to modify or end recurring arrangements as needed.

The Avatar module enhances the automation and flexibility of transactions within the Credex ecosystem by allowing members to set up recurring transactions. This feature is particularly useful for regular payments, subscriptions, or any other scenario where periodic transactions are required. The implementation maintains accountability by requiring explicit acceptance of recurring transaction requests and allowing for their cancellation at any time.

# Admin

This module is coming soon.

# DevAdmin

This module is under construction.

# To run the credex ecosystem in your local dev environment

### Prerequisites

Before running this project, make sure you have the following installed:

- Node.js (version 18.X.X or higher)
- npm (version X.X.X or higher)

### Installation

1. Clone the repository:

   ```bash
   git clone https://github.com/Credex/credex-core.git
   ```

2. Navigate to the project directory:

   ```bash
   cd credex-core
   ```

   Create a branch from the 'dev' branch.

3. Install the dependencies:

   ```bash
   npm install
   ```

### Running the Project

To run the project using nodemon, follow these steps:

1. Install nodemon globally (if not already installed):

   ```bash
   npm install -g nodemon
   ```

   This will install nodemon globally on your system.

2. Open a terminal and navigate to the project directory.

3. Run the following command:

   ```bash
   npm run nodemon
   ```

   This command will start the project using nodemon, which will automatically restart the server whenever changes are made to the code.

4. Open postman and visit `http://localhost:5000` to access the project endpoints.

# To run on a Codespaces virtual machine

### Prerequisites and installation

Executed automatically via devcontainer.

### Start the development server

```bash
npm run nodemon
```

This command will start the project using nodemon, which will automatically restart the server whenever changes are made to the code.

### Use Postman for endpoints

1. Click the icon for the Postman extension in the sidebar and sign in. You may need to use the authorization token provided by Postman. Open the Credex Team Workspace.

2. In the codespaces terminal, print the Github Token with

```
echo $GITHUB_TOKEN
```

Copy the token and paste it the "X-Github-Token" field in the credex-core variables in Postman. A new token is created every codespae session. If the codespace stops, this step has to be completed again.

3. After `npm run nodemon`, copy the forwarded port address from the Ports tab and paste it in the "base_url" field in the credex-core variables in Postman. This url will remain constant for this specific codespace, even across multiple sessions.

The github token and base_url are currently saved globally in Postman, so if multiple people are working at the same time, we'll need to update Postman to handle that.

# ledgerSpace schema

```mermaid
graph TB
    D[Daynode]

    subgraph Members
        M1[Member]
        M2[Member]
    end

    subgraph Accounts
        A1[Account]
        A2[Account]
        A3[Account]
    end

    subgraph Credexes
        C1[Credex]
        C2[Credex]
        C3[Credex]
        LA[LoopAnchor]
    end

    M1 --> |OWNS| A1
    M1 --> |OWNS| A2
    M2 --> |OWNS| A3

    A1 --> |OWES/CLEARED| C1
    C1 --> |OWES/CLEARED| A2
    A2 --> |OWES/CLEARED| C2
    C2 --> |OWES/CLEARED| A3
    A3 --> |OWES/CLEARED| C3
    C3 --> |OWES/CLEARED| A1

    A1 --> |OFFERS/REQUESTS| C1
    C1 --> |OFFERS/REQUESTS| A2
    A2 --> |OFFERS/REQUESTS| C2
    C2 --> |OFFERS/REQUESTS| A3
    A3 --> |OFFERS/REQUESTS| C3
    C3 --> |OFFERS/REQUESTS| A1

    A1 --> |OFFERED/REQUESTED| C1
    C1 --> |OFFERED/REQUESTED| A2
    A2 --> |OFFERED/REQUESTED| C2
    C2 --> |OFFERED/REQUESTED| A3
    A3 --> |OFFERED/REQUESTED| C3
    C3 --> |OFFERED/REQUESTED| A1

    C1 --> |REDEEMED| LA
    C2 --> |REDEEMED| LA
    C3 --> |REDEEMED| LA

    C1 --> |CREDLOOP| C2
    C2 --> |CREDLOOP| C3
    C3 --> |CREDLOOP| C1

    M1 --> |CREATED_ON| D
    M2 --> |CREATED_ON| D
    A1 --> |CREATED_ON| D
    A2 --> |CREATED_ON| D
    A3 --> |CREATED_ON| D
    C1 --> |CREATED_ON| D
    C2 --> |CREATED_ON| D
    C3 --> |CREATED_ON| D
    LA --> |CREATED_ON| D
```

\*\* relationship names separated by "/" indicates that only one of those relationship types can exist between the two nodes.

## Node Properties

### Member

- memberID: string
- memberHandle: string
- firstname: string
- lastname: string
- phone: string
- email: string
- memberTier: number

### Account

- accountID: string
- accountHandle: string
- accountName: string
- accountType: string
- DCOgiveInCXX: number
- DCOdenom: string
- queueStatus: string

### Credex

- credexID: string
- InitialAmount: number
- OutstandingAmount: number
- RedeemedAmount: number
- DefaultedAmount: number
- WrittenOffAmount: number
- Denomination: string
- CXXmultiplier: number
- credexType: string
- dueDate: Date
- DateRedeemed: Date
- queueStatus: string

### LoopAnchor

- loopID: string
- loopedAt: DateTime
- LoopedAmount: number
- CXXmultiplier: number
- Denomination: string

### Daynode

- Date: Date
- Active: boolean
- DCOrunningNow: boolean
- MTQrunningNow: boolean
- CXXprior_CXXcurrent: number
- CXX: number
- USD: number
- CAD: number
- ZiG: number

## Relationship Properties

### OWNS

- (No properties)

### OWES/CLEARED

- (No properties)

### OFFERS/REQUESTS

- (No properties)

### OFFERED/REQUESTED

- (No properties)

### REDEEMED

- AmountRedeemed: number
- AmountOutstandingNow: number
- Denomination: string
- CXXmultiplier: number
- createdAt: DateTime
- redeemedRelID: string

### CREDLOOP

- AmountRedeemed: number
- AmountOutstandingNow: number
- Denomination: string
- CXXmultiplier: number
- createdAt: DateTime
- loopID: string
- credloopRelID: string

### CREATED_ON

- (No properties)

### CREATED_ON

- (No properties)

# searchSpace schema

The SearchSpace schema represents a simplified and optimized version of the ledger space, designed for efficient loop finding in the Credex ecosystem. This schema is optimized to facilitate the resource-efficient identification of credloops for the Minute Transaction Queue (MTQ) process.

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#4a4a4a', 'primaryTextColor': '#fff', 'primaryBorderColor': '#7C0000', 'lineColor': '#F8B229', 'secondaryColor': '#006100', 'tertiaryColor': '#fff'}}}%%

graph TD
    %% Nodes
    A1[Account 1]:::accountNode
    A2[Account 2]:::accountNode
    A3[Account 3]:::accountNode
    SA1[FLOATING]:::searchAnchorFloating
    SA2[USD_SECURED]:::searchAnchorUSDSecured
    SA3[CAD_SECURED]:::searchAnchorCADSecured
    C1[Credex 1]:::credexNode
    C2[Credex 2]:::credexNode
    C3[Credex 3]:::credexNode
    C4[Credex 4]:::credexNode

    %% Relationships
    A1 --> |FLOATING| SA1
    SA1 --> |FLOATING| A2
    A2 --> |USD_SECURED| SA2
    SA2 --> |USD_SECURED| A3
    A2 --> |CAD_SECURED| SA3
    SA3 --> |CAD_SECURED| A3
    SA1 --> |SEARCH_SECURED| C1
    SA2 --> |SEARCH_SECURED| C2
    SA3 --> |SEARCH_SECURED| C3
    SA3 --> |SEARCH_SECURED| C4

    %% Styles
    classDef accountNode fill:#3498db,stroke:#2980b9,color:#fff,rx:10,ry:10;
    classDef searchAnchorFloating fill:#006400,stroke:#004d00,color:#fff,rx:10,ry:10;
    classDef searchAnchorUSDSecured fill:#b87333,stroke:#a66a2e,color:#fff,rx:10,ry:10;
    classDef searchAnchorCADSecured fill:#008080,stroke:#006666,color:#fff,rx:10,ry:10;
    classDef credexNode fill:#4B0082,stroke:#3B0062,color:#fff,rx:10,ry:10;

```

## Node properties

### Account

- accountID: string
- accountName: string

### SearchAnchor

- searchAnchorID: string
- earliestDueDate: Date

### Credex

- credexID: string
- outstandingAmount: number
- Denomination: string
- CXXmultiplier: number
- dueDate: Date

## Relationship Properties

### FLOATING

- (No properties)

### USD_SECURED, CAD_SECURED

- (No properties)

### SEARCH_SECURED

- (No properties)

## Explanation

1. **Accounts**: Represented by blue nodes, these are simplified versions of the accounts in the ledger space. They contain only essential information needed for loop finding.

2. **SearchAnchors**: These nodes come in three types:

   - FLOATING (dark green): Represent unsecured credit relationships between accounts.
   - USD_SECURED (copper): Represent secured credit relationships in USD.
   - CAD_SECURED (teal): Represent secured credit relationships in CAD.

3. **Credexes**: Shown as dark purple nodes, these represent individual credit transactions in the system.

4. **Relationships**:
   - FLOATING (dark green): Connects accounts to floating SearchAnchors, representing unsecured credit relationships.
   - USD_SECURED (copper): Connect accounts to USD_SECURED SearchAnchors, representing secured credit relationships in USD.
   - CAD_SECURED (teal): Connect accounts to CAD_SECURED SearchAnchors, representing secured credit relationships in CAD.
   - SEARCH_SECURED (dark purple): Links SearchAnchors to Credexes, allowing for efficient traversal during loop finding.

This optimized structure allows the Minute Transaction Queue to quickly identify potential credit loops by traversing the relationships between Accounts, SearchAnchors, and Credexes. The use of SearchAnchors as intermediary nodes between Accounts and Credexes significantly reduces the complexity of loop finding algorithms, enabling faster processing of transactions in the Credex ecosystem.



File: ./tsconfig.json
----------------------------------------
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./build"
  },
  "include": [
    "src/**/*.ts",
    "config/authenticate.ts",
    "config/config.ts",
    "config/swagger.ts"
  ],
  "exclude": ["node_modules"]
}



File: ./src/Account/controllers/authorizeForAccount.ts
----------------------------------------
import express from "express";
import { AuthorizeForAccountService } from "../services/AuthorizeForAccount";
import logger from "../../../config/logger";

/**
 * Controller for authorizing a member for an account
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function AuthorizeForAccountController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const requiredFields = ["memberHandleToBeAuthorized", "accountID", "ownerID"];

  try {
    for (const field of requiredFields) {
      if (!req.body[field]) {
        res.status(400).json({ message: `${field} is required` });
        return;
      }
    }

    const { memberHandleToBeAuthorized, accountID, ownerID } = req.body;

    // Validate memberHandleToBeAuthorized
    if (typeof memberHandleToBeAuthorized !== 'string' || !/^[a-z0-9._]{3,30}$/.test(memberHandleToBeAuthorized)) {
      res.status(400).json({ message: "Invalid memberHandleToBeAuthorized. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters." });
      return;
    }

    // Validate accountID
    if (typeof accountID !== 'string' || !/^[a-f0-9-]{36}$/.test(accountID)) {
      res.status(400).json({ message: "Invalid accountID. Must be a valid UUID." });
      return;
    }

    // Validate ownerID
    if (typeof ownerID !== 'string' || !/^[a-f0-9-]{36}$/.test(ownerID)) {
      res.status(400).json({ message: "Invalid ownerID. Must be a valid UUID." });
      return;
    }

    logger.info("Authorizing member for account", { memberHandleToBeAuthorized, accountID, ownerID });

    const responseData = await AuthorizeForAccountService(
      memberHandleToBeAuthorized,
      accountID,
      ownerID
    );

    if (!responseData) {
      logger.warn("Failed to authorize member for account", { memberHandleToBeAuthorized, accountID, ownerID });
      res.status(400).json({ message: "Failed to authorize member for account" });
      return;
    }

    if (responseData.message === "accounts not found") {
      logger.warn("Accounts not found during authorization", { memberHandleToBeAuthorized, accountID, ownerID });
      res.status(404).json({ message: "Accounts not found" });
      return;
    }

    if (responseData.message === "Limit of 5 authorized accounts reached. Remove an authorized account if you want to add another.") {
      logger.warn("Authorization limit reached", { memberHandleToBeAuthorized, accountID, ownerID });
      res.status(400).json({ message: responseData.message });
      return;
    }

    if (responseData.message === "You can only authorize someone to transact on behalf of your account when you are on the Entrepreneur tier or above.") {
      logger.warn("Insufficient tier for authorization", { memberHandleToBeAuthorized, accountID, ownerID });
      res.status(403).json({ message: responseData.message });
      return;
    }

    logger.info("Member authorized for account successfully", { memberHandleToBeAuthorized, accountID, ownerID });
    res.status(200).json(responseData);
  } catch (error) {
    logger.error("Error in AuthorizeForAccountController", { error, memberHandleToBeAuthorized: req.body.memberHandleToBeAuthorized, accountID: req.body.accountID, ownerID: req.body.ownerID });
    next(error);
  }
}



File: ./src/Account/controllers/updateSendOffersTo.ts
----------------------------------------
import express from "express";
import { UpdateSendOffersToService } from "../services/UpdateSendOffersTo";
import logger from "../../../config/logger";

/**
 * Controller for updating the recipient of offers for an account
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function UpdateSendOffersToController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const requiredFields = ["memberIDtoSendOffers", "accountID", "ownerID"];

  try {
    for (const field of requiredFields) {
      if (!req.body[field]) {
        res.status(400).json({ message: `${field} is required` });
        return;
      }
    }

    const { memberIDtoSendOffers, accountID, ownerID } = req.body;

    // Validate memberIDtoSendOffers
    if (typeof memberIDtoSendOffers !== 'string' || !/^[a-f0-9-]{36}$/.test(memberIDtoSendOffers)) {
      res.status(400).json({ message: "Invalid memberIDtoSendOffers. Must be a valid UUID." });
      return;
    }

    // Validate accountID
    if (typeof accountID !== 'string' || !/^[a-f0-9-]{36}$/.test(accountID)) {
      res.status(400).json({ message: "Invalid accountID. Must be a valid UUID." });
      return;
    }

    // Validate ownerID
    if (typeof ownerID !== 'string' || !/^[a-f0-9-]{36}$/.test(ownerID)) {
      res.status(400).json({ message: "Invalid ownerID. Must be a valid UUID." });
      return;
    }

    logger.info("Updating offer recipient for account", { memberIDtoSendOffers, accountID, ownerID });

    const responseData = await UpdateSendOffersToService(
      memberIDtoSendOffers,
      accountID,
      ownerID
    );

    if (!responseData) {
      logger.warn("Failed to update offer recipient for account", { memberIDtoSendOffers, accountID, ownerID });
      res.status(400).json({ message: "Failed to update offer recipient for account" });
      return;
    }

    logger.info("Offer recipient updated successfully for account", { memberIDtoSendOffers, accountID, ownerID });
    res.status(200).json(responseData);
  } catch (error) {
    logger.error("Error in UpdateSendOffersToController", { error, memberIDtoSendOffers: req.body.memberIDtoSendOffers, accountID: req.body.accountID, ownerID: req.body.ownerID });
    next(error);
  }
}



File: ./src/Account/controllers/getAccountDashboard.ts
----------------------------------------
import express from "express";
import { GetAccountDashboardService } from "../services/GetAccountDashboard";

export async function GetAccountDashboardController(
  req: express.Request,
  res: express.Response
) {
  const { memberID, accountID } = req.body;

  if (!memberID || !accountID) {
    return res.status(400).json({ message: "memberID and accountID are required" });
  }

  try {
    const accountDashboard = await GetAccountDashboardService(memberID, accountID);

    if (!accountDashboard) {
      return res.status(404).json({ message: "Account dashboard not found" });
    }

    return res.status(200).json(accountDashboard);
  } catch (error) {
    console.error("Error getting account dashboard:", error);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}


File: ./src/Account/controllers/updateAccount.ts
----------------------------------------
import express from "express";
import { UpdateAccountService } from "../services/UpdateAccount";
import logger from "../../../config/logger";
import { getDenominations } from "../../Core/constants/denominations";

/**
 * Controller for updating an account
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function UpdateAccountController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const requiredFields = ["ownerID", "accountID"];

  try {
    for (const field of requiredFields) {
      if (!req.body[field]) {
        res.status(400).json({ message: `${field} is required` });
        return;
      }
    }

    const { ownerID, accountID, accountName, accountHandle, defaultDenom } = req.body;

    // Validate ownerID
    if (typeof ownerID !== 'string' || !/^[a-f0-9-]{36}$/.test(ownerID)) {
      res.status(400).json({ message: "Invalid ownerID. Must be a valid UUID." });
      return;
    }

    // Validate accountID
    if (typeof accountID !== 'string' || !/^[a-f0-9-]{36}$/.test(accountID)) {
      res.status(400).json({ message: "Invalid accountID. Must be a valid UUID." });
      return;
    }

    // Validate accountName if provided
    if (accountName && (typeof accountName !== 'string' || accountName.length < 3 || accountName.length > 50)) {
      res.status(400).json({ message: "Invalid accountName. Must be a string between 3 and 50 characters." });
      return;
    }

    // Validate accountHandle if provided
    if (accountHandle && (typeof accountHandle !== 'string' || !/^[a-z0-9._]{3,30}$/.test(accountHandle))) {
      res.status(400).json({ message: "Invalid accountHandle. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters." });
      return;
    }

    // Validate defaultDenom if provided
    if (defaultDenom && (!getDenominations({ code: defaultDenom }).length)) {
      res.status(400).json({ message: "Invalid defaultDenom. Must be a valid denomination." });
      return;
    }

    logger.info("Updating account", { ownerID, accountID, accountName, accountHandle, defaultDenom });

    const updatedAccountID = await UpdateAccountService(
      ownerID,
      accountID,
      accountName,
      accountHandle,
      defaultDenom
    );

    if (updatedAccountID) {
      logger.info("Account updated successfully", { updatedAccountID });
      res.status(200).json({ message: `Account updated successfully`, accountID: updatedAccountID });
    } else {
      logger.warn("Account not found or no update performed", { ownerID, accountID });
      res.status(404).json({ message: "Account not found or no update performed" });
    }
  } catch (error) {
    logger.error("Error in UpdateAccountController", { error, ownerID: req.body.ownerID, accountID: req.body.accountID });
    next(error);
  }
}



File: ./src/Account/controllers/createAccount.ts
----------------------------------------
import express from "express";
import { CreateAccountService } from "../services/CreateAccount";
import { getDenominations } from "../../Core/constants/denominations";
import { checkPermittedAccountType } from "../../Core/constants/accountTypes";
import logger from "../../../config/logger";

/**
 * Controller for creating a new account
 * @param req - Express request object
 * @param res - Express response object
 */
export async function CreateAccountController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): Promise<void> {
  const fieldsRequired = [
    "ownerID",
    "accountType",
    "accountName",
    "accountHandle",
    "defaultDenom",
  ];

  try {
    // Validate required fields
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        res.status(400).json({ message: `${field} is required` });
        return;
      }
    }

    const { ownerID, accountType, accountName, accountHandle, defaultDenom, DCOgiveInCXX, DCOdenom } = req.body;

    // Validate defaultDenom
    if (!getDenominations({ code: defaultDenom }).length) {
      res.status(400).json({ message: "defaultDenom not in denoms" });
      return;
    }

    // Validate accountType
    if (!checkPermittedAccountType(accountType)) {
      res.status(400).json({ message: "accountType not permitted" });
      return;
    }

    // Validate and transform accountHandle
    const transformedAccountHandle = accountHandle.toLowerCase().replace(/\s/g, "");
    if (!/^[a-z0-9._]{3,30}$/.test(transformedAccountHandle)) {
      res.status(400).json({
        message: "Invalid account handle. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters.",
      });
      return;
    }

    // Validate accountName length
    if (accountName.length < 4 || accountName.length > 30) {
      res.status(400).json({ message: "accountName must be between 4 and 30 characters" });
      return;
    }

    // Validate DCOdenom if provided
    if (DCOdenom && !getDenominations({ code: DCOdenom }).length) {
      res.status(400).json({ message: "DCOdenom not in denoms" });
      return;
    }

    // Validate DCOgiveInCXX if provided
    if (DCOgiveInCXX && (isNaN(DCOgiveInCXX) || DCOgiveInCXX < 0)) {
      res.status(400).json({ message: "DCOgiveInCXX must be a non-negative number" });
      return;
    }

    logger.info("Creating new account", {
      ownerID,
      accountType,
      accountName,
      accountHandle: transformedAccountHandle,
      defaultDenom,
      DCOdenom,
    });

    const newAccount = await CreateAccountService(
      ownerID,
      accountType,
      accountName,
      transformedAccountHandle,
      defaultDenom,
      DCOgiveInCXX,
      DCOdenom
    );

    if (newAccount.accountID) {
      logger.info("Account created successfully", { accountID: newAccount.accountID });
      res.status(201).json({ accountID: newAccount.accountID, message: "Account created successfully" });
    } else {
      res.status(400).json({ message: newAccount.message || "Failed to create account" });
    }
  } catch (error) {
    logger.error("Error in CreateAccountController", { error });
    next(error);
  }
}



File: ./src/Account/controllers/unauthorizeForAccount.ts
----------------------------------------
import express from "express";
import { UnauthorizeForCompanyService } from "../services/UnauthorizeForAccount";
import logger from "../../../config/logger";

/**
 * Controller for unauthorizing a member for an account
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function UnauthorizeForAccountController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const requiredFields = ["memberIDtoBeUnauthorized", "accountID", "ownerID"];

  try {
    for (const field of requiredFields) {
      if (!req.body[field]) {
        res.status(400).json({ message: `${field} is required` });
        return;
      }
    }

    const { memberIDtoBeUnauthorized, accountID, ownerID } = req.body;

    // Validate memberIDtoBeUnauthorized
    if (typeof memberIDtoBeUnauthorized !== 'string' || !/^[a-f0-9-]{36}$/.test(memberIDtoBeUnauthorized)) {
      res.status(400).json({ message: "Invalid memberIDtoBeUnauthorized. Must be a valid UUID." });
      return;
    }

    // Validate accountID
    if (typeof accountID !== 'string' || !/^[a-f0-9-]{36}$/.test(accountID)) {
      res.status(400).json({ message: "Invalid accountID. Must be a valid UUID." });
      return;
    }

    // Validate ownerID
    if (typeof ownerID !== 'string' || !/^[a-f0-9-]{36}$/.test(ownerID)) {
      res.status(400).json({ message: "Invalid ownerID. Must be a valid UUID." });
      return;
    }

    logger.info("Unauthorizing member for account", { memberIDtoBeUnauthorized, accountID, ownerID });

    const responseData = await UnauthorizeForCompanyService(
      memberIDtoBeUnauthorized,
      accountID,
      ownerID
    );

    if (!responseData) {
      logger.warn("Failed to unauthorize member for account", { memberIDtoBeUnauthorized, accountID, ownerID });
      res.status(400).json({ message: "Failed to unauthorize member for the account" });
      return;
    }

    logger.info("Member unauthorized for account successfully", { memberIDtoBeUnauthorized, accountID, ownerID });
    res.status(200).json(responseData);
  } catch (error) {
    logger.error("Error in UnauthorizeForAccountController", { error, memberIDtoBeUnauthorized: req.body.memberIDtoBeUnauthorized, accountID: req.body.accountID, ownerID: req.body.ownerID });
    next(error);
  }
}



File: ./src/Account/controllers/getAccountByHandle.ts
----------------------------------------
import express from "express";
import { GetAccountByHandleService } from "../services/GetAccountByHandle";
import logger from "../../../config/logger";

/**
 * Controller for retrieving an account by its handle
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function GetAccountByHandleController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { accountHandle } = req.body;

  try {
    if (!accountHandle || typeof accountHandle !== 'string') {
      res.status(400).json({ message: "accountHandle is required and must be a string" });
      return;
    }

    // Validate accountHandle format
    if (!/^[a-z0-9._]{3,30}$/.test(accountHandle)) {
      res.status(400).json({
        message: "Invalid account handle. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters.",
      });
      return;
    }

    logger.info("Retrieving account by handle", { accountHandle });

    const accountData = await GetAccountByHandleService(accountHandle);

    if (accountData) {
      logger.info("Account retrieved successfully", { accountHandle });
      res.status(200).json({ accountData });
    } else {
      logger.info("Account not found", { accountHandle });
      res.status(404).json({ message: "Account not found" });
    }
  } catch (error) {
    logger.error("Error in GetAccountByHandleController", { error, accountHandle });
    next(error);
  }
}



File: ./src/Account/accountRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { CreateAccountController } from "./controllers/createAccount";
import { GetAccountByHandleController } from "./controllers/getAccountByHandle";
import { UpdateAccountController } from "./controllers/updateAccount";
import { AuthorizeForAccountController } from "./controllers/authorizeForAccount";
import { UnauthorizeForAccountController } from "./controllers/unauthorizeForAccount";
import { UpdateSendOffersToController } from "./controllers/updateSendOffersTo";

export default function AccountRoutes(
  app: express.Application,
  jsonParser: any
) {
  /**
   * @swagger
   * /api/v1/createAccount:
   *   post:
   *     summary: Create a new account
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - ownerID
   *               - accountType
   *               - accountName
   *               - accountHandle
   *               - defaultDenom
   *             properties:
   *               ownerID:
   *                 type: string
   *               accountType:
   *                 type: string
   *               accountName:
   *                 type: string
   *               accountHandle:
   *                 type: string
   *               defaultDenom:
   *                 type: string
   *     responses:
   *       200:
   *         description: Account created successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}createAccount`,
    jsonParser,
    CreateAccountController
  );

  /**
   * @swagger
   * /api/v1/getAccountByHandle:
   *   get:
   *     summary: Get account by handle
   *     tags: [Accounts]
   *     parameters:
   *       - in: query
   *         name: accountHandle
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Account retrieved successfully
   *       400:
   *         description: Bad request
   *       404:
   *         description: Account not found
   */
  app.get(
    `${apiVersionOneRoute}getAccountByHandle`,
    jsonParser,
    GetAccountByHandleController
  );

  /**
   * @swagger
   * /api/v1/updateAccount:
   *   patch:
   *     summary: Update account information
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - ownerID
   *               - accountID
   *             properties:
   *               ownerID:
   *                 type: string
   *               accountID:
   *                 type: string
   *               accountName:
   *                 type: string
   *               accountHandle:
   *                 type: string
   *               defaultDenom:
   *                 type: string
   *     responses:
   *       200:
   *         description: Account updated successfully
   *       400:
   *         description: Bad request
   *       404:
   *         description: Account not found
   */
  app.patch(
    `${apiVersionOneRoute}updateAccount`,
    jsonParser,
    UpdateAccountController
  );

  /**
   * @swagger
   * /api/v1/authorizeForAccount:
   *   post:
   *     summary: Authorize a member for an account
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - memberHandleToBeAuthorized
   *               - accountID
   *               - ownerID
   *             properties:
   *               memberHandleToBeAuthorized:
   *                 type: string
   *               accountID:
   *                 type: string
   *               ownerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Member authorized successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}authorizeForAccount`,
    jsonParser,
    AuthorizeForAccountController
  );

  /**
   * @swagger
   * /api/v1/unauthorizeForAccount:
   *   post:
   *     summary: Unauthorize a member for an account
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - memberIDtoBeUnauthorized
   *               - accountID
   *               - ownerID
   *             properties:
   *               memberIDtoBeUnauthorized:
   *                 type: string
   *               accountID:
   *                 type: string
   *               ownerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Member unauthorized successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}unauthorizeForAccount`,
    jsonParser,
    UnauthorizeForAccountController
  );

  /**
   * @swagger
   * /api/v1/updateSendOffersTo:
   *   post:
   *     summary: Update the member to receive offers for an account
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - memberIDtoSendOffers
   *               - accountID
   *               - ownerID
   *             properties:
   *               memberIDtoSendOffers:
   *                 type: string
   *               accountID:
   *                 type: string
   *               ownerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Send offers recipient updated successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}updateSendOffersTo`,
    jsonParser,
    UpdateSendOffersToController
  );
}



File: ./src/Account/services/UnauthorizeForAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function UnauthorizeForCompanyService(
  memberIDtoBeUnauthorized: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH
                (memberToUnauthorize:Member { memberID: $memberIDtoBeUnauthorized })
                -[authRel:AUTHORIZED_FOR]->(account:Account { accountID: $accountID })
                <-[:OWNS]-(owner:Member { memberID: $ownerID })
            DELETE authRel
            RETURN
                account.accountID AS accountID,
                memberToUnauthorize.accountID AS memberToUnauthorize
        `,
      {
        memberIDtoBeUnauthorized,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      console.log("could not unauthorize account");
      return false;
    }
    const record = result.records[0];

    console.log(
      `account ${record.get(
        "memberToUnauthorize"
      )} unauthorized to transact for ${record.get("accountID")}`
    );
    return true;
  } catch (error) {
    console.error("Error unauthorizing account:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/GetAccountByHandle.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function GetAccountByHandleService(
  accountHandle: string
): Promise<any | null> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  if (!accountHandle) {
    console.log("accountHandle is required");
    return null;
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH (account:Account { accountHandle: $accountHandle })
            RETURN
              account.accountID AS accountID,
              account.accountName AS accountName
        `,
      { accountHandle }
    );

    if (!result.records.length) {
      console.log("account not found");
      return null;
    }

    const accountID = result.records[0].get("accountID");
    const accountName = result.records[0].get("accountName");

    return {
      accountID: accountID,
      accountName: accountName,
    };
  } catch (error) {
    console.error("Error fetching account data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/UpdateAccount.ts
----------------------------------------
/*
updates data for a account

requires object of account data to be updated
field required: accountID

fields that can be updated:
    firstname
    lastname
    companyname
    phone
    accountHandle
    DailyCredcoinOfferingGive
    DailyCredcoinOfferingDenom

if extraneous data or data not matching criteria is included it will be ignored, data
that fits criteria (if any) will still be updated, and success message will be returned

returns accountID of updated account

returns null on error
*/

import { ledgerSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../../Core/constants/denominations";

export async function UpdateAccountService(
  ownerID: string,
  accountID: string,
  accountName: string,
  accountHandle: string,
  defaultDenom: string
) {
  // Validation: Check defaultDenom in denominations
  if (!getDenominations({ code: defaultDenom }).length) {
    const message = "defaultDenom not in denoms";
    console.log(message);
    return false;
  }

  const dataToUpdate = {
    accountName: accountName,
    accountHandle: accountHandle,
    defaultDenom: defaultDenom,
  };

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH
          (owner:Member { memberID: $ownerID })
          -[:OWNS]->
          (account:Account { accountID: $accountID })
        SET account += $dataToUpdate
        RETURN account.accountID AS accountID
            `,
      { ownerID, accountID, dataToUpdate }
    );

    if (!result.records[0].get("accountID")) {
      return false;
    }

    return result.records[0].get("accountID");
  } catch (error) {
    console.error("Error updating account data:", error);
    return null;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/UpdateSendOffersTo.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function UpdateSendOffersToService(
  memberIDtoSendOffers: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH
                (newMemberForOffers: Member { memberID: $memberIDtoSendOffers})
                -[:AUTHORIZED_FOR]->(account:Account { accountID: $accountID})
                <-[:OWNS]-(owner:Member { memberID: $ownerID}),
                (account)-[currentAccountForOffersRel:SEND_OFFERS_TO]->(:Member)
            DELETE currentAccountForOffersRel
            CREATE (account)-[:SEND_OFFERS_TO]->(newMemberForOffers)
            RETURN true
            `,
      {
        memberIDtoSendOffers,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      return false;
    }

    return true;
  } catch (error) {
    console.error(
      "Error updating account to receive offer notifications:",
      error
    );
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/GetAccountDashboard.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { GetBalancesService } from "./GetBalances";
import { GetPendingOffersInService } from "../../Credex/services/GetPendingOffersIn";
import { GetPendingOffersOutService } from "../../Credex/services/GetPendingOffersOut";

export async function GetAccountDashboardService(
  memberID: string,
  accountID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    interface AuthMember {
      memberID: string;
      firstname: string;
      lastname: string;
    }

    interface AccountData {
      accountID: string;
      accountName: string;
      accountHandle: string;
      defaultDenom: string;
      isOwnedAccount: boolean;
      sendOffersToFirstname: string;
      sendOffersToLastname: string;
      sendOffersToMemberID: string;
      authFor: AuthMember[];
      balanceData: any;
      pendingInData: any;
      pendingOutData: any;
    }

    const result = await ledgerSpaceSession.run(
      `
    MATCH
      (account:Account { accountID: $accountID })
      <-[:AUTHORIZED_FOR]-
      (member:Member { memberID: $memberID})
    MATCH
      (account)<-[:AUTHORIZED_FOR]-(allAuthMembers)
    OPTIONAL MATCH
      (account)<-[owns:OWNS]-(member)
    OPTIONAL MATCH
      (account)-[:SEND_OFFERS_TO]->(sendOffersTo:Member)
    RETURN
      account.accountID AS accountID,
      account.accountType AS accountType,
      account.accountName AS accountName,
      account.accountHandle AS accountHandle,
      account.defaultDenom AS defaultDenom,
      sendOffersTo.firstname AS sendOffersToFirstname,
      sendOffersTo.lastname AS sendOffersToLastname,
      sendOffersTo.memberID AS sendOffersToMemberID,
      owns IS NOT NULL AS isOwnedAccount,
      allAuthMembers.firstname AS authMemberFirstname,
      allAuthMembers.lastname AS authMemberLastname,
      allAuthMembers.memberID AS authMemberID
  `,
      { memberID, accountID }
    );

    if (!result.records.length) {
      console.log("account not found");
      return null;
    }

    const accountData: AccountData = {
      accountID: result.records[0].get("accountID"),
      accountName: result.records[0].get("accountName"),
      accountHandle: result.records[0].get("accountHandle"),
      defaultDenom: result.records[0].get("defaultDenom"),
      isOwnedAccount: result.records[0].get("isOwnedAccount"),
      sendOffersToFirstname: "",
      sendOffersToLastname: "",
      sendOffersToMemberID: "",
      authFor: [],
      balanceData: [],
      pendingInData: [],
      pendingOutData: [],
    };

    if (accountData.isOwnedAccount) {
      (accountData.sendOffersToFirstname = result.records[0].get(
        "sendOffersToFirstname"
      )),
        (accountData.sendOffersToLastname = result.records[0].get(
          "sendOffersToLastname"
        )),
        (accountData.sendOffersToMemberID = result.records[0].get(
          "sendOffersToMemberID"
        )),
        result.records.forEach((record) => {
          accountData.authFor.push({
            memberID: record.get("authMemberID"),
            firstname: record.get("authMemberFirstname"),
            lastname: record.get("authMemberLastname"),
          });
        });
    } else {
      accountData.authFor = [];
    }
    accountData.balanceData = await GetBalancesService(accountData.accountID);
    accountData.pendingInData = await GetPendingOffersInService(
      accountData.accountID
    );
    accountData.pendingOutData = await GetPendingOffersOutService(
      accountData.accountID
    );

    return accountData;
  } catch (error) {
    console.error("Error fetching account data:", error);
    return null;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/GetBalances.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";

export async function GetBalancesService(accountID: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    const getSecuredBalancesQuery = await ledgerSpaceSession.run(
      `
      MATCH (account:Account {accountID: $accountID})

      // Get all unique denominations from Credex nodes related to the account
      OPTIONAL MATCH (account)-[:OWES|OFFERED]-(securedCredex:Credex)<-[:SECURES]-()
      WITH DISTINCT securedCredex.Denomination AS denom, account

      // Aggregate incoming secured amounts for each denomination ensuring uniqueness
      OPTIONAL MATCH (account)<-[:OWES]-(inSecuredCredex:Credex {Denomination: denom})<-[:SECURES]-()
      WITH denom, account, 
          collect(DISTINCT inSecuredCredex) AS inSecuredCredexes

      // Aggregate outgoing secured amounts for each denomination ensuring uniqueness
      OPTIONAL MATCH (account)-[:OWES|OFFERED]->(outSecuredCredex:Credex {Denomination: denom})<-[:SECURES]-()
      WITH denom, 
          reduce(s = 0, n IN inSecuredCredexes | s + n.OutstandingAmount) AS sumSecuredIn, 
          collect(DISTINCT outSecuredCredex) AS outSecuredCredexes

      // Calculate the total outgoing amount
      WITH denom, sumSecuredIn, 
          reduce(s = 0, n IN outSecuredCredexes | s + n.OutstandingAmount) AS sumSecuredOut

      // Get the current day node which should have active status
      MATCH (daynode:Daynode {Active: true})

      // Calculate the net secured balance for each denomination and return the result
      RETURN denom, (sumSecuredIn - sumSecuredOut) / daynode[denom] AS netSecured
      `,
      { accountID }
    );

    const securedNetBalancesByDenom: string[] = getSecuredBalancesQuery.records
      .filter((record) => {
        const amount = record.get("netSecured");
        return typeof amount === "number" && isFinite(amount) && amount !== 0;
      })
      .map((record) => {
        const denom = record.get("denom");
        const amount = record.get("netSecured");
        return `${denomFormatter(amount, denom)} ${denom}`;
      });

    const getUnsecuredBalancesAndTotalAssetsQuery =
      await ledgerSpaceSession.run(
        `
        MATCH (account:Account{accountID:$accountID})

        OPTIONAL MATCH (account)<-[:OWES]-(owesInCredexUnsecured:Credex)
        WHERE NOT (owesInCredexUnsecured)<-[:SECURES]-()
        WITH account, COLLECT(DISTINCT owesInCredexUnsecured) AS unsecuredCredexesIn

        OPTIONAL MATCH (account)-[:OWES]->(owesOutCredexUnsecured:Credex)
        WHERE NOT (owesOutCredexUnsecured)<-[:SECURES]-()
        WITH account, unsecuredCredexesIn, COLLECT(DISTINCT owesOutCredexUnsecured) AS unsecuredCredexesOut

        OPTIONAL MATCH (account)<-[:OWES]-(owesInCredexAll:Credex)
        WITH account, unsecuredCredexesIn, unsecuredCredexesOut, COLLECT(DISTINCT owesInCredexAll) AS owesInCredexesAll

        OPTIONAL MATCH (account)-[:OWES]->(owesOutCredexAll:Credex)
        WITH account, unsecuredCredexesIn, unsecuredCredexesOut, owesInCredexesAll, COLLECT(DISTINCT owesOutCredexAll) AS owesOutCredexesAll

        WITH
          account.defaultDenom AS defaultDenom,
          REDUCE(total = 0, credex IN unsecuredCredexesIn | total + credex.OutstandingAmount) AS receivablesTotalCXX,
          REDUCE(total = 0, credex IN unsecuredCredexesOut | total + credex.OutstandingAmount) AS payablesTotalCXX,
          REDUCE(total = 0, credex IN unsecuredCredexesIn | total + credex.OutstandingAmount)
            - REDUCE(total = 0, credex IN unsecuredCredexesOut | total + credex.OutstandingAmount) AS unsecuredNetCXX,
          REDUCE(total = 0, credex IN owesInCredexesAll | total + credex.OutstandingAmount)
            - REDUCE(total = 0, credex IN owesOutCredexesAll | total + credex.OutstandingAmount) AS netCredexAssetsCXX
        MATCH (daynode:Daynode{Active:true})
        RETURN
          defaultDenom,
          receivablesTotalCXX / daynode[defaultDenom] AS receivablesTotalInDefaultDenom,
          payablesTotalCXX / daynode[defaultDenom] AS payablesTotalInDefaultDenom,
          unsecuredNetCXX / daynode[defaultDenom] AS unsecuredNetInDefaultDenom,
          netCredexAssetsCXX / daynode[defaultDenom] AS netCredexAssetsInDefaultDenom
      `,
        { accountID }
      );

    const unsecuredBalancesAndTotalAssets =
      getUnsecuredBalancesAndTotalAssetsQuery.records[0];
    const defaultDenom = unsecuredBalancesAndTotalAssets.get("defaultDenom");
    const unsecuredBalancesInDefaultDenom = {
      totalPayables: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("payablesTotalInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
      totalReceivables: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("receivablesTotalInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
      netPayRec: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("unsecuredNetInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
    };

    return {
      securedNetBalancesByDenom,
      unsecuredBalancesInDefaultDenom,
      netCredexAssetsInDefaultDenom: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("netCredexAssetsInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
    };
  } catch (error) {
    console.error("Error fetching balances:", error);
    throw new Error("Failed to fetch balances. Please try again later.");
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/AuthorizeForAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function AuthorizeForAccountService(
  memberHandleToBeAuthorized: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Check that account authorization is permitted on membership tier
    const getMemberTier = await ledgerSpaceSession.run(
      `
        MATCH (member:Member{ memberID: $ownerID })
        RETURN member.memberTier as memberTier
      `,
      { ownerID }
    );

    const memberTier = getMemberTier.records[0].get("memberTier");
    if (memberTier <= 3) {
      return {
        message:
          "You can only authorize someone to transact on behalf of your account when you are on the Entrepreneur tier or above.",
      };
    }

    const result = await ledgerSpaceSession.run(
      `
        MATCH (account:Account { accountID: $accountID })
            <-[:OWNS]-(owner:Member { memberID: $ownerID })
        MATCH (memberToAuthorize:Member { memberHandle: $memberHandleToBeAuthorized })
        MATCH (:Member)-[currentAuthForRel:AUTHORIZED_FOR]->(account)
        WITH count (currentAuthForRel) AS numAuthorized, memberToAuthorize, account
        CALL apoc.do.when(
          numAuthorized >= 5,
          'RETURN "limitReached" AS message',
          'MERGE (memberToAuthorize)-[:AUTHORIZED_FOR]->(account)
            RETURN
              "accountAuthorized" AS message,
              account.accountID AS accountID,
              memberToAuthorize.memberID AS memberIDtoAuthorize',
          {
            numAuthorized: numAuthorized,
            memberToAuthorize: memberToAuthorize,
            account: account
          }
        )
        YIELD value
        RETURN
          value.message AS message,
          value.accountID AS accountID,
          value.memberIDtoAuthorize AS memberIDtoAuthorize
      `,
      {
        memberHandleToBeAuthorized,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      return {
        message: "accounts not found",
      };
    }

    const record = result.records[0];

    if (record.get("message") == "limitReached") {
      return {
        message:
          "Limit of 5 authorized accounts reached. Remove an authorized account if you want to add another.",
      };
    }

    if (record.get("message") == "accountAuthorized") {
      console.log(
        `account ${record.get(
          "memberIDtoAuthorize"
        )} authorized to transact for ${record.get("accountID")}`
      );
      return {
        message: "account authorized",
        accountID: record.get("accountID"),
        memberIdAuthorized: record.get("memberIDtoAuthorized"),
      };
    } else {
      console.log("could not authorize account");
      return false;
    }
  } catch (error) {
    console.error("Error authorizing account:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/CreateAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function CreateAccountService(
  ownerID: string,
  accountType: string,
  accountName: string,
  accountHandle: string,
  defaultDenom: string,
  DCOgiveInCXX: number | null = null,
  DCOdenom: string | null = null
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  //check that account creation is permitted on membership tier
  const getMemberTier = await ledgerSpaceSession.run(
    `
        MATCH (member:Member{ memberID: $ownerID })
        OPTIONAL MATCH (member)-[:OWNS]->(account:Account)
        RETURN
          member.memberTier AS memberTier,
          COUNT(account) AS numAccounts
      `,
    { ownerID }
  );

  const memberTier = getMemberTier.records[0].get("memberTier");
  const numAccounts = getMemberTier.records[0].get("numAccounts");
  if (memberTier <= 2 && numAccounts >= 1) {
    return {
      account: false,
      message:
        "You cannot create an account on the Open or Verified membership tiers.",
    };
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode { Active: true })
        MATCH (owner:Member { memberID: $ownerID })
        CREATE (owner)-[:OWNS]->(account:Account {
          accountType: $accountType,
          accountName: $accountName,
          accountHandle: $accountHandle,
          defaultDenom: $defaultDenom,
          DCOgiveInCXX: $DCOgiveInCXX,
          DCOdenom: $DCOdenom,
          accountID: randomUUID(),
          queueStatus: "PENDING_ACCOUNT",
          createdAt: datetime(),
          updatedAt: datetime()
        })-[:CREATED_ON]->(daynode)
        CREATE
          (owner)-[:AUTHORIZED_FOR]->
          (account)
          -[:SEND_OFFERS_TO]->(owner)
        RETURN account.accountID AS accountID
      `,
      {
        ownerID,
        accountType,
        accountName,
        accountHandle,
        defaultDenom,
        DCOgiveInCXX,
        DCOdenom,
      }
    );

    if (!result.records.length) {
      const message = "could not create account";
      console.log(message);
      return { account: false, message };
    }

    const createdAccountID = result.records[0].get("accountID");
    console.log(accountType + " account created: " + createdAccountID);
    return {
      accountID: createdAccountID,
      message: "account created",
    };
  } catch (error) {
    console.error("Error creating account:", error);

    if (
      isNeo4jError(error) &&
      error.code === "Neo.ClientError.Schema.ConstraintValidationFailed"
    ) {
      if (error.message.includes("phone")) {
        return { account: false, message: "Phone number already in use" };
      }
      if (error.message.includes("handle")) {
        return {
          account: false,
          message: "Sorry, that handle is already in use",
        };
      }
      return { account: false, message: "Required unique field not unique" };
    }

    return {
      account: false,
      message:
        "Error: " + (error instanceof Error ? error.message : "Unknown error"),
    };
  } finally {
    await ledgerSpaceSession.close();
  }
}

// Type guard to check if an error is a Neo4j error
function isNeo4jError(
  error: unknown
): error is { code: string; message: string } {
  return (
    typeof error === "object" &&
    error !== null &&
    "code" in error &&
    "message" in error
  );
}



File: ./src/index.ts
----------------------------------------
// Import required modules and dependencies
import express from "express";
import http from "http";
import MemberRoutes from "./Member/memberRoutes";
import AccountRoutes from "./Account/accountRoutes";
import CredexRoutes from "./Credex/credexRoutes";
import DevAdminRoutes from "./DevAdmin/devAdminRoutes";
import RecurringRoutes from "./Avatar/recurringRoutes";
import logger, { expressLogger } from "../config/logger";
import bodyParser from "body-parser";
import startCronJobs from "./Core/cronJobs";
import authenticate from "../config/authenticate";
import helmet from "helmet";
import cors from "cors";
import rateLimit from "express-rate-limit";
import AdminDashboardRoutes from "./AdminDashboard/adminDashboardRoutes";
import AdminRoutes from "./DevelopmentAdmin/adminRoutes";
import { errorHandler, notFoundHandler } from "../middleware/errorHandler";
import { config } from "../config/config";
import swaggerUi from "swagger-ui-express";
import { swaggerSpec } from "../config/swagger";

// Create an Express application
const app = express();

// Create a JSON parser middleware
const jsonParser = bodyParser.json();

// Define the API version route prefix
export const apiVersionOneRoute = "/api/v1/";

// Apply security middleware
app.use(helmet()); // Helps secure Express apps with various HTTP headers
app.use(cors()); // Enable Cross-Origin Resource Sharing (CORS)

// Apply custom logging middleware
app.use(expressLogger);

// Serve Swagger UI for API documentation
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Apply authentication middleware to all routes under the API version prefix
app.use(apiVersionOneRoute, authenticate);

// Set up rate limiting to prevent abuse
// NOTE: With all requests coming from a single WhatsApp chatbot, rate limiting might cause issues
// Consider adjusting or removing rate limiting based on your specific use case
const limiter = rateLimit({
  windowMs: config.rateLimit.windowMs, // Time window for rate limiting
  max: config.rateLimit.max, // Maximum number of requests per window
  message: "Too many requests from this IP, please try again after 15 minutes",
});
app.use(limiter);

// Start cron jobs for scheduled tasks (e.g., daily credcoin offering, minute transaction queue)
startCronJobs();

// Apply route handlers for different modules
app.use(`${apiVersionOneRoute}member`, jsonParser, MemberRoutes);
AccountRoutes(app, jsonParser);
CredexRoutes(app, jsonParser);
AdminDashboardRoutes(app, jsonParser);
RecurringRoutes(app, jsonParser);

// Conditionally apply DevAdmin routes based on deployment environment
if (config.deployment === "demo" || config.deployment === "dev") {
  DevAdminRoutes(app, jsonParser);
}

// Apply error handling middleware
app.use(notFoundHandler); // Handle 404 errors
app.use(errorHandler); // Handle all other errors

// Create HTTP server
const server = http.createServer(app);

// Start the server
server.listen(config.port, () => {
  logger.info(`Server is running on http://localhost:${config.port}`);
  logger.info(
    `API documentation available at http://localhost:${config.port}/api-docs`
  );
  logger.info(`Server started at ${new Date().toISOString()}`);
  logger.info(`Environment: ${config.nodeEnv}`);
  logger.info(`Deployment type: ${config.deployment}`);
});

// Handle uncaught exceptions
process.on("uncaughtException", (error) => {
  logger.error("Uncaught Exception:", error);
  // Perform any necessary cleanup
  // TODO: Implement a more robust error reporting mechanism (e.g., send to a monitoring service)
  // Gracefully shut down the server
  server.close(() => {
    logger.info("Server closed due to uncaught exception");
    process.exit(1);
  });
});

// Handle unhandled rejections
process.on("unhandledRejection", (reason, promise) => {
  logger.error("Unhandled Rejection at:", promise, "reason:", reason);
  // Perform any necessary cleanup
  // TODO: Implement a more robust error reporting mechanism (e.g., send to a monitoring service)
});

// Implement graceful shutdown
process.on("SIGTERM", () => {
  logger.info("SIGTERM signal received: closing HTTP server");
  server.close(() => {
    logger.info("HTTP server closed");
    // Perform any additional cleanup (e.g., close database connections)
    process.exit(0);
  });
});



File: ./src/Avatar/controllers/acceptRecurring.ts
----------------------------------------
import express from "express";
import { AcceptRecurringService } from "../services/AcceptRecurring";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

/**
 * AcceptRecurringController
 *
 * This controller handles the acceptance of recurring transactions.
 * It validates the required fields, calls the AcceptRecurringService,
 * and returns the result along with updated dashboard data.
 *
 * @param req - Express request object
 * @param res - Express response object
 */
export async function AcceptRecurringController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    const fieldsRequired = ["avatarID", "signerID"];
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `${field} is required` });
      }
    }

    // Call AcceptRecurringService to process the acceptance
    const acceptRecurringData = await AcceptRecurringService({
      avatarID: req.body.avatarID,
      signerID: req.body.signerID
    });

    // Check if the service call was successful
    if (typeof acceptRecurringData.recurring === "boolean") {
      return res.status(400).json({ error: acceptRecurringData.message });
    }

    // Fetch dashboard data
    const dashboardData = await GetAccountDashboardService(
      req.body.signerID,
      acceptRecurringData.recurring.acceptorAccountID
    );

    if (!dashboardData) {
      return res.status(404).json({ error: "Failed to fetch dashboard data" });
    }

    // Return the acceptance data and dashboard data
    return res.status(200).json({
      acceptRecurringData: acceptRecurringData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in AcceptRecurringController:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}



File: ./src/Avatar/controllers/cancelRecurring.ts
----------------------------------------
import express from "express";
import { CancelRecurringService } from "../services/CancelRecurring";
import { GetAccountDashboardController } from "../../Account/controllers/getAccountDashboard";

export async function DeclineRecurringController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["signerID", "cancelerAccountID", "avatarID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    const cancelRecurringData = await CancelRecurringService(
      req.body.signerID,
      req.body.cancelerAccountID,
      req.body.avatarID
    );

    if (!cancelRecurringData) {
      return res.status(400).json(cancelRecurringData);
    }

    const dashboardReq = {
      body: {
        memberID: req.body.signerID,
        accountID: req.body.cancelerAccountID
      }
    } as express.Request;
    const dashboardRes = {
      status: (code: number) => ({
        json: (data: any) => data
      })
    } as express.Response;

    const dashboardData = await GetAccountDashboardController(dashboardReq, dashboardRes);

    res.json({
      cancelRecurringData: cancelRecurringData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in DeclineRecurringController:", err);
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Avatar/controllers/requestRecurring.ts
----------------------------------------
import express from "express";
import { RequestRecurringService } from "../services/RequestRecurring";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";
import { getDenominations } from "../../Core/constants/denominations";

/**
 * RequestRecurringController
 * 
 * This controller handles the creation of recurring payment requests.
 * It validates the input, calls the RequestRecurringService,
 * and returns the result along with updated dashboard data.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function RequestRecurringController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    const fieldsRequired = [
      "signerMemberID",
      "requestorAccountID",
      "counterpartyAccountID",
      "InitialAmount",
      "Denomination",
      "nextPayDate",
      "daysBetweenPays",
    ];
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `${field} is required` });
      }
    }

    // Check denomination validity
    if (!getDenominations({ code: req.body.Denomination }).length) {
      return res.status(400).json({ error: "Denomination not permitted" });
    }

    // Validate optional parameters
    if (req.body.securedCredex !== undefined && typeof req.body.securedCredex !== 'boolean') {
      return res.status(400).json({ error: "securedCredex must be a boolean" });
    }

    if (req.body.credspan !== undefined) {
      const credspan = Number(req.body.credspan);
      if (isNaN(credspan) || credspan < 7 || credspan > 35) {
        return res.status(400).json({ error: "credspan must be a number between 7 and 35" });
      }
    }

    if (req.body.remainingPays !== undefined) {
      const remainingPays = Number(req.body.remainingPays);
      if (isNaN(remainingPays) || remainingPays < 0) {
        return res.status(400).json({ error: "remainingPays must be a positive number" });
      }
    }

    // Check securedCredex and credspan relationship
    if (req.body.securedCredex === true && req.body.credspan !== undefined) {
      return res.status(400).json({ error: "credspan must be null when securedCredex is true" });
    }

    if (req.body.securedCredex !== true && req.body.credspan === undefined) {
      return res.status(400).json({ error: "credspan must be provided when securedCredex is not true" });
    }

    const createRecurringData = await RequestRecurringService(req.body);

    if (!createRecurringData) {
      return res.status(400).json({ error: "Failed to create recurring payment" });
    }

    const dashboardData = await GetAccountDashboardService(
      req.body.signerMemberID,
      req.body.requestorAccountID
    );

    if (!dashboardData) {
      return res.status(404).json({ error: "Failed to fetch dashboard data" });
    }

    return res.status(200).json({
      avatarMemberID: createRecurringData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in RequestRecurringController:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}



File: ./src/Avatar/recurringRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { RequestRecurringController } from "./controllers/requestRecurring";
import { AcceptRecurringController } from "./controllers/acceptRecurring";
import { DeclineRecurringController } from "./controllers/cancelRecurring";

export default function RecurringRoutes(
  app: express.Application,
  jsonParser: any
) {
  /**
   * @swagger
   * /api/v1/requestRecurring:
   *   post:
   *     summary: Request a recurring payment
   *     tags: [Recurring]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - signerMemberID
   *               - requestorAccountID
   *               - counterpartyAccountID
   *               - InitialAmount
   *               - Denomination
   *               - nextPayDate
   *               - daysBetweenPays
   *             properties:
   *               signerMemberID:
   *                 type: string
   *               requestorAccountID:
   *                 type: string
   *               counterpartyAccountID:
   *                 type: string
   *               InitialAmount:
   *                 type: number
   *               Denomination:
   *                 type: string
   *               nextPayDate:
   *                 type: string
   *                 format: date
   *               daysBetweenPays:
   *                 type: integer
   *               securedCredex:
   *                 type: boolean
   *               credspan:
   *                 type: integer
   *               remainingPays:
   *                 type: integer
   *     responses:
   *       200:
   *         description: Recurring payment requested successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}requestRecurring`,
    jsonParser,
    RequestRecurringController
  );

  /**
   * @swagger
   * /api/v1/acceptRecurring:
   *   put:
   *     summary: Accept a recurring payment request
   *     tags: [Recurring]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - avatarID
   *               - signerID
   *             properties:
   *               avatarID:
   *                 type: string
   *               signerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Recurring payment accepted successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}acceptRecurring`,
    jsonParser,
    AcceptRecurringController
  );

  /**
   * @swagger
   * /api/v1/cancelRecurring:
   *   put:
   *     summary: Cancel a recurring payment
   *     tags: [Recurring]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - signerID
   *               - cancelerAccountID
   *               - avatarID
   *             properties:
   *               signerID:
   *                 type: string
   *               cancelerAccountID:
   *                 type: string
   *               avatarID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Recurring payment cancelled successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}cancelRecurring`,
    jsonParser,
    DeclineRecurringController
  );
}



File: ./src/Avatar/services/RequestRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import * as neo4j from "neo4j-driver";

interface RecurringParams {
  signerMemberID: string;
  requestorAccountID: string;
  counterpartyAccountID: string;
  InitialAmount: number;
  Denomination: string;
  nextPayDate: string;
  daysBetweenPays: number;
  securedCredex?: boolean;
  credspan?: number;
  remainingPays?: number;
}

export async function RequestRecurringService(params: RecurringParams): Promise<string | null> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    let cypher = `
      MATCH
        (requestor:Account {accountID: $requestorAccountID})<-[:AUTHORIZED_FOR]-
        (signer:Member|Avatar { memberID: $signerMemberID })
      MATCH (counterparty:Account {accountID: $counterpartyAccountID})
      MATCH (daynode:Daynode { Active: true })
      CREATE (recurring:Avatar)
      SET
        recurring.avatarType = "RECURRING",
        recurring.memberID = randomUUID(),
        recurring.Denomination = $Denomination,
        recurring.InitialAmount = $InitialAmount,
        recurring.nextPayDate = date($nextPayDate),
        recurring.daysBetweenPays = $daysBetweenPays,
        recurring.createdAt = datetime(),
        recurring.memberTier = 3
    `;

    if (params.securedCredex !== undefined) {
      cypher += `SET recurring.securedCredex = $securedCredex `;
    }

    if (params.credspan !== undefined) {
      cypher += `SET recurring.credspan = $credspan `;
    }

    if (params.remainingPays !== undefined) {
      cypher += `SET recurring.remainingPays = $remainingPays `;
    }

    cypher += `
      CREATE (requestor)<-[:REQUESTS]-(recurring)<-[:REQUESTS]-(counterparty)
      CREATE (requestor)<-[:REQUESTED]-(recurring)<-[:REQUESTED]-(counterparty)
      CREATE (requestor)<-[:AUTHORIZED_FOR]-(recurring)
      CREATE (signer)-[:SIGNED]--(recurring)
      CREATE (recurring)-[:CREATED_ON]--(daynode)
      RETURN
        recurring.memberID AS avatarID
    `;

    const neo4jParams = {
      ...params,
      daysBetweenPays: neo4j.int(params.daysBetweenPays),
      credspan: params.credspan ? neo4j.int(params.credspan) : undefined,
      remainingPays: params.remainingPays ? neo4j.int(params.remainingPays) : undefined
    };

    const createRecurringQuery = await ledgerSpaceSession.run(cypher, neo4jParams);

    return createRecurringQuery.records[0]?.get("avatarID") || null;
  } catch (error) {
    console.error("Error creating recurring avatar:", error);
    return null;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Avatar/services/AcceptRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

interface AcceptRecurringParams {
  avatarID: string;
  signerID: string;
}

interface AcceptRecurringResult {
  recurring: {
    acceptedRecurringID: string;
    acceptorAccountID: string;
    acceptorSignerID: string;
  } | boolean;
  message: string;
}

/**
 * AcceptRecurringService
 * 
 * This service handles the acceptance of a recurring transaction.
 * It updates the database to reflect the acceptance of the recurring avatar.
 * 
 * @param params - An object containing avatarID and signerID
 * @returns An object containing the result of the acceptance operation
 */
export async function AcceptRecurringService(params: AcceptRecurringParams): Promise<AcceptRecurringResult> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const { avatarID, signerID } = params;

    // Execute Cypher query to validate and update the Recurring avatar
    const acceptRecurringQuery = await ledgerSpaceSession.run(
      `
      MATCH
        (signer:Member { memberID: $signerID })-[:AUTHORIZED_FOR]->
        (acceptor:Account)-[rel1:REQUESTS]->
        (recurring:Avatar { memberID: $avatarID })-[rel2:REQUESTS]->
        (requestor:Account)
      CREATE (signer)-[:SIGNED]->(recurring)
      CREATE (acceptor)<-[:AUTHORIZED_FOR]-(recurring)
      CREATE (acceptor)-[:ACTIVE]->(recurring)-[:ACTIVE]->(requestor)
      DELETE rel1, rel2
      RETURN
        recurring.memberID AS avatarID,
        acceptor.accountID AS acceptorAccountID,
        signer.memberID AS signerID
      `,
      { avatarID, signerID }
    );

    // Check if the query returned any records
    if (acceptRecurringQuery.records.length === 0) {
      console.log(
        `No records found or recurring transaction no longer pending for avatarID: ${avatarID}`
      );
      return {
        recurring: false,
        message: `No records found or recurring transaction no longer pending for avatarID: ${avatarID}`,
      };
    }

    // TODO: Implement notification for recurring acceptance

    // Extract relevant data from the query result
    const record = acceptRecurringQuery.records[0];
    const acceptedRecurringID = record.get("avatarID");
    const acceptorAccountID = record.get("acceptorAccountID");
    const acceptorSignerID = record.get("signerID");

    console.log(`Recurring request accepted for avatarID: ${acceptedRecurringID}`);
    
    // Return the result of the acceptance operation
    return {
      recurring: {
        acceptedRecurringID,
        acceptorAccountID,
        acceptorSignerID,
      },
      message: "Recurring template created",
    };

  } catch (error) {
    // Handle any errors that occur during the process
    console.error("Error accepting recurring template:", error);
    return {
      recurring: false,
      message: `Error accepting recurring template: ${error}`,
    };
  } finally {
    // Ensure the database session is closed
    await ledgerSpaceSession.close();
  }
}



File: ./src/Avatar/services/CancelRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function CancelRecurringService(
  signerID: string,
  cancelerAccountID: string,
  avatarID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Validate and update the Recurring node
    const cancelRecurringQuery = await ledgerSpaceSession.run(
      `
      MATCH
        (signer:Member { memberID: $signerID })-[:AUTHORIZED_FOR]->
        (cancelingAccount:Account { accountID: $cancelerAccountID })-[rel1:ACTIVE|REQUESTS]-
        (recurring:Avatar { memberID: $avatarID})-[rel2:ACTIVE|REQUESTS]-
        (counterparty:Account)
      MATCH
        (cancelingAccount)<-[authRel1:AUTHORIZED_FOR]-
        (recurring)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH cancelingAccount, recurring, counterparty, rel1, rel2, authRel1, authRel2
      CALL apoc.create.relationship(cancelingAccount, 'CANCELED', {}, recurring) YIELD rel as canceledRel1
      CALL apoc.create.relationship(recurring, 'CANCELED', {}, counterparty) YIELD rel as canceledRel2
      DELETE rel1, rel2, authRel1, authRel2
      RETURN recurring.memberID AS deactivatedAvatarID
      `,
      {
        signerID,
        cancelerAccountID,
        avatarID,
      }
    );

    if (cancelRecurringQuery.records.length === 0) {
      return "Recurring template not found or not authorized to cancel";
    }

    const deactivatedAvatarID = cancelRecurringQuery.records[0].get(
      "deactivatedAvatarID"
    );

    return deactivatedAvatarID;
  } catch (error) {
    return error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/middleware/tokenGeneration.js
----------------------------------------
const jwt = require('jsonwebtoken');

// Payload (information to be included in the token)
const payload = { username: 'taku263' };

// Generate the token using the secret key
const token = jwt.sign(payload, "433a19703cc997d5e37ee22429aadb6c8827429e2c3763326a37c0b55e7aead0", { expiresIn: '1h' });

console.log(token); // This is the token you will share



File: ./src/Credex/controllers/acceptCredex.ts
----------------------------------------
import express from "express";
import { AcceptCredexService } from "../services/AcceptCredex";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

/**
 * AcceptCredexController
 * 
 * This controller handles the acceptance of Credex offers.
 * It validates the required fields, calls the AcceptCredexService,
 * and returns the result along with updated dashboard data.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function AcceptCredexController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    const fieldsRequired = ["credexID", "signerID"];
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `${field} is required` });
      }
    }

    const acceptCredexData = await AcceptCredexService(
      req.body.credexID,
      req.body.signerID
    );
    
    if (!acceptCredexData) {
      return res.status(400).json({ error: "Failed to accept Credex" });
    }

    const dashboardData = await GetAccountDashboardService(
      req.body.signerID,
      acceptCredexData.acceptorAccountID
    );

    if (!dashboardData) {
      return res.status(404).json({ error: "Failed to fetch dashboard data" });
    }

    return res.status(200).json({
      acceptCredexData: acceptCredexData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in AcceptCredexController:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}



File: ./src/Credex/controllers/cancelCredex.ts
----------------------------------------
import express from "express";
import { CancelCredexService } from "../services/CancelCredex";

/**
 * CancelCredexController
 * 
 * This controller handles the cancellation of Credex offers.
 * It validates the required fields, calls the CancelCredexService,
 * and returns the result.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function CancelCredexController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    if (!req.body.credexID) {
      return res.status(400).json({ error: "credexID is required" });
    }

    const responseData = await CancelCredexService(req.body.credexID);
    
    if (!responseData) {
      return res.status(404).json({ error: "Credex not found or already processed" });
    }

    return res.status(200).json({ message: "Credex cancelled successfully", credexID: responseData });
  } catch (err) {
    console.error("Error in CancelCredexController:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}



File: ./src/Credex/controllers/offerCredex.ts
----------------------------------------
import express from "express";
import { OfferCredexService } from "../services/OfferCredex";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";
import { getDenominations, denomFormatter } from "../../Core/constants/denominations";
import { checkDueDate, credspan } from "../../Core/constants/credspan";
import { checkPermittedCredexType } from "../../Core/constants/credexTypes";
import { SecuredCredexAuthForTierController } from "../../Member/controllers/securedCredexAuthForTier";
import { ledgerSpaceDriver } from "../../../config/neo4j";

/**
 * OfferCredexController
 * 
 * This controller handles the creation of new Credex offers.
 * It validates the required fields, performs additional validations,
 * calls the OfferCredexService, and returns the result along with updated dashboard data.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function OfferCredexController(
  req: express.Request,
  res: express.Response
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Validate required fields
    const fieldsRequired = [
      "memberID",
      "issuerAccountID",
      "receiverAccountID",
      "Denomination",
      "InitialAmount",
      "credexType",
      "OFFERSorREQUESTS",
    ];
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `${field} is required` });
      }
    }

    const {
      memberID,
      issuerAccountID,
      receiverAccountID,
      Denomination,
      InitialAmount,
      credexType,
      OFFERSorREQUESTS,
      securedCredex = false,
      dueDate = "",
    } = req.body;

    // Check if issuerAccountID and receiverAccountID are the same
    if (issuerAccountID === receiverAccountID) {
      return res.status(400).json({ error: "Issuer and receiver cannot be the same account" });
    }

    // Validate InitialAmount is a number
    if (typeof InitialAmount !== "number") {
      return res.status(400).json({ error: "InitialAmount must be a number" });
    }

    // Check denomination validity
    if (!getDenominations({ code: Denomination }).length) {
      return res.status(400).json({ error: "Invalid denomination" });
    }

    // Check credex type validity
    if (!checkPermittedCredexType(credexType)) {
      return res.status(400).json({ error: "Invalid credex type" });
    }

    // Validate OFFERSorREQUESTS
    if (OFFERSorREQUESTS !== "OFFERS" && OFFERSorREQUESTS !== "REQUESTS") {
      return res.status(400).json({ error: "Invalid OFFER/REQUEST value" });
    }

    // Check due date for unsecured credex
    if (!securedCredex) {
      if (!dueDate) {
        return res.status(400).json({ error: "Unsecured credex must have a due date" });
      }
      const dueDateOK = await checkDueDate(dueDate);
      if (!dueDateOK) {
        return res.status(400).json({ 
          error: `Due date must be permitted date, in format YYYY-MM-DD. First permitted due date is 1 week from today. Last permitted due date is ${credspan / 7} weeks from today.` 
        });
      }
    } else if (dueDate) {
      return res.status(400).json({ error: "Secured credex cannot have a due date" });
    }

    // Check secured credex limits based on membership tier
    if (securedCredex) {
      const getMemberTier = await ledgerSpaceSession.run(
        `
          MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
          RETURN member.memberTier as memberTier
        `,
        { issuerAccountID }
      );

      const memberTier = getMemberTier.records[0].get("memberTier");
      const tierAuth = await SecuredCredexAuthForTierController(
        issuerAccountID,
        memberTier,
        InitialAmount,
        Denomination
      );
      if (!tierAuth.isAuthorized) {
        return res.status(400).json({ error: tierAuth.message });
      }
    }

    // Check if unsecured credex is permitted on membership tier
    if (!securedCredex) {
      const getMemberTier = await ledgerSpaceSession.run(
        `
          MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
          RETURN member.memberTier as memberTier
        `,
        { issuerAccountID }
      );

      const memberTier = getMemberTier.records[0].get("memberTier");
      if (memberTier == 1) {
        return res.status(400).json({ error: "Members on the Open Tier cannot issue unsecured credexes" });
      }
    }

    // Call OfferCredexService to create the Credex offer
    const offerCredexData = await OfferCredexService(req.body);
    
    if (!offerCredexData || typeof offerCredexData.credex === 'boolean') {
      return res.status(400).json({ error: offerCredexData.message || "Failed to create Credex offer" });
    }
    
    // Fetch updated dashboard data
    const dashboardData = await GetAccountDashboardService(memberID, issuerAccountID);
    
    if (!dashboardData) {
      return res.status(404).json({ error: "Failed to fetch dashboard data" });
    }
    
    // Return the offer data and updated dashboard data
    return res.status(200).json({
      offerCredexData: offerCredexData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in OfferCredexController:", err);
    return res.status(500).json({ error: "Internal server error" });
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/controllers/acceptCredexBulk.ts
----------------------------------------
import express from "express";
import { AcceptCredexService } from "../services/AcceptCredex";
import { GetAccountDashboardController } from "../../Account/controllers/getAccountDashboard";

export async function AcceptCredexBulkController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["credexIDs", "signerID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  if (
    !Array.isArray(req.body.credexIDs) ||
    !req.body.credexIDs.every((id: any) => typeof id === "string")
  ) {
    return res
      .status(400)
      .json({ message: "Array of credexIDs to accept is required" });
  }

  try {
    const acceptCredexData = await Promise.all(
      req.body.credexIDs.map(async (credexID: string) => {
        const data = await AcceptCredexService(credexID, req.body.signerID);
        if (data) {
          return data;
        }
        return null;
      })
    );

    // Filter out any null values
    const validCredexData = acceptCredexData.filter(
      (
        item
      ): item is {
        acceptedCredexID: any;
        acceptorAccountID: any;
        memberID: any;
      } => item !== null
    );

    if (validCredexData.length > 0) {
      // Assuming that memberID and acceptorAccountID are the same for all returned objects
      const { memberID, acceptorAccountID } = validCredexData[0];

      const dashboardReq = {
        body: {
          memberID,
          accountID: acceptorAccountID
        }
      } as express.Request;
      const dashboardRes = {
        status: (code: number) => ({
          json: (data: any) => data
        })
      } as express.Response;

      const dashboardData = await GetAccountDashboardController(dashboardReq, dashboardRes);
      res.json({
        acceptCredexData: validCredexData,
        dashboardData: dashboardData,
      });
    } else {
      // Handle the case when there are no valid data returned from AcceptCredexService
      res
        .status(400)
        .json({ error: "No valid data returned from AcceptCredexService" });
    }
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/controllers/getLedger.ts
----------------------------------------
import express from "express";
import { GetLedgerService } from "../services/GetLedger";

export async function GetLedgerController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    if (!req.body.accountID) {
      return res.status(400).json({ error: "accountID is required" });
    }

    // Validate and set default values for optional fields
    const numRows = req.body.numRows ? parseInt(req.body.numRows) : 10;
    const startRow = req.body.startRow ? parseInt(req.body.startRow) : 0;

    if (isNaN(numRows) || isNaN(startRow) || numRows < 1 || startRow < 0) {
      return res.status(400).json({ error: "Invalid numRows or startRow" });
    }

    const responseData = await GetLedgerService(
      req.body.accountID,
      numRows,
      startRow
    );
    res.json(responseData);
  } catch (err) {
    console.error("Error in GetLedgerController:", err);
    res.status(500).json({ error: "Internal server error" });
  }
}



File: ./src/Credex/controllers/declineCredex.ts
----------------------------------------
import express from "express";
import { DeclineCredexService } from "../services/DeclineCredex";

export async function DeclineCredexController(
  req: express.Request,
  res: express.Response,
) {
  const fieldsRequired = ["credexID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }
  try {
    const responseData = await DeclineCredexService(req.body.credexID);
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/controllers/getCredex.ts
----------------------------------------
import express from "express";
import { GetCredexService } from "../services/GetCredex";

export async function GetCredexController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["credexID", "accountID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    const responseData = await GetCredexService(
      req.body.credexID,
      req.body.accountID
    );
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/services/CancelCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

/**
 * CancelCredexService
 * 
 * This service handles the cancellation of a Credex offer or request.
 * It changes the relationships from OFFERS or REQUESTS to CANCELLED.
 * 
 * @param credexID - The ID of the Credex to be cancelled
 * @returns The ID of the cancelled Credex or null if the operation fails
 * @throws Error if there's an issue with the database operation
 */
export async function CancelCredexService(credexID: string): Promise<string | null> {
  if (!credexID) {
    console.error("CancelCredexService: credexID is required");
    return null;
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.executeWrite(async (tx) => {
      const query = `
        MATCH (issuer:Account)-[rel1:OFFERS|REQUESTS]->(credex:Credex {credexID: $credexID})-[rel2:OFFERS|REQUESTS]->(acceptor:Account)
        WHERE credex.queueStatus <> "PROCESSED"
        DELETE rel1, rel2
        CREATE (issuer)-[:CANCELLED]->(credex)-[:CANCELLED]->(acceptor)
        SET
          credex.cancelledAt = datetime(),
          credex.OutstandingAmount = 0,
          credex.queueStatus = "PROCESSED"
        RETURN credex.credexID AS credexID
      `;

      const queryResult = await tx.run(query, { credexID });

      if (queryResult.records.length === 0) {
        console.warn(`No records found or credex no longer pending for credexID: ${credexID}`);
        return null;
      }

      return queryResult.records[0].get("credexID") as string;
    });

    if (result) {
      console.log(`Credex cancelled successfully: ${result}`);
    }

    return result;
  } catch (error) {
    console.error(`Error cancelling credex for credexID ${credexID}:`, error);
    throw new Error(`Failed to cancel Credex: ${(error as Error).message}`);
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/GetLedger.ts
----------------------------------------
/*

returns details to display a ledger list of transactions

requires:
  accountID

requires (with defaults if not included)
  numRows (number of transactions to return, default is 10)
  startRow (number of row to start at, for pagination, default is first row)

returns for each credex:
  credexID
  formattedInitialAmount (string eg 8,546.32 USD)
  counterpartyDisplayname

returns empty array if no credexes

returns error message if numRows or startRows can't be coerced into numbers
returns empty array if accountID not valid

*/

import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";

export async function GetLedgerService(
  accountID: string,
  numRows: number = 10,
  startRow: number = 0
) {
  numRows = Math.round(Number(numRows));
  startRow = Math.round(Number(startRow));

  if (Number.isNaN(numRows) || Number.isNaN(startRow)) {
    return "numRows and startRows must be numbers";
  }

  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
            (account:Account{accountID:$accountID})-[transactionType:OWES|CLEARED]-(credex:Credex)-[:OWES|CLEARED]-(counterparty:Account)
        OPTIONAL MATCH (credex)<-[:SECURES]-(securer:Account)
        RETURN
            credex.credexID AS credexID,
            credex.InitialAmount/credex.CXXmultiplier AS InitialAmount,
            credex.Denomination AS Denomination,
            (startNode(transactionType) = account) as debit,
            counterparty.accountName AS counterpartyAccountName
            ORDER BY credex.acceptedAt
            SKIP $startRow
            LIMIT $numRows
    `,
      {
        accountID: accountID,
        numRows: neo4j.int(numRows),
        startRow: neo4j.int(startRow),
      }
    );

    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const credexes = result.records.map((record) => {
      const credexID = record.get("credexID");
      const InitialAmount = record.get("debit")
        ? -parseFloat(record.get("InitialAmount"))
        : record.get("InitialAmount");
      const Denomination = record.get("Denomination");
      const counterpartyAccountName = record.get("counterpartyAccountName");

      const formattedInitialAmount =
        denomFormatter(InitialAmount, Denomination) + " " + Denomination;

      return {
        credexID,
        formattedInitialAmount,
        counterpartyAccountName,
      };
    });

    return credexes;
  } catch (error) {
    console.error("Error in GetLedgerService:", error);
    throw error;
  }
}



File: ./src/Credex/services/GetSecuredAuthorization.ts
----------------------------------------
/*
returns information on a account's secured balance

required inputs:
  issuerAccountID,
  Denomination,

returns:
  securerID (null if no secured balances available or error)
  securableAmountInDenom (0 if no secured balances or error, infinity if CREDEX_FOUNDATION_AUDITED)
    
*/

import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function GetSecuredAuthorizationService(
  issuerAccountID: string,
  Denomination: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  // Check if issuer is CREDEX_FOUNDATION_AUDITED
  const isFoundationAuditedQuery = await ledgerSpaceSession.run(
    `
      OPTIONAL MATCH
        (issuer:Account { accountID: $issuerAccountID })
        <-[:CREDEX_FOUNDATION_AUDITED]-
        (credexFoundation:Account { accountType: "CREDEX_FOUNDATION" })
      RETURN issuer IS NOT NULL AS isAudited
    `,
    { issuerAccountID }
  );

  const record = isFoundationAuditedQuery.records[0];
  const isAudited = record ? record.get("isAudited") : false;

  // If the issuer is CREDEX_FOUNDATION_AUDITED, authorize for unlimited secured credex issuance
  if (isAudited) {
    await ledgerSpaceSession.close();
    return {
      securerID: issuerAccountID,
      securableAmountInDenom: Infinity,
    };
  }

  // If issuer is not CREDEX_FOUNDATION_AUDITED, verify the available secured balance in denom
  const getSecurableDataQuery = await ledgerSpaceSession.run(
    `
      MATCH (account:Account {accountID: $accountID})
      OPTIONAL MATCH (account)-[transactionType:OWES|OFFERS]-(credex:Credex)<-[:SECURES]-(securer:Account)
      WHERE credex.Denomination = $Denomination
      WITH
        securer.accountID AS securingAccountID,
        SUM(CASE WHEN endNode(transactionType) = account THEN credex.OutstandingAmount ELSE 0 END) -
        SUM(CASE WHEN startNode(transactionType) = account THEN credex.OutstandingAmount ELSE 0 END)
        AS netSecurablePerSecurerCXX
      MATCH (daynode:Daynode {Active: true})
      RETURN
        securingAccountID,
        netSecurablePerSecurerCXX / daynode[$Denomination] AS netSecurableInDenom
        ORDER BY netSecurableInDenom DESC
        LIMIT 1
    `,
    {
      accountID: issuerAccountID,
      Denomination: Denomination,
    }
  );

  await ledgerSpaceSession.close();

  const securableRecord = getSecurableDataQuery.records[0];
  if (!securableRecord || securableRecord.length === 0) {
    return {
      securerID: null,
      securableAmountInDenom: 0,
    };
  }
    console.log({
      securerID: securableRecord.get("securingAccountID"),
      securableAmountInDenom: securableRecord.get("netSecurableInDenom"),
    });

  return {
    securerID: securableRecord.get("securingAccountID"),
    securableAmountInDenom: securableRecord.get("netSecurableInDenom"),
  };
}



File: ./src/Credex/services/GetPendingOffersIn.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";
import moment from "moment-timezone";

interface OfferedCredex {
  credexID: string;
  formattedInitialAmount: string;
  counterpartyAccountName: string;
  dueDate?: string; // optional field
  secured?: boolean; // optional field
}

export async function GetPendingOffersInService(accountID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
          (account:Account{accountID:$accountID})<-[:OFFERS]-(offersInCredex:Credex)<-[:OFFERS]-(counterparty:Account)
        OPTIONAL MATCH
          (offersInCredex)<-[:SECURES]-(securer:Account)
        RETURN
          offersInCredex.InitialAmount / offersInCredex.CXXmultiplier AS InitialAmount,
          offersInCredex.credexID AS credexID,
          offersInCredex.Denomination AS Denomination,
          offersInCredex.dueDate AS dueDate,
          counterparty.accountName AS counterpartyAccountName,
          securer IS NOT NULL as secured
      `,
      { accountID }
    );
    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const offeredCredexData = [];
    for (const record of result.records) {
      const formattedInitialAmount =
        denomFormatter(
          record.get("InitialAmount"),
          record.get("Denomination")
        ) +
        " " +
        record.get("Denomination");

      const thisOfferedCredex: OfferedCredex = {
        credexID: record.get("credexID"),
        formattedInitialAmount: formattedInitialAmount,
        counterpartyAccountName: record.get("counterpartyAccountName"),
      };
      if (record.get("dueDate")) {
        thisOfferedCredex.dueDate = moment(record.get("dueDate"))
          .subtract(1, "months") //because moment uses Jan = 0 and neo4j uses Jan = 1
          .format("YYYY-MM-DD");
      }
      if (record.get("secured")) {
        thisOfferedCredex.secured = record.get("secured");
      }
      offeredCredexData.push(thisOfferedCredex);
    }

    return offeredCredexData;
  } catch (error) {
    console.error("Error in GetPendingOffersInService:", error);
    throw error;
  }
}



File: ./src/Credex/services/CreateCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";
import { GetSecuredAuthorizationService } from "./GetSecuredAuthorization";

export async function CreateCredexService(credexData: any) {
  const {
    issuerAccountID,
    receiverAccountID,
    InitialAmount,
    Denomination,
    credexType,
    OFFERSorREQUESTS,
    securedCredex = false,
    dueDate = "",
  } = credexData;

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  let OFFEREDorREQUESTED = OFFERSorREQUESTS === "OFFERS" ? "OFFERED" : "REQUESTED";

  try {
    // Get securable data for secured credex
    let secureableData = { securerID: "", securableAmountInDenom: 0 };
    if (securedCredex) {
      secureableData = await GetSecuredAuthorizationService(
        issuerAccountID,
        Denomination
      );
      if (secureableData.securableAmountInDenom < InitialAmount) {
        return {
          credex: false,
          message: `Error: Your secured credex for ${denomFormatter(
            InitialAmount,
            Denomination
          )} ${Denomination} cannot be issued because your maximum securable ${Denomination} balance is ${denomFormatter(
            secureableData.securableAmountInDenom,
            Denomination
          )} ${Denomination}`,
        };
      }
    }

    // Create the credex
    const createCredexQuery = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode {Active: true})
        MATCH (issuer:Account {accountID: $issuerAccountID})
        MATCH (receiver:Account {accountID: $receiverAccountID})
        CREATE (newCredex:Credex)
        SET
          newCredex.credexID = randomUUID(),
          newCredex.Denomination = $Denomination,
          newCredex.CXXmultiplier = daynode[$Denomination],
          newCredex.InitialAmount = $InitialAmount * daynode[$Denomination],
          newCredex.OutstandingAmount = $InitialAmount * daynode[$Denomination],
          newCredex.RedeemedAmount = 0,
          newCredex.DefaultedAmount = 0,
          newCredex.WrittenOffAmount = 0,
          newCredex.credexType = $credexType,
          newCredex.createdAt = datetime(),
          newCredex.queueStatus = "PENDING_CREDEX"
        MERGE (newCredex)-[:CREATED_ON]->(daynode)
        MERGE (issuer)-[:${OFFERSorREQUESTS}]->(newCredex)-[:${OFFERSorREQUESTS}]->(receiver)
        MERGE (issuer)-[:${OFFEREDorREQUESTED}]->(newCredex)-[:${OFFEREDorREQUESTED}]->(receiver)
        RETURN
          newCredex.credexID AS credexID,
          receiver.accountName AS receiverAccountName
      `,
      {
        issuerAccountID,
        receiverAccountID,
        InitialAmount,
        Denomination,
        credexType,
      }
    );

    const credexID = createCredexQuery.records[0].get("credexID");

    // Add dueDate for unsecured credex
    if (!securedCredex) {
      const addDueDateQuery = await ledgerSpaceSession.run(
        `
          MATCH (newCredex:Credex {credexID: $credexID})
          SET newCredex.dueDate = date($dueDate)
          RETURN newCredex.dueDate AS dueDate
        `,
        {
          credexID,
          dueDate,
        }
      );
      if (addDueDateQuery.records.length === 0) {
        return { credex: false, message: "error creating credex" };
      }
    }

    // Add secured relationships for secured credex
    if (securedCredex && secureableData.securerID) {
      await ledgerSpaceSession.run(
        `
          MATCH (newCredex:Credex {credexID: $credexID})
          MATCH (securingAccount: Account {accountID: $securingAccountID})
          MERGE (securingAccount)-[:SECURES]->(newCredex)
        `,
        {
          credexID,
          securingAccountID: secureableData.securerID,
        }
      );
    }

    const newCredex = {
      credexID: createCredexQuery.records[0].get("credexID"),
      formattedInitialAmount: denomFormatter(InitialAmount, Denomination),
      counterpartyAccountName: createCredexQuery.records[0].get(
        "receiverAccountName"
      ),
      secured: securedCredex,
      dueDate: dueDate,
    };

    return {
      credex: newCredex,
      message: "Credex created: " + newCredex.credexID,
    };
  } catch (error) {
    return { credex: false, message: "Error creating credex: " + error };
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/DeclineCredex.ts
----------------------------------------
/*
marks a credex as declined by changing the relationships
from OFFERS or REQUESTS to DECLINED

required inputs:
  credexID

on success returns credexID

will return false if:
  credexID not found
  credex does not have OFFERS or REQUESTS relationships (credex already accepted/declined/cancelled)
    
*/

import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function DeclineCredexService(credexID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        MATCH (issuer:Account)-[rel1:OFFERS|REQUESTS]->(credex:Credex{credexID:$credexID})-[rel2:OFFERS|REQUESTS]->(acceptor:Account)
        DELETE rel1, rel2
        CREATE (issuer)-[:DECLINED]->(credex)-[:DECLINED]->(acceptor)
        WITH credex
        SET
            credex.declinedAt = Datetime(),
            credex.OutstandingAmount = 0,
            credex.queueStatus = "PROCESSED"
        RETURN credex.credexID AS credexID
    `,
      { credexID }
    );
    await ledgerSpaceSession.close();

    if (result.records.length === 0) {
      console.log(
        `No records found or credex no longer pending for credexID: ${credexID}`
      );
      return false;
    }

    const declinedCredexID = result.records[0].get("credexID");
    console.log(`Offer declined for credexID: ${declinedCredexID}`);
    return declinedCredexID;
  } catch (error) {
    console.log(error);
  }
}



File: ./src/Credex/services/GetCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";
import moment from "moment-timezone";

export async function GetCredexService(credexID: string, accountID: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH
        (account:Account {accountID: $accountID})-[transactionType:OWES|CLEARED|REQUESTS|OFFERS|DECLINED|CANCELLED]-(credex:Credex {credexID: $credexID})-[:OWES|CLEARED|REQUESTS|OFFERS|DECLINED|CANCELLED]-(counterparty:Account)
        OPTIONAL MATCH (credex)<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH (credex)-[credloopRel:CREDLOOP]-(clearedAgainstCredex:Credex)-[:OWES|CLEARED]-(account), (clearedAgainstCredex)-[:OWES|CLEARED]-(clearedAgainstCounterparty:Account)
        RETURN
        credex.credexID AS credexID,
        type(transactionType) AS transactionType,
        (startNode(transactionType) = account) AS debit,
        counterparty.accountName AS counterpartyAccountName,
        securer.accountID AS securerID,
        securer.accountName AS securerName,
        credex.Denomination AS Denomination,
        credex.InitialAmount / credex.CXXmultiplier AS InitialAmount,
        credex.OutstandingAmount / credex.CXXmultiplier AS OutstandingAmount,
        credex.RedeemedAmount / credex.CXXmultiplier AS RedeemedAmount,
        credex.DefaultedAmount / credex.CXXmultiplier AS DefaultedAmount,
        credex.WrittenOffAmount / credex.CXXmultiplier AS WrittenOffAmount,
        credex.acceptedAt AS acceptedAt,
        credex.declinedAt AS declinedAt,
        credex.cancelledAt AS cancelledAt,
        credex.dueDate AS dueDate,
        clearedAgainstCredex.credexID AS clearedAgainstCredexID,
        credloopRel.AmountRedeemed / credloopRel.CXXmultiplier AS clearedAmount,
        clearedAgainstCredex.InitialAmount / clearedAgainstCredex.CXXmultiplier AS clearedAgainstCredexInitialAmount,
        clearedAgainstCredex.Denomination AS clearedAgainstCredexDenomination,
        clearedAgainstCounterparty.accountName AS clearedAgainstCounterpartyAccountName
      `,
      { credexID, accountID }
    );

    if (result.records.length === 0) {
      throw new Error("No records found");
    }

    const record = result.records[0];
    const debit = record.get("debit");

    type Amounts = {
      InitialAmount: number;
      OutstandingAmount: number;
      RedeemedAmount: number;
      DefaultedAmount: number;
      WrittenOffAmount: number;
    };

    const amounts: Amounts = [
      "InitialAmount",
      "OutstandingAmount",
      "RedeemedAmount",
      "DefaultedAmount",
      "WrittenOffAmount",
    ].reduce(
      (acc: Amounts, amount: string) => {
        const value = parseFloat(record.get(amount));
        acc[amount as keyof Amounts] = debit ? -value : value;
        return acc;
      },
      {
        InitialAmount: 0,
        OutstandingAmount: 0,
        RedeemedAmount: 0,
        DefaultedAmount: 0,
        WrittenOffAmount: 0,
      }
    );

    const Denomination = record.get("Denomination");
    const formattedAmounts = (
      Object.entries(amounts) as [keyof Amounts, number][]
    ).reduce((acc, [key, value]) => {
      acc[`formatted${key}`] = `${denomFormatter(
        value,
        Denomination
      )} ${Denomination}`;
      return acc;
    }, {} as Record<string, string>);

    const acceptedAt = moment(record.get("acceptedAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const declinedAt = moment(record.get("declinedAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const cancelledAt = moment(record.get("cancelledAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const dueDate = moment(record.get("dueDate"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const counterpartyAccountName = record.get("counterpartyAccountName")

    const credexData = {
      credexID: record.get("credexID"),
      transactionType: record.get("transactionType"),
      debit,
      counterpartyAccountName,
      securerID: record.get("securerID"),
      securerName: record.get("securerName"),
      Denomination,
      acceptedAt: acceptedAt,
      declinedAt: declinedAt,
      cancelledAt: cancelledAt,
      dueDate: dueDate,
      ...formattedAmounts,
    };

    const clearedAgainstData = result.records
      .filter((record) => record.get("clearedAgainstCredexID"))
      .map((record) => {
        const clearedAmount = record.get("clearedAmount");
        const clearedAgainstCredexInitialAmount = parseFloat(
          record.get("clearedAgainstCredexInitialAmount")
        );
        const signumClearedAgainstCredexInitialAmount = debit
          ? clearedAgainstCredexInitialAmount
          : -clearedAgainstCredexInitialAmount;
        const clearedAgainstCredexDenomination = record.get(
          "clearedAgainstCredexDenomination"
        );

        const clearedAgainstCounterpartyAccountName = record.get("clearedAgainstCounterpartyAccountName")

        return {
          clearedAgainstCredexID: record.get("clearedAgainstCredexID"),
          formattedClearedAmount: `${denomFormatter(
            clearedAmount,
            clearedAgainstCredexDenomination
          )} ${clearedAgainstCredexDenomination}`,
          formattedClearedAgainstCredexInitialAmount: `${denomFormatter(
            signumClearedAgainstCredexInitialAmount,
            clearedAgainstCredexDenomination
          )} ${clearedAgainstCredexDenomination}`,
          clearedAgainstCounterpartyAccountName,
        };
      });

    return { credexData, clearedAgainstData };
  } catch (error) {
    console.error("Error in GetCredexService:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/AcceptCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

interface AcceptCredexResult {
  acceptedCredexID: string;
  acceptorAccountID: string;
  acceptorSignerID: string;
}

/**
 * AcceptCredexService
 * 
 * This service handles the acceptance of a Credex offer.
 * It updates the Credex status from OFFERS to OWES and signs the acceptance.
 * 
 * @param credexID - The ID of the Credex to be accepted
 * @param signerID - The ID of the Member or Avatar signing the acceptance
 * @returns An object with the accepted Credex details or null if the operation fails
 * @throws Error if there's an issue with the database operation
 */
export async function AcceptCredexService(credexID: string, signerID: string): Promise<AcceptCredexResult | null> {
  if (!credexID || !signerID) {
    console.error("AcceptCredexService: credexID and signerID are required");
    return null;
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.executeWrite(async (tx) => {
      const query = `
        MATCH
          (issuer:Account)-[rel1:OFFERS]->
          (acceptedCredex:Credex {credexID: $credexID})-[rel2:OFFERS]->
          (acceptor:Account)<-[:AUTHORIZED_FOR]-
          (signer:Member|Avatar { memberID: $signerID })
        DELETE rel1, rel2
        CREATE (issuer)-[:OWES]->(acceptedCredex)-[:OWES]->(acceptor)
        CREATE (acceptedCredex)<-[:SIGNED]-(signer)
        SET acceptedCredex.acceptedAt = datetime()
        RETURN
          acceptedCredex.credexID AS credexID,
          acceptor.accountID AS acceptorAccountID,
          signer.memberID AS signerID
      `;

      const queryResult = await tx.run(query, { credexID, signerID });

      if (queryResult.records.length === 0) {
        console.warn(`No records found or credex no longer pending for credexID: ${credexID}`);
        return null;
      }

      const record = queryResult.records[0];
      return {
        acceptedCredexID: record.get('credexID'),
        acceptorAccountID: record.get('acceptorAccountID'),
        acceptorSignerID: record.get('signerID')
      };
    });

    if (result) {
      console.log(`Offer accepted for credexID: ${result.acceptedCredexID}`);
      // TODO: Implement credex accepted notification here
    }

    return result;
  } catch (error) {
    console.error(`Error accepting credex for credexID ${credexID}:`, error);
    throw new Error(`Failed to accept Credex: ${(error as Error).message}`);
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/GetPendingOffersOut.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";
import moment from "moment-timezone";

interface OfferedCredex {
  credexID: string;
  formattedInitialAmount: string;
  counterpartyAccountName: string;
  dueDate?: string; // optional field
  secured?: boolean; // optional field
}

export async function GetPendingOffersOutService(accountID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
          (account:Account{accountID:$accountID})-[:OFFERS]->(offersOutCredex:Credex)-[:OFFERS]->(counterparty:Account)
        OPTIONAL MATCH
          (offersOutCredex)<-[:SECURES]-(securer:Account)
        RETURN
          offersOutCredex.InitialAmount / offersOutCredex.CXXmultiplier AS InitialAmount,
          offersOutCredex.credexID AS credexID,
          offersOutCredex.Denomination AS Denomination,
          offersOutCredex.dueDate AS dueDate,
          counterparty.accountName AS counterpartyAccountName,
          securer IS NOT NULL as secured
      `,
      { accountID }
    );
    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const offeredCredexData = [];
    for (const record of result.records) {
      const formattedInitialAmount =
        denomFormatter(
          parseFloat("-" + record.get("InitialAmount")),
          record.get("Denomination")
        ) +
        " " +
        record.get("Denomination");

      const thisOfferedCredex: OfferedCredex = {
        credexID: record.get("credexID"),
        formattedInitialAmount: formattedInitialAmount,
        counterpartyAccountName: record.get("counterpartyAccountName"),
      };
      if (record.get("dueDate")) {
        thisOfferedCredex.dueDate = moment(record.get("dueDate"))
          .subtract(1, "months") //because moment uses Jan = 0 and neo4j uses Jan = 1
          .format("YYYY-MM-DD");
      }
      if (record.get("secured")) {
        thisOfferedCredex.secured = record.get("secured");
      }
      offeredCredexData.push(thisOfferedCredex);
    }

    return offeredCredexData;
  } catch (error) {
    console.error("Error in GetPendingOffersOutService:", error);
    throw error;
  }
}



File: ./src/Credex/services/OfferCredex.ts
----------------------------------------
import { CreateCredexService } from "./CreateCredex";
import { ledgerSpaceDriver } from "../../../config/neo4j";

interface CredexData {
  memberID: string;
  receiverAccountID: string;
  credexType?: string;
  OFFERSorREQUESTS?: string;
  [key: string]: any;
}

/**
 * OfferCredexService
 * 
 * This service handles the creation of a new Credex offer.
 * It uses the CreateCredexService to create the Credex and then
 * signs the offer and prepares it for notification.
 * 
 * @param credexData - An object containing the data for the new Credex
 * @returns The result of the Credex offer creation
 */
export async function OfferCredexService(credexData: CredexData) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    // Set default values for the Credex
    credexData.OFFERSorREQUESTS = "OFFERS";
    credexData.credexType = credexData.credexType || "PURCHASE";
    
    // Create the new Credex
    const newCredex = await CreateCredexService(credexData);

    if (typeof newCredex.credex === "boolean" || !newCredex.credex?.credexID) {
      throw new Error("Failed to create Credex");
    }

    // Sign the Credex and prepare for notification
    const signResult = await signCredex(ledgerSpaceSession, newCredex.credex.credexID, credexData.memberID);
    
    if (!signResult) {
      console.warn("Failed to sign Credex, but Credex was created successfully");
    }

    // TODO: Implement offer notification here

    console.log(newCredex.message);
    return newCredex;
  } catch (error) {
    console.error("Error offering credex:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}

async function signCredex(session: any, credexID: string, signingMemberID: string): Promise<boolean> {
  try {
    const signQuery = await session.run(
      `
      MATCH
        (credex:Credex { credexID: $credexID })<-[:OFFERS]-
        (Account)<-[:AUTHORIZED_FOR]-
        (signer:Member|Avatar { memberID: $signingMemberID })
      CREATE (credex)<-[:SIGNED]-(signer)
      RETURN signer.memberID AS signerID
      `,
      { credexID, signingMemberID }
    );

    return signQuery.records.length > 0;
  } catch (error) {
    console.error("Error signing Credex:", error);
    return false;
  }
}



File: ./src/Credex/credexRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { OfferCredexController } from "./controllers/offerCredex";
import { AcceptCredexController } from "./controllers/acceptCredex";
import { AcceptCredexBulkController } from "./controllers/acceptCredexBulk";
import { DeclineCredexController } from "./controllers/declineCredex";
import { CancelCredexController } from "./controllers/cancelCredex";
import { GetCredexController } from "./controllers/getCredex";
import { GetLedgerController } from "./controllers/getLedger";

export default function CredexRoutes(
  app: express.Application,
  jsonParser: any
) {
  /**
   * @swagger
   * /api/v1/offerCredex:
   *   post:
   *     summary: Offer a new Credex
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - memberID
   *               - issuerAccountID
   *               - receiverAccountID
   *               - Denomination
   *               - InitialAmount
   *             properties:
   *               memberID:
   *                 type: string
   *               issuerAccountID:
   *                 type: string
   *               receiverAccountID:
   *                 type: string
   *               Denomination:
   *                 type: string
   *               InitialAmount:
   *                 type: number
   *               credexType:
   *                 type: string
   *               securedCredex:
   *                 type: boolean
   *               dueDate:
   *                 type: string
   *                 format: date
   *     responses:
   *       200:
   *         description: Credex offered successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}offerCredex`,
    jsonParser,
    OfferCredexController
  );

  /**
   * @swagger
   * /api/v1/acceptCredex:
   *   put:
   *     summary: Accept a Credex offer
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - credexID
   *               - signerID
   *             properties:
   *               credexID:
   *                 type: string
   *               signerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Credex accepted successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}acceptCredex`,
    jsonParser,
    AcceptCredexController
  );

  /**
   * @swagger
   * /api/v1/acceptCredexBulk:
   *   put:
   *     summary: Accept multiple Credex offers in bulk
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - credexIDs
   *               - signerID
   *             properties:
   *               credexIDs:
   *                 type: array
   *                 items:
   *                   type: string
   *               signerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Credexes accepted successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}acceptCredexBulk`,
    jsonParser,
    AcceptCredexBulkController
  );

  /**
   * @swagger
   * /api/v1/declineCredex:
   *   put:
   *     summary: Decline a Credex offer
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - credexID
   *             properties:
   *               credexID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Credex declined successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}declineCredex`,
    jsonParser,
    DeclineCredexController
  );

  /**
   * @swagger
   * /api/v1/cancelCredex:
   *   put:
   *     summary: Cancel a Credex offer
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - credexID
   *             properties:
   *               credexID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Credex cancelled successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}cancelCredex`,
    jsonParser,
    CancelCredexController
  );

  /**
   * @swagger
   * /api/v1/getCredex:
   *   get:
   *     summary: Get Credex details
   *     tags: [Credex]
   *     parameters:
   *       - in: query
   *         name: credexID
   *         required: true
   *         schema:
   *           type: string
   *       - in: query
   *         name: accountID
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Credex details retrieved successfully
   *       400:
   *         description: Bad request
   *       404:
   *         description: Credex not found
   */
  app.get(`${apiVersionOneRoute}getCredex`, jsonParser, GetCredexController);

  /**
   * @swagger
   * /api/v1/getLedger:
   *   get:
   *     summary: Get account ledger
   *     tags: [Credex]
   *     parameters:
   *       - in: query
   *         name: accountID
   *         required: true
   *         schema:
   *           type: string
   *       - in: query
   *         name: numRows
   *         schema:
   *           type: integer
   *       - in: query
   *         name: startRow
   *         schema:
   *           type: integer
   *     responses:
   *       200:
   *         description: Ledger retrieved successfully
   *       400:
   *         description: Bad request
   */
  app.get(`${apiVersionOneRoute}getLedger`, jsonParser, GetLedgerController);
}



File: ./src/Core/constants/accountTypes.ts
----------------------------------------
export const accountTypes = ["PERSONAL_CONSUMPTION", "BUSINESS", "CREDEX_FOUNDATION"];

export function checkPermittedAccountType(credexTypeToCheck: string) {
  if (accountTypes.includes(credexTypeToCheck)) {
    return true;
  }
}



File: ./src/Core/constants/denominations.ts
----------------------------------------
import { filter } from "lodash";

/**
 * Options for querying denominations.
 */
type DenomOptions = {
  code?: string;
  sourceForRate?: string;
  formatAsList?: boolean;
};

/**
 * Represents a currency denomination.
 */
export type Denomination = {
  code: string;
  fulldescription: string;
  regionalization: string;
  sourceForRate: string;
};

/**
 * Array of supported denominations in the Credex system.
 */
const denominations: Denomination[] = [
  {
    code: "CXX",
    fulldescription: "CXX (Credcoin)",
    regionalization: "en-CA",
    sourceForRate: "DCO",
  },
  {
    code: "CAD",
    fulldescription: "CAD (Canadian Dollars)",
    regionalization: "en-CA",
    sourceForRate: "OpenExchangeRates",
  },
  {
    code: "USD",
    fulldescription: "USD (United States Dollars)",
    regionalization: "en-US",
    sourceForRate: "OpenExchangeRates",
  },
  {
    code: "XAU",
    fulldescription: "XAU (Troy Gold Ounces)",
    regionalization: "en-CA",
    sourceForRate: "OpenExchangeRates",
  },
  {
    code: "ZIG",
    fulldescription: "ZIG (Zimbabwe Gold Official Rate)",
    regionalization: "en-CA",
    sourceForRate: "RBZ",
  },
];

/**
 * Retrieves denominations based on provided options.
 * @param options - Options for filtering denominations.
 * @returns An array of Denomination objects or a comma-separated string of denomination codes.
 */
export function getDenominations(
  options: DenomOptions
): string | Denomination[] {
  let result = denominations;

  if (options.code) {
    result = result.filter((denom) => denom.code === options.code);
  }

  if (options.sourceForRate) {
    result = result.filter(
      (denom) => denom.sourceForRate === options.sourceForRate
    );
  }

  if (options.formatAsList) {
    return result.map((denom) => denom.code).join(",");
  }

  return result;
}

/**
 * Formats a numerical amount according to the specified denomination.
 * @param amount - The numerical amount to format.
 * @param code - The denomination code.
 * @returns A formatted string representation of the amount.
 */
export const denomFormatter = (amount: number, code: string): string => {
  // Ensure amount is a finite number
  if (!isFinite(amount)) {
    amount = 0;
  }

  /**
   * Formats a currency amount with the specified precision and regionalization.
   * @param amount - The amount to format.
   * @param precision - The number of decimal places to round to.
   * @param regionalization - The locale string for number formatting.
   * @returns A formatted string representation of the amount.
   */
  const formatCurrencyAmount = (
    amount: number,
    precision: number,
    regionalization: string
  ): string => {
    const roundedAmount = Number(amount.toFixed(precision));
    return new Intl.NumberFormat(regionalization).format(roundedAmount);
  };

  const denomData = getDenominations({ code }) as Denomination[];
  const regionalization =
    denomData.length > 0 ? denomData[0].regionalization : "en-US";

  let formattedAmount: string;
  switch (code) {
    case "CXX":
      formattedAmount = formatCurrencyAmount(amount, 3, regionalization);
      break;
    case "XAU":
      formattedAmount = formatCurrencyAmount(amount, 4, regionalization);
      break;
    default:
      formattedAmount = formatCurrencyAmount(amount, 2, regionalization);
  }

  return formattedAmount;
};

/**
 * Retrieves the full description of a denomination by its code.
 * @param code - The denomination code.
 * @returns The full description of the denomination, or undefined if not found.
 */
export const getFullDescription = (code: string): string | undefined => {
  const denom = denominations.find((d) => d.code === code);
  return denom?.fulldescription;
};

/**
 * Checks if a given code is a valid denomination.
 * @param code - The denomination code to check.
 * @returns True if the code is a valid denomination, false otherwise.
 */
export const isValidDenomination = (code: string): boolean => {
  return denominations.some((d) => d.code === code);
};



File: ./src/Core/constants/credspan.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import moment from "moment-timezone";

export const credspan = 35;

export async function checkDueDate(dueDate: any): Promise<boolean> {
  const dueDateMoment = moment.utc(dueDate, "YYYY-MM-DD", true);
  if (!dueDateMoment.isValid()) {
    console.error("Due date not in valid format");
    return false;
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const currentDateQuery = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      RETURN daynode.Date AS today
    `);
  const today = currentDateQuery.records[0].get("today");
  if (!today) {
    console.log("could not get date from daynode");
    return false;
  }
  const lastPermittedDayMoment = moment(today)
    .subtract(1, "months") // because of diff date formats
    .add(credspan, "days");
  const firstPermittedDayMoment = moment(today)
    .subtract(1, "months") // because of diff date formats
    .add(7, "days");
  if (
    dueDateMoment >= lastPermittedDayMoment ||
    dueDateMoment < firstPermittedDayMoment
  ) {
    console.error("Due date is not within permitted credspan");
    return false;
  }
  return true;
}



File: ./src/Core/constants/credexTypes.ts
----------------------------------------
export const credexTypes = [
  "PURCHASE",
  "GIFT",
  "DCO_GIVE",
  "DCO_RECEIVE"
];

export function checkPermittedCredexType(credexTypeToCheck: string) {
  if (credexTypes.includes(credexTypeToCheck)) {
    return true;
  }
}



File: ./src/Core/DCO/DailyCredcoinOffering.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { DBinitialization } from "./DBinitialization";
import { DCOexecute } from "./DCOexecute";
import { DCOavatars } from "./DCOavatars";
import logger from "../../../config/logger";

/**
 * Executes the Daily Credcoin Offering (DCO) process.
 * This function checks for an active daynode, initializes the database if necessary,
 * and runs the DCO execution and avatar update processes.
 * 
 * @returns {Promise<boolean>} Returns true if the DCO process completes successfully, false otherwise.
 */
export async function DailyCredcoinOffering(): Promise<boolean> {
  console.log("Starting Daily Credcoin Offering process");
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Check for active daynode
    const daynodeExists = await checkActiveDaynode(ledgerSpaceSession);

    if (!daynodeExists) {
      console.log("No active daynode found. Initializing database...");
      await DBinitialization();
      console.log("Database initialization complete");
    }

    await DCOexecute();
    await DCOavatars();

    return true;
  } catch (error) {
    logger.error("Error in DailyCredcoinOffering", error);
    return false;
  } finally {
    await resetDCORunningFlag(ledgerSpaceSession);
    await ledgerSpaceSession.close();
  }
}

/**
 * Checks if an active daynode exists in the database.
 * 
 * @param {Neo4jSession} session - The Neo4j session to use for the query.
 * @returns {Promise<boolean>} Returns true if an active daynode exists, false otherwise.
 */
async function checkActiveDaynode(session: any): Promise<boolean> {
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN daynode IS NOT NULL AS activeDaynodeExists
  `);
  return result.records[0].get("activeDaynodeExists");
}

/**
 * Resets the DCOrunningNow flag on the active daynode.
 * 
 * @param {Neo4jSession} session - The Neo4j session to use for the query.
 */
async function resetDCORunningFlag(session: any): Promise<void> {
  console.log("Resetting DCOrunningNow flag");
  await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    SET daynode.DCOrunningNow = false
  `);
}



File: ./src/Core/DCO/fetchZigRate.ts
----------------------------------------
import axios from "axios";
import cheerio from "cheerio";

const https = require("https");

const url = "https://www.rbz.co.zw/index.php";

const httpsAgent = new https.Agent({
  rejectUnauthorized: false, // To Ignore SSL errors in dev
});

export async function fetchZigRate(): Promise<
  { currency: string; bid: string; ask: string; avg: string }[]
> {
  try {
    const { data } = await axios.get(url, { httpsAgent });
    const parsedHtml = cheerio.load(data);

    const rates: { currency: string; bid: string; ask: string; avg: string }[] =
      [];

    parsedHtml("#baTab1 table tbody tr").each((index: number, element: any) => {
      const currency: string = parsedHtml(element)
        .find("td")
        .eq(0)
        .text()
        .trim();
      const bid: string = parsedHtml(element).find("td").eq(1).text().trim();
      const ask: string = parsedHtml(element).find("td").eq(2).text().trim();
      const avg: string = parsedHtml(element).find("td").eq(3).text().trim();

      if (currency && bid && ask && avg) {
        rates.push({ currency, bid, ask, avg });
      }
    });
    //console.log(rates);
    return rates;
  } catch (error) {
    console.error("Error fetching exchange rates:", error);
    return [];
  }
}



File: ./src/Core/DCO/DCOavatars.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import moment from "moment-timezone";

/**
 * DCOavatars function
 * This function is run as a cronjob every 24 hours to process recurring avatars.
 * It identifies active recurring avatars, creates credexes, and updates there status.
 */
export async function DCOavatars() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    console.log("Checking for activated recurring avatars...");
    
    // Query to get active recurring avatars that are due for processing
    const GetActiveRecurringAvatars = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      MATCH
        (issuer:Account)-[rel1:ACTIVE]->
        (avatar:Avatar { avatarType: "RECURRING", nextPayDate: daynode.Date})-[rel2:ACTIVE]->
        (acceptor:Account)
      MATCH
        (issuer)<-[authRel1:AUTHORIZED_FOR]-
        (avatar)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2
      
      // Reduce remainingPays by 1 if it exists
      SET avatar.remainingPays = 
        CASE
          WHEN avatar.remainingPays IS NOT NULL THEN avatar.remainingPays - 1
          ELSE null
        END
      
      // Calculate the new nextPayDate
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2,
           CASE
             WHEN avatar.remainingPays IS NULL OR avatar.remainingPays > 0 
             THEN date(avatar.nextPayDate) + duration({days: avatar.daysBetweenPays})
             ELSE null
           END AS newNextPayDate
      
      // Update nextPayDate
      SET avatar.nextPayDate = newNextPayDate
      
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2, newNextPayDate
      
      // Check if the avatar should be marked as completed
      OPTIONAL MATCH (issuer)-[completed1:COMPLETED]->(avatar)-[completed2:COMPLETED]->(acceptor)
      FOREACH(ignoreMe IN CASE WHEN newNextPayDate IS NULL AND completed1 IS NULL
               THEN [1] ELSE [] END |
        DELETE rel1, rel2
        SET
          authRel1.markedToDelete = true,
          authRel2.markedToDelete = true
        CREATE (issuer)-[:COMPLETED]->(avatar)-[:COMPLETED]->(acceptor)
      )
      
      RETURN
        avatar {
          .*,
          remainingPays: avatar.remainingPays,
          nextPayDate: avatar.nextPayDate
        } AS avatar,
        issuer.accountID AS issuerAccountID,
        acceptor.accountID AS acceptorAccountID,
        daynode.Date AS Date    
    `);

    // Process each active recurring avatar
    for (const record of GetActiveRecurringAvatars.records) {
      const avatar = record.get("avatar");
      const issuerAccountID = record.get("issuerAccountID");
      const acceptorAccountID = record.get("acceptorAccountID");

      try {
        // Prepare data for creating a new credex
        const offerData: any = {
          memberID: avatar.memberID,
          issuerAccountID: issuerAccountID,
          receiverAccountID: acceptorAccountID,
          Denomination: avatar.Denomination,
          InitialAmount: avatar.InitialAmount,
          credexType: "PURCHASE",
          OFFERSorREQUESTS: "OFFERS",
        };

        // Handle secured and unsecured credexes differently
        if (avatar.securedCredex) {
          offerData.securedCredex = true;
        } else {
          // Calculate dueDate for unsecured credexes using the avatar's credspan
          avatar.dueDate = moment(record.get("Date"))
            .add(parseInt(avatar.credspan), "days")
            .subtract(parseInt("1"), "month")
            .format("YYYY-MM-DD");
          
          offerData.dueDate = avatar.dueDate;
        }

        // Create a new credex offer
        const offerResult = await OfferCredexService(offerData);

        // If offer is successful, automatically accept it
        if (
          offerResult &&
          typeof offerResult.credex === "object" &&
          offerResult.credex.credexID
        ) {
          const acceptResult = await AcceptCredexService(
            offerResult.credex.credexID,
            avatar.memberID
          );
          if (acceptResult) {
            console.log(
              `Successfully created credex for recurring avatar: ${avatar.memberID}. Remaining pays: ${avatar.remainingPays}, Next pay date: ${avatar.nextPayDate}`
            );
          } else {
            throw new Error(`Failed to accept credex for avatar: ${avatar.memberID}`);
          }
        } else {
          throw new Error(`Failed to create offer for avatar: ${avatar.memberID}`);
        }

        const deleteAvatarAuths = await ledgerSpaceSession.run(`
          MATCH ()-[rel:AUTHORIZED_FOR {markedToDelete: true}]->()
          DELETE rel
          `);

      } catch (error) {
        console.error(`Error processing avatar ${avatar.memberID}:`, error);
        // TODO: Implement member notification about the failure
        console.log(`Placeholder: Notify member ${avatar.memberID} about the failure in processing their recurring avatar.`);
      }
    }
  } catch (error) {
    console.error("Error in DCOavatars:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Core/DCO/DCOexecute.ts
----------------------------------------
import axios from "axios";
import _ from "lodash";
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { getDenominations, Denomination } from "../constants/denominations";
import { GetSecuredAuthorizationService } from "../../Credex/services/GetSecuredAuthorization";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { fetchZigRate } from "./fetchZigRate";
import { createNeo4jBackup } from "./DBbackup";
import logger from "../../../config/logger";

interface Rates {
  [key: string]: number;
}

interface Participant {
  accountID: string;
  DCOmemberID: string;
  DCOgiveInCXX: number;
  DCOgiveInDenom: number;
  DCOdenom: string;
}

/**
 * Executes the Daily Credcoin Offering (DCO) process.
 * This function handles the daily operations of the Credcoin system,
 * including rate updates, participant validation, and transaction processing.
 */
export async function DCOexecute(): Promise<boolean> {
  console.log("Starting DCOexecute");
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    await waitForMTQCompletion(ledgerSpaceSession);
    const { previousDate, nextDate } = await setDCORunningFlag(
      ledgerSpaceSession
    );

    await createNeo4jBackup(previousDate, "_end");
    await handleDefaultingCredexes(ledgerSpaceSession);
    await expirePendingOffers(ledgerSpaceSession);

    const USDbaseRates = await fetchCurrencyRates(nextDate);
    const {
      newCXXrates,
      CXXprior_CXXcurrent,
      DCOinCXX,
      DCOinXAU,
      numberConfirmedParticipants,
    } = await processDCOParticipants(ledgerSpaceSession, USDbaseRates);

    await createNewDaynode(
      ledgerSpaceSession,
      newCXXrates,
      nextDate,
      CXXprior_CXXcurrent
    );
    await updateCredexBalances(
      ledgerSpaceSession,
      searchSpaceSession,
      newCXXrates,
      CXXprior_CXXcurrent
    );

    const { foundationID, foundationXOid } = await getFoundationData(
      ledgerSpaceSession
    );
    await processDCOTransactions(
      ledgerSpaceSession,
      foundationID,
      foundationXOid,
      DCOinCXX,
      numberConfirmedParticipants
    );

    await createNeo4jBackup(nextDate, "_start");
    console.log(`DCOexecute completed for ${nextDate}`);

    return true;
  } catch (error) {
    logger.error("Error during DCOexecute", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}

async function waitForMTQCompletion(session: any): Promise<void> {
  console.log("Waiting for MTQ completion");
  let MTQflag = true;
  while (MTQflag) {
    const result = await session.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.MTQrunningNow AS MTQflag
    `);
    MTQflag = result.records[0]?.get("MTQflag");
    if (MTQflag) {
      console.log("MTQ running. Waiting 5 seconds...");
      await new Promise((resolve) => setTimeout(resolve, 5000));
    }
  }
  console.log("MTQ not running. Proceeding...");
}

async function setDCORunningFlag(
  session: any
): Promise<{ previousDate: string; nextDate: string }> {
  console.log("Setting DCOrunningNow flag");
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    SET daynode.DCOrunningNow = true
    RETURN
      daynode.Date AS previousDate,
      daynode.Date + Duration({days: 1}) AS nextDate
  `);
  const previousDate = result.records[0].get("previousDate");
  const nextDate = result.records[0].get("nextDate");
  console.log(`Expiring day: ${previousDate}`);
  return { previousDate, nextDate };
}

async function handleDefaultingCredexes(session: any): Promise<void> {
  console.log("Processing defaulting unsecured credexes");
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    OPTIONAL MATCH (account1:Account)-[rel1:OWES]->(defaulting:Credex)-[rel2:OWES]->(account2:Account)
    WHERE defaulting.dueDate <= daynode.Date AND defaulting.DefaultedAmount <= 0
    SET defaulting.DefaultedAmount = defaulting.OutstandingAmount
    WITH defaulting, daynode
    UNWIND defaulting AS defaultingCredex
    CREATE (defaultingCredex)-[:DEFAULTED_ON]->(daynode)
    RETURN count(defaulting) AS numberDefaulted
  `);
  const numberDefaulted = result.records[0]?.get("numberDefaulted") || 0;
  console.log(`Defaults: ${numberDefaulted}`);
}

async function expirePendingOffers(session: any): Promise<void> {
  console.log("Expiring pending offers/requests");
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    OPTIONAL MATCH (:Account)-[rel1:OFFERS|REQUESTS]->(expiringPending:Credex)-[rel2:OFFERS|REQUESTS]->(:Account),
    (expiringPending)-[:CREATED_ON]->(createdDaynode:Daynode)
    WHERE createdDaynode.Date + Duration({days: 1}) < daynode.Date
    DELETE rel1, rel2
    RETURN count(expiringPending) AS numberExpiringPending
  `);
  const numberExpiringPending =
    result.records[0]?.get("numberExpiringPending") || 0;
  console.log(`Expired pending offers/requests: ${numberExpiringPending}`);
}

async function fetchCurrencyRates(nextDate: string): Promise<Rates> {
  console.log("Fetching currency rates");
  const symbols = getDenominations({
    sourceForRate: "OpenExchangeRates",
    formatAsList: true,
  }) as string;
  const {
    data: { rates: USDbaseRates },
  } = await axios.get(
    `https://openexchangerates.org/api/historical/${nextDate}.json`,
    { params: { app_id: process.env.OPEN_EXCHANGE_RATES_API, symbols } }
  );

  const ZIGrates = await fetchZigRate();
  USDbaseRates.ZIG = ZIGrates.length > 0 ? parseFloat(ZIGrates[1].avg) : NaN;

  validateRates(USDbaseRates);
  return USDbaseRates;
}

function validateRates(rates: Rates): void {
  const allDenoms = getDenominations({}) as Denomination[];
  const denomsToCheck = allDenoms.filter(
    (denom: Denomination) => denom.code !== "CXX"
  );

  const allValid = denomsToCheck.every(
    (denom: Denomination) =>
      rates.hasOwnProperty(denom.code) &&
      typeof rates[denom.code] === "number" &&
      !isNaN(rates[denom.code])
  );

  if (!allValid) {
    throw new Error("Invalid or missing currency rates");
  }
}

async function processDCOParticipants(
  session: any,
  USDbaseRates: Rates
): Promise<any> {
  console.log("Processing DCO participants");
  const denomsInXAU = _.mapValues(
    USDbaseRates,
    (value) => value / USDbaseRates.XAU
  );

  const result = await session.run(`
    MATCH (daynode:Daynode{Active:true})
    MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
    WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
    RETURN
      DCOparticpantsDeclared.accountID AS accountID,
      DCOmember.memberID AS DCOmemberID,
      DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
      DCOparticpantsDeclared.DCOgiveInCXX / daynode[DCOparticpantsDeclared.DCOdenom] AS DCOgiveInDenom,
      DCOparticpantsDeclared.DCOdenom AS DCOdenom
  `);

  const declaredParticipants = result.records;
  console.log(`Declared participants: ${declaredParticipants.length}`);

  let DCOinCXX = 0;
  let DCOinXAU = 0;
  const confirmedParticipants: Participant[] = [];

  for (const participant of declaredParticipants) {
    const { accountID, DCOmemberID, DCOdenom, DCOgiveInCXX, DCOgiveInDenom } =
      participant.toObject();
    const { securableAmountInDenom } = await GetSecuredAuthorizationService(
      accountID,
      DCOdenom
    );

    if (DCOgiveInDenom <= securableAmountInDenom) {
      confirmedParticipants.push({
        accountID,
        DCOmemberID,
        DCOdenom,
        DCOgiveInCXX,
        DCOgiveInDenom,
      });
      DCOinCXX += DCOgiveInCXX;
      DCOinXAU += DCOgiveInDenom / denomsInXAU[DCOdenom];
    }
  }

  const numberConfirmedParticipants = confirmedParticipants.length;
  const nextCXXinXAU = DCOinXAU / numberConfirmedParticipants;
  const CXXprior_CXXcurrent = DCOinCXX / numberConfirmedParticipants;

  console.log(`Confirmed participants: ${numberConfirmedParticipants}`);
  console.log(`DCO in CXX: ${DCOinCXX}`);
  console.log(`DCO in XAU: ${DCOinXAU}`);
  console.log(`Next CXX in XAU: ${nextCXXinXAU}`);

  const newCXXrates = _.mapValues(
    denomsInXAU,
    (value) => 1 / nextCXXinXAU / value
  );
  newCXXrates.CXX = 1;

  logger.info("DCO Rates", {
    USDinXAU: denomsInXAU.XAU,
    CXXinXAU: newCXXrates.CXX,
    CXXprior_CXXcurrent,
  });

  return {
    newCXXrates,
    CXXprior_CXXcurrent,
    DCOinCXX,
    DCOinXAU,
    numberConfirmedParticipants,
    confirmedParticipants,
  };
}

async function createNewDaynode(
  session: any,
  newCXXrates: Rates,
  nextDate: string,
  CXXprior_CXXcurrent: number
): Promise<void> {
  console.log("Creating new daynode");
  await session.run(
    `
    MATCH (expiringDaynode:Daynode {Active: TRUE})
    CREATE (expiringDaynode)-[:NEXT_DAY]->(nextDaynode:Daynode)
    SET expiringDaynode.Active = false,
        expiringDaynode.DCOrunningNow = false,
        nextDaynode = $newCXXrates,
        nextDaynode.CXXprior_CXXcurrent = $CXXprior_CXXcurrent,
        nextDaynode.Date = date($nextDate),
        nextDaynode.Active = true,
        nextDaynode.DCOrunningNow = true
  `,
    { newCXXrates, nextDate, CXXprior_CXXcurrent }
  );
}

async function updateCredexBalances(
  ledgerSession: any,
  searchSession: any,
  newCXXrates: Rates,
  CXXprior_CXXcurrent: number
): Promise<void> {
  console.log("Updating credex and asset balances");

  // Update ledger space
  await ledgerSession.run(`
    MATCH (newDaynode:Daynode {Active: TRUE})

    // Update CXX credexes
    MATCH (credcoinCredex:Credex)
    WHERE credcoinCredex.Denomination = "CXX"
    SET 
      credcoinCredex.InitialAmount = credcoinCredex.InitialAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.OutstandingAmount = credcoinCredex.OutstandingAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.RedeemedAmount = credcoinCredex.RedeemedAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.DefaultedAmount = credcoinCredex.DefaultedAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.WrittenOffAmount = credcoinCredex.WrittenOffAmount / newDaynode.CXXprior_CXXcurrent

    // Update currency credexes
    MATCH (currencyCredex:Credex)
    WHERE currencyCredex.Denomination <> "CXX"
    SET
      currencyCredex.InitialAmount = (currencyCredex.InitialAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.OutstandingAmount = (currencyCredex.OutstandingAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.RedeemedAmount = (currencyCredex.RedeemedAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.DefaultedAmount = (currencyCredex.DefaultedAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.WrittenOffAmount = (currencyCredex.WrittenOffAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.CXXmultiplier = newDaynode[currencyCredex.Denomination]

    // Update CXX :REDEEMED relationships
    MATCH ()-[CXXredeemed:REDEEMED]-()
    WHERE CXXredeemed.Denomination = "CXX"
    SET
      CXXredeemed.AmountRedeemed = CXXredeemed.AmountRedeemed / newDaynode.CXXprior_CXXcurrent,
      CXXredeemed.AmountOutstandingNow = CXXredeemed.AmountOutstandingNow / newDaynode.CXXprior_CXXcurrent

    // Update currency :REDEEMED relationships
    MATCH ()-[currencyRedeemed:REDEEMED]-()
    WHERE currencyRedeemed.Denomination <> "CXX"
    SET
      currencyRedeemed.AmountOutstandingNow = (currencyRedeemed.AmountOutstandingNow / currencyRedeemed.CXXmultiplier) * newDaynode[currencyRedeemed.Denomination],
      currencyRedeemed.AmountRedeemed = (currencyRedeemed.AmountRedeemed / currencyRedeemed.CXXmultiplier) * newDaynode[currencyRedeemed.Denomination],
      currencyRedeemed.CXXmultiplier = newDaynode[currencyRedeemed.Denomination]

    // Update CXX :CREDLOOP relationships
    MATCH ()-[CXXcredloop:CREDLOOP]-()
    WHERE CXXcredloop.Denomination = "CXX"
    SET
      CXXcredloop.AmountRedeemed = CXXcredloop.AmountRedeemed / newDaynode.CXXprior_CXXcurrent,
      CXXcredloop.AmountOutstandingNow = CXXcredloop.AmountOutstandingNow / newDaynode.CXXprior_CXXcurrent

    // Update currency :CREDLOOP relationships
    MATCH ()-[currencyCredloop:CREDLOOP]-()
    WHERE currencyCredloop.Denomination <> "CXX"
    SET
      currencyCredloop.AmountOutstandingNow = (currencyCredloop.AmountOutstandingNow / currencyCredloop.CXXmultiplier) * newDaynode[currencyCredloop.Denomination],
      currencyCredloop.AmountRedeemed = (currencyCredloop.AmountRedeemed / currencyCredloop.CXXmultiplier) * newDaynode[currencyCredloop.Denomination],
      currencyCredloop.CXXmultiplier = newDaynode[currencyCredloop.Denomination]

    // Update loop anchors (always CXX)
    MATCH (loopAnchors:LoopAnchor)
    SET
      loopAnchors.LoopedAmount = loopAnchors.LoopedAmount / newDaynode.CXXprior_CXXcurrent
  `);

  // Update search space
  await searchSession.run(
    `
    MATCH (credex:Credex)
    WHERE credex.Denomination = "CXX"
    SET credex.outstandingAmount = credex.outstandingAmount / $CXXprior_CXXcurrent
  `,
    { CXXprior_CXXcurrent }
  );

  await searchSession.run(
    `
    MATCH (credex:Credex)
    WHERE credex.Denomination <> "CXX"
    WITH credex, $newCXXrates AS rates
    SET credex.outstandingAmount = (credex.outstandingAmount / credex.CXXmultiplier) * coalesce(rates[credex.Denomination], 1),
        credex.CXXmultiplier = coalesce(rates[credex.Denomination], 1)
  `,
    { newCXXrates }
  );
}

async function getFoundationData(
  session: any
): Promise<{ foundationID: string; foundationXOid: string }> {
  const result = await session.run(`
    MATCH (credexFoundation:Account {accountType: "CREDEX_FOUNDATION"})<-[:OWNS]-(foundationXO:Member)
    RETURN credexFoundation.accountID AS foundationID, foundationXO.memberID AS foundationXOid
  `);
  return {
    foundationID: result.records[0].get("foundationID"),
    foundationXOid: result.records[0].get("foundationXOid"),
  };
}

async function processDCOTransactions(
  session: any,
  foundationID: string,
  foundationXOid: string,
  DCOinCXX: number,
  numberConfirmedParticipants: number
): Promise<void> {
  console.log("Processing DCO transactions");

  const confirmedParticipants: Participant[] = (
    await session.run(`
    MATCH (daynode:Daynode{Active:true})
    MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
    WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
    RETURN
      DCOparticpantsDeclared.accountID AS accountID,
      DCOmember.memberID AS DCOmemberID,
      DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
      DCOparticpantsDeclared.DCOgiveInCXX / daynode[DCOparticpantsDeclared.DCOdenom] AS DCOgiveInDenom,
      DCOparticpantsDeclared.DCOdenom AS DCOdenom
  `)
  ).records.map((record: any) => record.toObject() as Participant);

  // Process DCO give transactions
  await Promise.all(
    confirmedParticipants.map(async (participant: Participant) => {
      const dataForDCOgive = {
        memberID: participant.DCOmemberID,
        issuerAccountID: participant.accountID,
        receiverAccountID: foundationID,
        Denomination: participant.DCOdenom,
        InitialAmount: participant.DCOgiveInDenom,
        credexType: "DCO_GIVE",
        securedCredex: true,
      };

      const DCOgiveCredex = await OfferCredexService(dataForDCOgive);
      if (
        typeof DCOgiveCredex.credex === "boolean" ||
        !DCOgiveCredex.credex?.credexID
      ) {
        throw new Error(
          "Invalid response from OfferCredexService for DCO give"
        );
      }
      await AcceptCredexService(DCOgiveCredex.credex.credexID, foundationXOid);
    })
  );

  // Process DCO receive transactions
  await Promise.all(
    confirmedParticipants.map(async (participant: Participant) => {
      const dataForDCOreceive = {
        memberID: foundationXOid,
        issuerAccountID: foundationID,
        receiverAccountID: participant.accountID,
        Denomination: "CXX",
        InitialAmount: DCOinCXX / numberConfirmedParticipants,
        credexType: "DCO_RECEIVE",
        securedCredex: true,
      };

      const DCOreceiveCredex = await OfferCredexService(dataForDCOreceive);
      if (
        typeof DCOreceiveCredex.credex === "boolean" ||
        !DCOreceiveCredex.credex?.credexID
      ) {
        throw new Error(
          "Invalid response from OfferCredexService for DCO receive"
        );
      }
      await AcceptCredexService(
        DCOreceiveCredex.credex.credexID,
        foundationXOid
      );
    })
  );
}



File: ./src/Core/DCO/DCOsnapshots/placeholder.ts
----------------------------------------
//placeholder


File: ./src/Core/DCO/DBinitialization.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../constants/denominations";
import { OnboardMemberController } from "../../Member/controllers/onboardMember";
import { UpdateMemberTierController } from "../../Member/controllers/updateMemberTier";
import { CreateAccountService } from "../../Account/services/CreateAccount";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { fetchZigRate } from "./fetchZigRate";
import axios from "axios";
import _ from "lodash";
import moment from "moment-timezone";
import logger from "../../../config/logger";

/**
 * Initializes the database for the Daily Credcoin Offering (DCO) process.
 * This function sets up necessary constraints, creates initial accounts,
 * and establishes the starting state for the DCO.
 */
export async function DBinitialization(): Promise<void> {
  console.log("Starting DBinitialization");

  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    await setupDatabaseConstraints(ledgerSpaceSession, searchSpaceSession);
    const dayZero = establishDayZero();
    const dayZeroCXXrates = await fetchAndProcessRates(dayZero);
    await createDayZeroDaynode(ledgerSpaceSession, dayZero, dayZeroCXXrates);
    await createInitialAccounts(ledgerSpaceSession);
  } catch (error) {
    logger.error("Error during DBinitialization", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}

/**
 * Sets up necessary database constraints and indexes.
 */
async function setupDatabaseConstraints(
  ledgerSpaceSession: any,
  searchSpaceSession: any
): Promise<void> {
  console.log("Creating database constraints and indexes...");

  // Remove any current db constraints
  await ledgerSpaceSession.run("CALL apoc.schema.assert({}, {})");
  await searchSpaceSession.run("CALL apoc.schema.assert({}, {})");

  // Set new constraints
  const constraints = [
    "CREATE CONSTRAINT daynodeDate_unique IF NOT EXISTS FOR (daynode:Daynode) REQUIRE daynode.Date IS UNIQUE",
    "CREATE CONSTRAINT memberID_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.memberID IS UNIQUE",
    "CREATE CONSTRAINT memberHandle_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.memberHandle IS UNIQUE",
    "CREATE CONSTRAINT memberPhone_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.phone IS UNIQUE",
    "CREATE CONSTRAINT accountID_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountID IS UNIQUE",
    "CREATE CONSTRAINT accountHandle_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountHandle IS UNIQUE",
  ];

  for (const constraint of constraints) {
    await ledgerSpaceSession.run(constraint);
  }

  await searchSpaceSession.run(
    "CREATE CONSTRAINT accountID_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountID IS UNIQUE"
  );
  await searchSpaceSession.run(
    "CREATE CONSTRAINT credexID_unique IF NOT EXISTS FOR (credex:Credex) REQUIRE credex.credexID IS UNIQUE"
  );
}

/**
 * Establishes the day zero date.
 */
function establishDayZero(): string {
  console.log("Establishing day zero");
  const dayZero =
    process.env.DEPLOYMENT === "dev"
      ? "2021-01-01"
      : moment.utc().subtract(1, "days").format("YYYY-MM-DD");
  console.log("Day zero:", dayZero);
  return dayZero;
}

/**
 * Fetches and processes currency rates for day zero.
 */
async function fetchAndProcessRates(dayZero: string): Promise<any> {
  console.log("Loading currencies and current rates...");
  const symbols = getDenominations({
    sourceForRate: "OpenExchangeRates",
    formatAsList: true,
  });
  const baseUrl = `https://openexchangerates.org/api/historical/${dayZero}.json?app_id=${process.env.OPEN_EXCHANGE_RATES_API}&symbols=${symbols}`;

  const {
    data: { rates: USDbaseRates },
  } = await axios.get(baseUrl);
  USDbaseRates.ZIG = (await fetchZigRate())[1].avg;

  const OneCXXinCXXdenom = 1;
  const CXXdenom = "CAD";
  console.log(OneCXXinCXXdenom + " CXX = 1 " + CXXdenom);

  const XAUbaseRates = _.mapValues(
    USDbaseRates,
    (value) => value / USDbaseRates.XAU
  );
  const dayZeroCXXrates = _.mapValues(
    XAUbaseRates,
    (value) => (1 / value) * OneCXXinCXXdenom * XAUbaseRates[CXXdenom]
  );
  dayZeroCXXrates.CXX = 1;

  console.log("Day zero CXX rates:", dayZeroCXXrates);
  return dayZeroCXXrates;
}

/**
 * Creates the day zero daynode in the database.
 */
async function createDayZeroDaynode(
  session: any,
  dayZero: string,
  dayZeroCXXrates: any
): Promise<void> {
  console.log("Creating day zero daynode...");
  await session.run(
    `
    CREATE (daynode:Daynode)
    SET daynode = $dayZeroCXXrates,
        daynode.Date = date($dayZero),
        daynode.Active = TRUE,
        daynode.DCOrunningNow = TRUE
  `,
    { dayZeroCXXrates, dayZero }
  );
}

/**
 * Creates initial accounts and relationships for the DCO process.
 */
async function createInitialAccounts(session: any): Promise<void> {
  console.log("Creating initialization accounts and relationships...");

  const rdubs = await createRdubsAccount();
  const credexFoundationID = await createCredexFoundation(
    rdubs.onboardedMemberID
  );
  const greatSunID = await createGreatSun(rdubs.onboardedMemberID);
  const vimbisoPayID = await createVimbisoPay(rdubs.onboardedMemberID);

  await createInitialRelationships(
    session,
    credexFoundationID,
    greatSunID,
    vimbisoPayID
  );
  await createInitialCredex(
    rdubs.onboardedMemberID,
    greatSunID,
    rdubs.personalAccountID
  );
}

async function createRdubsAccount(): Promise<{
  onboardedMemberID: string;
  personalAccountID: string;
}> {
  const result = await OnboardMemberController(
    "Ryan",
    "Watson",
    "263778177125"
  );

  if ("error" in result) {
    throw new Error(`Failed to create rdubs account: ${result.error}`);
  }

  const onboardedMemberID = result.memberDashboard.memberID;

  const updateTierResult = await UpdateMemberTierController(onboardedMemberID, 5);
  if (!updateTierResult.success) {
    throw new Error(`Failed to update member tier: ${updateTierResult.message}`);
  }

  const rdubsPersonalAccount = await CreateAccountService(
    onboardedMemberID,
    "PERSONAL_CONSUMPTION",
    "Ryan Watson Personal",
    "263778177125",
    "USD",
    1,
    "CAD"
  );

  return {
    onboardedMemberID,
    personalAccountID: rdubsPersonalAccount.accountID,
  };
}

async function createCredexFoundation(memberID: string): Promise<string> {
  const credexFoundation = await CreateAccountService(
    memberID,
    "CREDEX_FOUNDATION",
    "Credex Foundation",
    "credexfoundation",
    "CXX"
  );

  if (
    typeof credexFoundation.account === "boolean" ||
    !credexFoundation.accountID
  ) {
    throw new Error("Failed to create Credex Foundation account");
  }

  return credexFoundation.accountID;
}

async function createGreatSun(memberID: string): Promise<string> {
  const greatSun = await CreateAccountService(
    memberID,
    "BUSINESS",
    "Great Sun Financial",
    "greatsunfinancial",
    "CAD"
  );

  if (!greatSun || !greatSun.accountID) {
    throw new Error("Failed to create Great Sun account");
  }

  return greatSun.accountID;
}

async function createVimbisoPay(memberID: string): Promise<string> {
  const vimbisoPay = await CreateAccountService(
    memberID,
    "BUSINESS",
    "VimbisoPay",
    "vimbisopay.audited",
    "CAD"
  );

  if (!vimbisoPay || !vimbisoPay.accountID) {
    throw new Error("Failed to create VimbisoPay account");
  }

  return vimbisoPay.accountID;
}

async function createInitialRelationships(
  session: any,
  credexFoundationID: string,
  greatSunID: string,
  vimbisoPayID: string
): Promise<void> {
  await session.run(
    `
    MATCH (credexFoundation: Account { accountID: $credexFoundationID })
    MATCH (greatSun: Account { accountID: $greatSunID })
    MATCH (vimbisoPay: Account { accountID: $vimbisoPayID })
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (credexFoundation)
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (greatSun)
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (vimbisoPay)
  `,
    { credexFoundationID, greatSunID, vimbisoPayID }
  );
}

async function createInitialCredex(
  memberID: string,
  issuerAccountID: string,
  receiverAccountID: string
): Promise<void> {
  const credexData = {
    memberID,
    issuerAccountID,
    receiverAccountID,
    Denomination: "CAD",
    InitialAmount: 365, // fund DCO for a year with no adjustments
    credexType: "PURCHASE",
    securedCredex: true,
  };

  const DCOinitializationOfferCredex = await OfferCredexService(credexData);
  if (typeof DCOinitializationOfferCredex.credex === "boolean") {
    throw new Error("Invalid response from OfferCredexService");
  }
  if (
    DCOinitializationOfferCredex.credex &&
    typeof DCOinitializationOfferCredex.credex.credexID === "string"
  ) {
    await AcceptCredexService(
      DCOinitializationOfferCredex.credex.credexID,
      memberID
    );
  } else {
    throw new Error("Invalid credexID from OfferCredexService");
  }
}



File: ./src/Core/DCO/DBbackup.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import fs from "fs";
import path from "path";

const exportDatabase = async (
  driver: any,
  databaseName: string,
  previousDate: string,
  append: string
): Promise<void> => {
  const session = driver.session();
  try {
    const fileName = `${previousDate}_${databaseName}${append}.json`;
    const filePath = path.join(__dirname, "DCOsnapshots", fileName);

    const result = await session.run(`
      CALL apoc.export.json.all(null, {stream:true, useTypes:true})
    `);

    const records = result.records;
    let jsonData = "";
    records.forEach((record: any) => {
      jsonData += record.get(0);
    });

    fs.writeFileSync(filePath, jsonData);
    console.log(`Backup for ${databaseName} created successfully: ${filePath}`);
  } catch (error) {
    console.error(`Error creating backup for ${databaseName}:`, error);
    throw error;
  } finally {
    await session.close();
  }
};

export const createNeo4jBackup = async (
  previousDate: string,
  append: string
): Promise<void> => {
  try {
    await exportDatabase(ledgerSpaceDriver, "ledgerSpace_dev", previousDate, append);
    await exportDatabase(
      searchSpaceDriver,
      "searchSpace_dev",
      previousDate,
      append
    );
    console.log("Both databases backed up successfully.");
  } catch (error) {
    console.error("Error creating backups:", error);
    throw error;
  }
};



File: ./src/Core/MTQ/MinuteTransactionQueue.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { Session } from "neo4j-driver";
import { LoopFinder } from "./LoopFinder";
import _ from "lodash";
import logger from "../../../config/logger";

interface Account {
  accountID: string;
  accountName: string;
}

interface Credex {
  acceptedAt: string;
  issuerAccountID: string;
  acceptorAccountID: string;
  credexID: string;
  amount: number;
  denomination: string;
  CXXmultiplier: number;
  credexSecuredDenom: string;
  dueDate: string;
}

export async function MinuteTransactionQueue(): Promise<boolean> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  logger.info("MTQ start: checking if DCO or MTQ is in progress");

  try {
    const { DCOflag, MTQflag } = await checkDCOAndMTQStatus(ledgerSpaceSession);

    if (DCOflag === null || MTQflag === null) {
      logger.warn("No active daynode found. Skipping MTQ.");
      return false;
    }

    if (DCOflag || MTQflag) {
      if (DCOflag) logger.info("DCO in progress, holding MTQ");
      if (MTQflag) logger.info("MTQ already in progress, holding new MTQ");
      return false;
    }

    logger.info("Running MTQ");

    await setMTQRunningFlag(ledgerSpaceSession, true);

    const BAIL_TIME = 14 * 60 * 1000; // 14 minutes
    const bailTimer = setTimeout(() => {
      logger.warn("Bail timer reached");
      return true;
    }, BAIL_TIME);

    try {
      await processQueuedAccounts(ledgerSpaceSession, searchSpaceSession);
      await processQueuedCredexes(ledgerSpaceSession, searchSpaceSession);
    } finally {
      clearTimeout(bailTimer);
      await setMTQRunningFlag(ledgerSpaceSession, false);
    }

    logger.info("MTQ processing completed");
    return true;
  } catch (error) {
    logger.error("Error in MinuteTransactionQueue:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}

async function checkDCOAndMTQStatus(
  session: Session
): Promise<{ DCOflag: boolean | null; MTQflag: boolean | null }> {
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN
      daynode.DCOrunningNow AS DCOflag,
      daynode.MTQrunningNow AS MTQflag
  `);

  if (result.records.length === 0) {
    logger.warn("No active daynode found");
    return { DCOflag: null, MTQflag: null };
  }

  return {
    DCOflag: result.records[0].get("DCOflag"),
    MTQflag: result.records[0].get("MTQflag"),
  };
}

async function setMTQRunningFlag(
  session: Session,
  value: boolean
): Promise<void> {
  const result = await session.run(
    `
    MATCH (daynode:Daynode {Active: true})
    SET daynode.MTQrunningNow = $value
    RETURN daynode
  `,
    { value }
  );

  if (result.records.length === 0) {
    logger.warn("No active daynode found when setting MTQ running flag");
  }
}

async function processQueuedAccounts(
  ledgerSpaceSession: Session,
  searchSpaceSession: Session
): Promise<void> {
  const queuedAccounts = await getQueuedAccounts(ledgerSpaceSession);

  for (const account of queuedAccounts) {
    try {
      await createAccountInSearchSpace(searchSpaceSession, account);
      await markAccountAsProcessed(ledgerSpaceSession, account.accountID);
      logger.info(`Account created in searchSpace: ${account.accountName}`);
    } catch (error) {
      logger.error(`Error processing account ${account.accountName}:`, error);
    }
  }
}

async function getQueuedAccounts(session: Session): Promise<Account[]> {
  const result = await session.run(`
    MATCH (newAccount:Account {queueStatus: "PENDING_ACCOUNT"})
    RETURN
      newAccount.accountID AS accountID,
      newAccount.accountName AS accountName
  `);
  return result.records.map((record: any) => ({
    accountID: record.get("accountID"),
    accountName: record.get("accountName"),
  }));
}

async function createAccountInSearchSpace(
  session: Session,
  account: Account
): Promise<void> {
  const result = await session.run(
    `
    CREATE (newAccount:Account)
    SET newAccount = $account
    RETURN newAccount.accountID AS accountID
    `,
    { account }
  );

  if (result.records.length === 0) {
    throw new Error(
      `Failed to create account in searchSpace: ${account.accountName}`
    );
  }
}

async function markAccountAsProcessed(
  session: Session,
  accountID: string
): Promise<void> {
  await session.run(
    `
    MATCH (processedAccount:Account {accountID: $accountID})
    SET processedAccount.queueStatus = "PROCESSED"
    `,
    { accountID }
  );
}

async function processQueuedCredexes(
  ledgerSpaceSession: Session,
  searchSpaceSession: Session
): Promise<void> {
  const queuedCredexes = await getQueuedCredexes(ledgerSpaceSession);
  const sortedQueuedCredexes = _.sortBy(queuedCredexes, "acceptedAt");

  for (const credex of sortedQueuedCredexes) {
    try {
      await LoopFinder(
        credex.issuerAccountID,
        credex.credexID,
        credex.amount,
        credex.denomination,
        credex.CXXmultiplier,
        credex.credexSecuredDenom,
        credex.dueDate,
        credex.acceptorAccountID
      );
    } catch (error) {
      logger.error(`Error processing credex ${credex.credexID}:`, error);
    }
  }
}

async function getQueuedCredexes(session: Session): Promise<Credex[]> {
  const result = await session.run(`
    MATCH
      (issuerAccount:Account)
      -[:OWES]->(queuedCredex:Credex {queueStatus: "PENDING_CREDEX"})
      -[:OWES]->(acceptorAccount:Account)
    OPTIONAL MATCH (queuedCredex)<-[:SECURES]-(securer:Account)
    RETURN queuedCredex.acceptedAt AS acceptedAt,
           issuerAccount.accountID AS issuerAccountID,
           acceptorAccount.accountID AS acceptorAccountID,
           securer.accountID AS securerID,
           queuedCredex.credexID AS credexID,
           queuedCredex.InitialAmount AS amount,
           queuedCredex.Denomination AS denomination,
           queuedCredex.CXXmultiplier AS CXXmultiplier,
           queuedCredex.dueDate AS dueDate
  `);

  return result.records.map((record: any) => ({
    acceptedAt: record.get("acceptedAt"),
    issuerAccountID: record.get("issuerAccountID"),
    acceptorAccountID: record.get("acceptorAccountID"),
    credexID: record.get("credexID"),
    amount: record.get("amount").toNumber(),
    denomination: record.get("denomination"),
    CXXmultiplier: record.get("CXXmultiplier").toNumber(),
    credexSecuredDenom:
      record.get("securerID") !== null
        ? record.get("denomination")
        : "floating",
    dueDate: record.get("dueDate"),
  }));
}



File: ./src/Core/MTQ/LoopFinder.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { Session } from "neo4j-driver";
import logger from "../../../config/logger";

export async function LoopFinder(
  issuerAccountID: string,
  credexID: string,
  credexAmount: number,
  Denomination: string,
  CXXmultiplier: number,
  credexSecuredDenom: string,
  credexDueDate: string,
  acceptorAccountID: string
): Promise<boolean> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    const searchOwesType = getSearchOwesType(credexSecuredDenom);
    credexDueDate = await adjustCredexDueDate(ledgerSpaceSession, credexSecuredDenom, credexDueDate);

    await createOrUpdateSearchSpaceCredex(
      searchSpaceSession,
      issuerAccountID,
      acceptorAccountID,
      credexID,
      credexAmount,
      Denomination,
      CXXmultiplier,
      credexDueDate,
      searchOwesType
    );

    let searchForCredloops = true;
    while (searchForCredloops) {
      logger.info("Searching for credloops...");
      const { valueToClear, credexesInLoop, credexesRedeemed } = await findCredloop(searchSpaceSession, issuerAccountID, searchOwesType);

      if (credexesInLoop.length > 0) {
        await processCredloop(ledgerSpaceSession, searchSpaceSession, valueToClear, credexesInLoop, credexesRedeemed);
      } else {
        await markCredexAsProcessed(ledgerSpaceSession, credexID);
        logger.info("No credloops found. Credex marked as processed.");
        searchForCredloops = false;
      }
    }

    return true;
  } catch (error) {
    logger.error("Error in LoopFinder:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}

function getSearchOwesType(credexSecuredDenom: string): string {
  return credexSecuredDenom !== "floating" ? `${credexSecuredDenom}_SECURED` : "FLOATING";
}

async function adjustCredexDueDate(session: Session, credexSecuredDenom: string, credexDueDate: string): Promise<string> {
  if (credexSecuredDenom !== "floating") {
    const result = await session.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.Date AS today
    `);
    return result.records[0].get("today");
  }
  return credexDueDate;
}

async function createOrUpdateSearchSpaceCredex(
  session: Session,
  issuerAccountID: string,
  acceptorAccountID: string,
  credexID: string,
  credexAmount: number,
  Denomination: string,
  CXXmultiplier: number,
  credexDueDate: string,
  searchOwesType: string
): Promise<void> {
  const credexExists = await checkCredexExists(session, credexID);

  if (!credexExists) {
    await createSearchSpaceCredex(
      session,
      issuerAccountID,
      acceptorAccountID,
      credexID,
      credexAmount,
      Denomination,
      CXXmultiplier,
      credexDueDate,
      searchOwesType
    );
  } else {
    logger.info(`Credex already exists in SearchSpace: ${credexID}`);
  }
}

async function checkCredexExists(session: Session, credexID: string): Promise<boolean> {
  const result = await session.run(
    `
    OPTIONAL MATCH (credex:Credex {credexID: $credexID})
    RETURN credex IS NOT NULL AS credexExists
    `,
    { credexID }
  );
  return result.records[0].get("credexExists");
}

async function createSearchSpaceCredex(
  session: Session,
  issuerAccountID: string,
  acceptorAccountID: string,
  credexID: string,
  credexAmount: number,
  Denomination: string,
  CXXmultiplier: number,
  credexDueDate: string,
  searchOwesType: string
): Promise<void> {
  try {
    const result = await session.run(
      `
      MATCH (issuer:Account {accountID: $issuerAccountID})
      MATCH (acceptor:Account {accountID: $acceptorAccountID})
      MERGE (issuer)-[:${searchOwesType}]->(searchOwesType:${searchOwesType})-[:${searchOwesType}]->(acceptor)
        ON CREATE SET searchOwesType.searchAnchorID = randomUUID()
      CREATE (searchOwesType)<-[:SEARCH_SECURED]-(credex:Credex {
          credexID: $credexID,
          outstandingAmount: $credexAmount,
          Denomination: $Denomination,
          CXXmultiplier: $CXXmultiplier,
          dueDate: date($credexDueDate)
      })
      WITH searchOwesType, credex
      CALL apoc.do.case(
          [
              searchOwesType.earliestDueDate IS NULL
              OR searchOwesType.earliestDueDate > date($credexDueDate), 
              'SET searchOwesType.earliestDueDate = date($credexDueDate) RETURN true'
          ],
          'RETURN false',
          {
            searchOwesType: searchOwesType,
            credexDueDate: credex.dueDate
          }
      ) YIELD value
      RETURN credex.credexID AS credexID
      `,
      {
        issuerAccountID,
        acceptorAccountID,
        credexID,
        credexAmount,
        Denomination,
        CXXmultiplier,
        credexDueDate,
        searchOwesType,
      }
    );

    if (result.records.length === 0) {
      throw new Error("Unable to create SearchSpace credex");
    }

    logger.info(`Credex created in SearchSpace: ${result.records[0].get("credexID")}`);
  } catch (error) {
    logger.error("Error creating SearchSpace credex:", error);
    throw error;
  }
}

async function findCredloop(session: Session, issuerAccountID: string, searchOwesType: string): Promise<{ valueToClear: number; credexesInLoop: string[]; credexesRedeemed: string[] }> {
  const result = await session.run(
    `
    // Step 1: Find all loops starting and ending at the specified account, with the specified searchOwesType
    MATCH credloops = (issuer:Account {accountID: $issuerAccountID})-[:${searchOwesType}*]->(issuer)
    
    WITH credloops, nodes(credloops) AS loopNodes
    UNWIND loopNodes AS node
    WITH credloops, node
    WITH credloops, MIN(node.earliestDueDate) AS earliestDueDate

    // Step 3: Filter loops to include only those containing a node with the earliest earliestDueDate
    WITH credloops, earliestDueDate, nodes(credloops) AS loopNodes
    UNWIND loopNodes AS node
    WITH credloops, node
    WHERE node.earliestDueDate = earliestDueDate
    WITH credloops, length(credloops) AS loopLength

    // Step 4: Return only the longest loop, breaking ties with rand()
    ORDER BY loopLength DESC, rand()
    LIMIT 1
    WITH nodes(credloops) AS credloopNodes

    // Step 5: Each node returns the credex it is connected to with the earliest dueDate
    // on tie, credex with largest amount
    UNWIND credloopNodes AS loopNode
    MATCH (loopNode)<-[:SEARCH_SECURED]-(credex:Credex)
    WITH loopNode, collect(credex) AS credexList
    WITH 
           reduce(minCredex = credexList[0], c IN credexList | 
                  CASE 
                    WHEN c.dueDate < minCredex.dueDate THEN c
                    WHEN c.dueDate = minCredex.dueDate AND c.outstandingAmount > minCredex.outstandingAmount THEN c
                    ELSE minCredex 
                  END) AS earliestCredex
    WITH collect(earliestCredex) AS finalCredexes, COLLECT(earliestCredex.credexID) AS credexIDs

    // Step 6: Identify the minimum outstandingAmount and subtract it from all credexes
    UNWIND finalCredexes AS credexInLoop
    WITH finalCredexes, min(credexInLoop.outstandingAmount) AS lowestAmount, credexIDs

    UNWIND finalCredexes AS credex
    SET credex.outstandingAmount = credex.outstandingAmount - lowestAmount

    // Step 7: Collect all credexes and filter those with outstandingAmount = 0.
    WITH lowestAmount, COLLECT(credex) AS allCredexes, credexIDs
    WITH lowestAmount, allCredexes, [credex IN allCredexes WHERE credex.outstandingAmount = 0] AS zeroCredexes, credexIDs

    //Step 8: collect credexIDs of the zeroCredexes
    UNWIND zeroCredexes as zeroCredex
    RETURN collect(zeroCredex.credexID) AS zeroCredexIDs, lowestAmount, credexIDs
    `,
    { issuerAccountID, searchOwesType }
  );

  if (result.records.length > 0) {
    return {
      valueToClear: result.records[0].get("lowestAmount").toNumber(),
      credexesInLoop: result.records[0].get("credexIDs"),
      credexesRedeemed: result.records[0].get("zeroCredexIDs")
    };
  }

  return { valueToClear: 0, credexesInLoop: [], credexesRedeemed: [] };
}

async function processCredloop(ledgerSpaceSession: Session, searchSpaceSession: Session, valueToClear: number, credexesInLoop: string[], credexesRedeemed: string[]): Promise<void> {
  logger.info("Credexes in loop:", credexesInLoop);
  logger.info("Credexes redeemed:", credexesRedeemed);

  await cleanupSearchSpace(searchSpaceSession, credexesRedeemed);
  await updateLedgerSpace(ledgerSpaceSession, valueToClear, credexesInLoop, credexesRedeemed);
}

async function cleanupSearchSpace(session: Session, credexesRedeemed: string[]): Promise<void> {
  await session.run(
    `
    // Step 10: Delete zeroCredexes
    UNWIND $credexesRedeemed AS credexRedeemedID
    MATCH (credex:Credex {credexID: credexRedeemedID})-[:SEARCH_SECURED]->(searchAnchor)
    DETACH DELETE credex
    WITH DISTINCT searchAnchor

    // Step 11: Handle orphaned searchAnchors
    OPTIONAL MATCH (searchAnchor)<-[:SEARCH_SECURED]-(otherCredex:Credex)
    WITH searchAnchor, collect(otherCredex) AS otherCredexes
    CALL apoc.do.when(
      size(otherCredexes) = 0,
      'DETACH DELETE searchAnchor RETURN "searchAnchorDeleted" AS result',
      'RETURN "noChanges" AS result',
      {searchAnchor: searchAnchor}
    ) YIELD value AS deleteValue
    WITH deleteValue, searchAnchor, otherCredexes
    WHERE deleteValue <> "searchAnchorDeleted"

    // Step 12: Update earliestDueDate on remaining searchAnchors
    UNWIND otherCredexes AS otherCredex
    WITH DISTINCT searchAnchor, otherCredex
    CALL apoc.do.when(
      (searchAnchor.earliestDueDate IS NULL OR searchAnchor.earliestDueDate > date(otherCredex.dueDate)),
      'SET searchAnchor.earliestDueDate = date(otherCredex.dueDate) RETURN "searchAnchorEarliestUpdated" AS result',
      'RETURN "noChanges" AS result',
      {searchAnchor: searchAnchor, otherCredex: otherCredex}
    ) YIELD value AS updateValue
    RETURN searchAnchor
    `,
    { credexesRedeemed }
  );
}

async function updateLedgerSpace(session: Session, valueToClear: number, credexesInLoop: string[], credexesRedeemed: string[]): Promise<void> {
  logger.info(`Credloop of ${valueToClear} CXX found and cleared, now updating ledgerSpace`);

  const result = await session.run(
    `
    MATCH (daynode:Daynode {Active: true})
    CREATE (loopAnchor:LoopAnchor {
        loopedAt: DateTime(),
        loopID: randomUUID(),
        LoopedAmount: $valueToClear,
        CXXmultiplier: 1,
        Denomination: "CXX"
    })-[to_daynode:CREATED_ON]->(daynode)
    WITH loopAnchor

    UNWIND $credexesInLoop AS credexID
    MATCH (thisCredex:Credex {credexID: credexID})
    SET thisCredex.OutstandingAmount = thisCredex.OutstandingAmount - $valueToClear,
        thisCredex.RedeemedAmount = thisCredex.RedeemedAmount + $valueToClear
    WITH thisCredex, loopAnchor
    CREATE (thisCredex)-[:REDEEMED {
        AmountRedeemed: $valueToClear,
        AmountOutstandingNow: thisCredex.OutstandingAmount,
        Denomination: thisCredex.Denomination,
        CXXmultiplier: thisCredex.CXXmultiplier,
        createdAt: DateTime(),
        redeemedRelID: randomUUID()
    }]->(loopAnchor)

    WITH thisCredex, loopAnchor
    MATCH (loopAnchor)<-[:REDEEMED]-(thisCredex)
      -[:OWES]->(:Account)-[:OWES]->(nextCredex:Credex)
      -[:REDEEMED]->(loopAnchor)
    CREATE (thisCredex)-[:CREDLOOP {
        AmountRedeemed: $valueToClear,
        AmountOutstandingNow: thisCredex.OutstandingAmount,
        Denomination: thisCredex.Denomination,
        CXXmultiplier: thisCredex.CXXmultiplier,
        createdAt: DateTime(),
        loopID: loopAnchor.loopID,
        credloopRelID: randomUUID()
    }]->(nextCredex)

    WITH DISTINCT loopAnchor
    UNWIND $credexesRedeemed AS redeemedCredexID
    MATCH
      (owesOutAccount:Account)-[owes1:OWES]->
        (thisRedeemedCredex:Credex {credexID: redeemedCredexID})-[owes2:OWES]->
        (owesInAccount:Account),
      (thisRedeemedCredex)-[:REDEEMED]->(loopAnchor)
    CREATE
      (owesOutAccount)-[:CLEARED]->(thisRedeemedCredex)-[:CLEARED]->(owesInAccount)
    SET thisRedeemedCredex.DateRedeemed = DateTime()
    DELETE owes1, owes2

    RETURN DISTINCT loopAnchor.loopID AS loopID
    `,
    { valueToClear, credexesInLoop, credexesRedeemed }
  );

  logger.info(`LoopAnchor created: ${result.records[0].get("loopID")}`);
}

async function markCredexAsProcessed(session: Session, credexID: string): Promise<void> {
  await session.run(
    `
    MATCH (processedCredex:Credex {credexID: $credexID})
    SET processedCredex.queueStatus = "PROCESSED"
    RETURN processedCredex.credexID AS credexID
    `,
    { credexID }
  );
}

// TODO: Implement notification system
/*
async function createNotifications(session: Session, loopID: string): Promise<void> {
  // Implementation for creating notifications
}
*/



File: ./src/Core/cronJobs.ts
----------------------------------------
import cron from "node-cron";
import { DailyCredcoinOffering } from "./DCO/DailyCredcoinOffering";
import { MinuteTransactionQueue } from "./MTQ/MinuteTransactionQueue";

export default function startCronJobs() {
  // Running DailyCredcoinOffering every day at midnight UTC
  cron.schedule(
    "0 0 * * *",
    async () => {
      try {
        await DailyCredcoinOffering();
      } catch (error) {
        console.error("Error running DailyCredcoinOffering:", error);
      }
    },
    {
      timezone: "UTC",
    }
  );

  // Running MinuteTransactionQueue every minute
  cron.schedule("* * * * *", async () => {
    try {
      await MinuteTransactionQueue();
    } catch (error) {
      console.error("Error running MinuteTransactionQueue:", error);
    }
  });
}



File: ./src/Member/controllers/updateMemberTier.ts
----------------------------------------
import express from "express";
import { UpdateMemberTierService } from "../services/UpdateMemberTier";
import logger from "../../../config/logger";

/**
 * Controller for updating a member's tier
 * @param memberID - ID of the member
 * @param tier - New tier for the member
 * @returns Object containing success status and message
 */
export async function UpdateMemberTierController(
  memberID: string,
  tier: number
): Promise<{ success: boolean; message: string }> {
  try {
    // Input validation
    if (!memberID || typeof memberID !== 'string') {
      return { success: false, message: "Invalid memberID" };
    }

    if (!Number.isInteger(tier) || tier < 1) {
      return { success: false, message: "Invalid tier. Must be a positive integer." };
    }

    logger.info("Updating member tier", { memberID, tier });

    const result = await UpdateMemberTierService(memberID, tier);
    if (result) {
      logger.info("Member tier updated successfully", { memberID, tier });
      return { success: true, message: "Member tier updated successfully" };
    } else {
      logger.warn("Failed to update member tier", { memberID, tier });
      return { success: false, message: "Failed to update member tier" };
    }
  } catch (error) {
    logger.error("Error in UpdateMemberTierController", { error, memberID, tier });
    return { success: false, message: "Internal Server Error" };
  }
}

/**
 * Express middleware wrapper for updating a member's tier
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function updateMemberTierExpressHandler(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): Promise<void> {
  const { memberID, tier } = req.body;

  try {
    if (!memberID || typeof memberID !== 'string') {
      res.status(400).json({ message: "Invalid memberID. Must be a string." });
      return;
    }

    if (!Number.isInteger(tier) || tier < 1) {
      res.status(400).json({ message: "Invalid tier. Must be a positive integer." });
      return;
    }

    const result = await UpdateMemberTierController(memberID, tier);

    if (result.success) {
      res.status(200).json({ message: result.message });
    } else {
      res.status(400).json({ message: result.message });
    }
  } catch (error) {
    logger.error("Error in updateMemberTierExpressHandler", { error, memberID, tier });
    next(error);
  }
}



File: ./src/Member/controllers/getMemberDashboardByPhone.ts
----------------------------------------
import express from "express";
import { GetMemberDashboardByPhoneService } from "../services/GetMemberDashboardByPhone";
import { GetAccountDashboardController } from "../../Account/controllers/getAccountDashboard";
import logger from "../../../config/logger";

/**
 * Controller for retrieving a member's dashboard by phone number
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function GetMemberDashboardByPhoneController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { phone } = req.body;

  try {
    if (!phone || typeof phone !== 'string') {
      res.status(400).json({ message: "phone is required and must be a string" });
      return;
    }

    // Validate phone number format (simple regex for demonstration, adjust as needed)
    if (!/^\+?[1-9]\d{1,14}$/.test(phone)) {
      res.status(400).json({
        message: "Invalid phone number format. Please provide a valid international phone number.",
      });
      return;
    }

    logger.info("Retrieving member dashboard by phone", { phone });

    const memberDashboard = await GetMemberDashboardByPhoneService(phone);
    if (!memberDashboard) {
      logger.warn("Could not retrieve member dashboard", { phone });
      res.status(404).json({ message: "Could not retrieve member dashboard" });
      return;
    }

    const accountDashboards = await Promise.all(
      memberDashboard.accountIDS.map(async (accountId: string) => {
        const accountReq = {
          body: {
            memberID: memberDashboard.memberID,
            accountID: accountId
          }
        } as express.Request;
        const accountRes = {
          status: (code: number) => ({
            json: (data: any) => data
          })
        } as express.Response;

        return GetAccountDashboardController(accountReq, accountRes);
      })
    );

    logger.info("Member dashboard retrieved successfully", { phone, memberID: memberDashboard.memberID });
    res.status(200).json({ memberDashboard, accountDashboards });
  } catch (error) {
    logger.error("Error in GetMemberDashboardByPhoneController", { error, phone });
    next(error);
  }
}



File: ./src/Member/controllers/onboardMember.ts
----------------------------------------
import express from "express";
import { OnboardMemberService } from "../services/OnboardMember";
import { GetMemberDashboardByPhoneService } from "../services/GetMemberDashboardByPhone";
import logger from "../../../config/logger";

/**
 * Validates input for onboarding a new member
 * @param firstname - First name of the member
 * @param lastname - Last name of the member
 * @param phone - Phone number of the member
 * @returns null if valid, error message string if invalid
 */
function validateInput(
  firstname: string,
  lastname: string,
  phone: string
): string | null {
  if (!firstname || !lastname || !phone) {
    return "firstname, lastname, and phone are required";
  }
  if (
    typeof firstname !== "string" ||
    typeof lastname !== "string" ||
    typeof phone !== "string"
  ) {
    return "firstname, lastname, and phone must be strings";
  }
  if (firstname.length < 2 || firstname.length > 50 || lastname.length < 2 || lastname.length > 50) {
    return "First name and last name must be between 2 and 50 characters";
  }

  // Phone number validation (with optional '+' prefix)
  const phoneRegex = /^\+?[1-9]\d{1,14}$/;
  if (!phoneRegex.test(phone)) {
    return "Invalid phone number format. It should be a valid international phone number.";
  }

  return null;
}

/**
 * Controller for onboarding a new member
 * @param firstname - First name of the member
 * @param lastname - Last name of the member
 * @param phone - Phone number of the member
 * @returns Object containing member dashboard or error message
 */
export async function OnboardMemberController(
  firstname: string,
  lastname: string,
  phone: string
): Promise<{ memberDashboard: any } | { error: string }> {
  const validationError = validateInput(firstname, lastname, phone);
  if (validationError) {
    logger.warn("Invalid input for onboarding member", { firstname, lastname, phone, error: validationError });
    return { error: validationError };
  }

  try {
    logger.info("Onboarding new member", { firstname, lastname, phone });

    const onboardedMember = await OnboardMemberService(
      firstname,
      lastname,
      phone
    );

    if (!onboardedMember.onboardedMemberID) {
      logger.warn("Failed to onboard member", { firstname, lastname, phone, error: onboardedMember.message });
      return { error: onboardedMember.message || "Failed to onboard member" };
    }

    logger.info("Member onboarded successfully", { memberID: onboardedMember.onboardedMemberID });

    const memberDashboard = await GetMemberDashboardByPhoneService(phone);
    if (!memberDashboard) {
      logger.warn("Could not retrieve member dashboard after onboarding", { phone });
      return { error: "Could not retrieve member dashboard" };
    }

    logger.info("Member dashboard retrieved successfully", { memberID: onboardedMember.onboardedMemberID });
    return { memberDashboard };
  } catch (error) {
    logger.error("Error in OnboardMemberController", { error, firstname, lastname, phone });
    return { error: "Internal Server Error" };
  }
}

/**
 * Express middleware wrapper for onboarding a new member
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function onboardMemberExpressHandler(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): Promise<void> {
  const { firstname, lastname, phone } = req.body;

  try {
    const result = await OnboardMemberController(firstname, lastname, phone);

    if ("error" in result) {
      res.status(400).json({ message: result.error });
    } else {
      res.status(201).json(result);
    }
  } catch (error) {
    logger.error("Error in onboardMemberExpressHandler", { error, firstname, lastname, phone });
    next(error);
  }
}



File: ./src/Member/controllers/getMemberByHandle.ts
----------------------------------------
import express from "express";
import { GetMemberByHandleService } from "../services/GetMemberByHandle";
import logger from "../../../config/logger";

/**
 * Controller for retrieving a member by their handle
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function GetMemberByHandleController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { memberHandle } = req.body;

  try {
    if (!memberHandle || typeof memberHandle !== 'string') {
      res.status(400).json({ message: "memberHandle is required and must be a string" });
      return;
    }

    // Validate memberHandle format
    if (!/^[a-z0-9._]{3,30}$/.test(memberHandle)) {
      res.status(400).json({
        message: "Invalid member handle. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters.",
      });
      return;
    }

    logger.info("Retrieving member by handle", { memberHandle });

    const memberData = await GetMemberByHandleService(memberHandle);

    if (memberData) {
      logger.info("Member retrieved successfully", { memberHandle });
      res.status(200).json({ memberData });
    } else {
      logger.info("Member not found", { memberHandle });
      res.status(404).json({ message: "Member not found" });
    }
  } catch (error) {
    logger.error("Error in GetMemberByHandleController", { error, memberHandle });
    next(error);
  }
}



File: ./src/Member/controllers/securedCredexAuthForTier.ts
----------------------------------------
import express from "express";
import { SecuredCredexAuthForTier } from "../services/SecuredCredexAuthForTier";
import logger from "../../../config/logger";
import { getDenominations } from "../../Core/constants/denominations";

/**
 * Controller for authorizing secured credex for a member's tier
 * @param memberID - ID of the member
 * @param tier - Member's tier
 * @param Amount - Amount for authorization
 * @param Denomination - Denomination for authorization
 * @returns Object containing authorization status and message
 */
export async function SecuredCredexAuthForTierController(
  memberID: string,
  tier: number,
  Amount: number,
  Denomination: string
): Promise<{ isAuthorized: boolean; message: string }> {
  try {
    // Input validation
    if (!memberID || typeof memberID !== 'string') {
      return { isAuthorized: false, message: "Invalid memberID" };
    }

    if (!Number.isInteger(tier) || tier < 1) {
      return { isAuthorized: false, message: "Invalid tier" };
    }

    if (typeof Amount !== 'number' || Amount <= 0) {
      return { isAuthorized: false, message: "Invalid Amount" };
    }

    if (!Denomination || typeof Denomination !== 'string' || !getDenominations({ code: Denomination }).length) {
      return { isAuthorized: false, message: "Invalid Denomination" };
    }

    logger.info("Authorizing secured credex for tier", { memberID, tier, Amount, Denomination });

    const result = await SecuredCredexAuthForTier(memberID, Amount, Denomination);
    
    if (typeof result === 'string') {
      logger.warn("Secured credex authorization failed", { memberID, tier, Amount, Denomination, message: result });
      return { isAuthorized: false, message: result };
    } else {
      logger.info("Secured credex authorization successful", { memberID, tier, Amount, Denomination });
      return { isAuthorized: true, message: "Authorization successful" };
    }
  } catch (error) {
    logger.error("Error in SecuredCredexAuthForTierController", { error, memberID, tier, Amount, Denomination });
    return { isAuthorized: false, message: "Internal Server Error" };
  }
}

/**
 * Express middleware wrapper for secured credex authorization
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function securedCredexAuthForTierExpressHandler(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): Promise<void> {
  const { memberID, tier, Amount, Denomination } = req.body;

  try {
    const result = await SecuredCredexAuthForTierController(memberID, tier, Amount, Denomination);

    if (result.isAuthorized) {
      res.status(200).json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    logger.error("Error in securedCredexAuthForTierExpressHandler", { error, memberID, tier, Amount, Denomination });
    next(error);
  }
}



File: ./src/Member/services/SecuredCredexAuthForTier.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";

export async function SecuredCredexAuthForTier(
  issuerAccountID: string,
  amount: number,
  denom: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const queryResult = await ledgerSpaceSession.run(
      `
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        WITH member, member.memberTier AS memberTier

        // If memberTier > 2, return true immediately as "result"
        WHERE memberTier > 2
        RETURN true AS result

        UNION

        // If memberTier <= 2, proceed with the larger search query and return calculated values in an object as "result"
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        WITH member, member.memberTier AS memberTier, account
        WHERE memberTier <= 2
        MATCH (daynode:Daynode { Active: true })
        OPTIONAL MATCH (member)-[:OWNS]->(allAccounts:Account)
        OPTIONAL MATCH
          (allAccounts)-[:OWES|OFFERS]->(credex:Credex)<-[:SECURES]-(Account),
          (credex)-[:CREATED_ON]->(daynode)
        WITH
          daynode.USD AS daynodeUSD,
          SUM(credex.InitialAmount) AS dayTotalCXX,
          $amount * daynode[$denom] AS credexAmountCXX,
          memberTier
        RETURN
          {
            dayTotalUSD: dayTotalCXX / daynodeUSD,
            credexAmountUSD: credexAmountCXX / daynodeUSD,
            memberTier: memberTier
          } AS result
    `,
      { issuerAccountID, amount, denom }
    );

    if (queryResult.records.length === 0) {
      return "query error";
    }
    if (queryResult.records[0].get("result") == true) {
      return true;
    }

    const memberTier = queryResult.records[0].get("result").memberTier;
    const dayTotalUSD = queryResult.records[0].get("result").dayTotalUSD;
    const credexAmountUSD =
      queryResult.records[0].get("result").credexAmountUSD;

    var amountAvailableUSD = 0;
    if (memberTier == 1) {
      amountAvailableUSD = 10 - dayTotalUSD;
    }
    if (memberTier == 2) {
      amountAvailableUSD = 100 - dayTotalUSD;
    }
    if (amountAvailableUSD >= credexAmountUSD) {
      return true;
    } else {
      return (
        "You are only able to issue " +
        denomFormatter(amountAvailableUSD, "USD") +
        " USD until tomorrow. Limits renew at midnight UTC."
      );
    }
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Member/services/GetMemberByHandle.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function GetMemberByHandleService(
  memberHandle: string
): Promise<any | null> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  if (!memberHandle) {
    console.log("memberHandle is required");
    return null;
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH (member:Member { memberHandle: $memberHandle })
            RETURN
              member.memberID AS memberID,
              member.firstname AS firstname,
              member.lastname AS lastname
        `,
      { memberHandle }
    );

    if (!result.records.length) {
      console.log("member not found");
      return null;
    }

    const memberID = result.records[0].get("memberID");
    const firstname = result.records[0].get("firstname");
    const lastname = result.records[0].get("lastname");

    return {
      memberID: memberID,
      memberName: firstname + " " + lastname,
    };
  } catch (error) {
    console.error("Error fetching member data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Member/services/UpdateMemberTier.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import * as neo4j from "neo4j-driver";

export async function UpdateMemberTierService(
  memberIDtoUpdate: string,
  newTier: number
) {
  if (newTier < 1 || newTier > 5) {
    return {
      message: "New member tier is not a valid value",
    };
  }
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH (member:Member { memberID: $memberIDtoUpdate })
        SET member.memberTier = $newTier
        RETURN
          member.memberID AS memberIDupdated
      `,
      {
        memberIDtoUpdate,
        newTier: neo4j.int(newTier),
      }
    );

    if (!result.records.length) {
      return false;
    }

    const record = result.records[0];

    if (record.get("memberIDupdated")) {
      console.log("Member tier for " + memberIDtoUpdate + " set to " + newTier);
      return true;
    } else {
      console.log("could not authorize account");
      return false;
    }
  } catch (error) {
    console.error("Error updating member tier: ", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Member/services/GetMemberDashboardByPhone.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";

export async function GetMemberDashboardByPhoneService(phone: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
      MATCH (daynode:Daynode { Active: true })
      MATCH (member:Member { phone: $phone })
      OPTIONAL MATCH (member)-[:OWNS]->(account:Account)
      OPTIONAL MATCH (account)-[:OWES|OFFERS]->(credex:Credex)-[:CREATED_ON]->(daynode)
      WITH
        member, daynode,
        COLLECT(account.accountID) AS accountIDs,
        SUM(credex.InitialAmount) AS totalIssuedTodayCXX
      RETURN
        member.memberID AS memberID,
        member.firstname AS firstname,
        member.lastname AS lastname,
        member.memberHandle AS memberHandle,
        member.defaultDenom AS defaultDenom,
        member.memberTier AS memberTier,
        totalIssuedTodayCXX/daynode["USD"] AS totalIssuedTodayUSD,
        accountIDs AS accountIDS
      `,
      { phone }
    );

    if (!result.records.length) {
      console.log("member not found by phone");
      return false;
    }

    const memberTier = result.records[0].get("memberTier").low;
    const totalIssuedTodayUSD = result.records[0].get("totalIssuedTodayUSD");
    console.log(totalIssuedTodayUSD);
    let remainingAvailableUSD: number = Infinity;
    if (memberTier == 1) {
      remainingAvailableUSD = parseFloat(
        denomFormatter(10 - totalIssuedTodayUSD, "USD")
      );
    }
    if (memberTier == 2) {
      remainingAvailableUSD = parseFloat(
        denomFormatter(100 - totalIssuedTodayUSD, "USD")
      );
    }

    return {
      memberID: result.records[0].get("memberID"),
      firstname: result.records[0].get("firstname"),
      lastname: result.records[0].get("lastname"),
      memberHandle: result.records[0].get("memberHandle"),
      defaultDenom: result.records[0].get("defaultDenom"),
      memberTier: memberTier,
      remainingAvailableUSD: remainingAvailableUSD,
      accountIDS: result.records[0].get("accountIDS"),
    };
  } catch (error) {
    console.error("Error fetching account data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Member/services/OnboardMember.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../../Core/constants/denominations";

export async function OnboardMemberService(
  firstname: string,
  lastname: string,
  phone: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const defaultDenom = "USD";

  try {
    // Validation: Check defaultDenom in denominations
    if (!getDenominations({ code: defaultDenom }).length) {
      const message = "defaultDenom not in denoms";
      console.log(message);
      return { onboardedMemberID: false, message: message };
    }

    const result = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode { Active: true })
        CREATE (member:Member{
          firstname: $firstname,
          lastname: $lastname,
          memberHandle: $phone,
          defaultDenom: $defaultDenom,
          phone: $phone,
          memberID: randomUUID(),
          memberTier: 1,
          createdAt: datetime(),
          updatedAt: datetime()
        })-[:CREATED_ON]->(daynode)
        RETURN
          member.memberID AS memberID
      `,
      {
        firstname,
        lastname,
        defaultDenom,
        phone,
      }
    );

    if (!result.records.length) {
      const message = "could not onboard member";
      console.log(message);
      return { onboardedMemberID: false, message: message };
    }

    const memberID = result.records[0].get("memberID");

    console.log("member onboarded: " + memberID);
    return {
      onboardedMemberID: memberID,
      message: "member onboarded",
    };
  } catch (error) {
    console.error("Error onboarding member:", error);

    // Type guard to narrow the type of error
    if (
      isNeo4jError(error) &&
      error.code === "Neo.ClientError.Schema.ConstraintValidationFailed"
    ) {
      if (error.message.includes("phone")) {
        return {
          onboardedMemberID: false,
          message: "Phone number already in use",
        };
      }
      if (error.message.includes("memberHandle")) {
        return {
          onboardedMemberID: false,
          message: "Member handle already in use",
        };
      }
      return {
        onboardedMemberID: false,
        message: "Required unique field not unique",
      };
    }

    return {
      onboardedMemberID: false,
      message:
        "Error: " + (error instanceof Error ? error.message : "Unknown error"),
    };
  } finally {
    await ledgerSpaceSession.close();
  }
}

// Type guard to check if an error is a Neo4j error
function isNeo4jError(
  error: unknown
): error is { code: string; message: string } {
  return (
    typeof error === "object" &&
    error !== null &&
    "code" in error &&
    "message" in error
  );
}



File: ./src/Member/memberRoutes.ts
----------------------------------------
import express from "express";
import { GetMemberByHandleController } from "./controllers/getMemberByHandle";
import { GetMemberDashboardByPhoneController } from "./controllers/getMemberDashboardByPhone";
import { updateMemberTierExpressHandler } from "./controllers/updateMemberTier";
import { onboardMemberExpressHandler } from "./controllers/onboardMember";

const router = express.Router();

/**
 * @openapi
 * /member/getMemberByHandle:
 *   post:
 *     tags:
 *       - Member
 *     summary: Get member by handle
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - memberHandle
 *             properties:
 *               memberHandle:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/getMemberByHandle", GetMemberByHandleController);

/**
 * @openapi
 * /member/getMemberDashboardByPhone:
 *   post:
 *     tags:
 *       - Member
 *     summary: Get member dashboard by phone
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - phone
 *             properties:
 *               phone:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/getMemberDashboardByPhone", GetMemberDashboardByPhoneController);

/**
 * @openapi
 * /member/onboardMember:
 *   post:
 *     tags:
 *       - Member
 *     summary: Onboard a new member
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - firstname
 *               - lastname
 *               - phone
 *             properties:
 *               firstname:
 *                 type: string
 *               lastname:
 *                 type: string
 *               phone:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/onboardMember", onboardMemberExpressHandler);

/**
 * @openapi
 * /member/updateMemberTier:
 *   post:
 *     tags:
 *       - Member
 *     summary: Update member tier
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - memberID
 *               - tier
 *             properties:
 *               memberID:
 *                 type: string
 *               tier:
 *                 type: number
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/updateMemberTier", updateMemberTierExpressHandler);

export default router;



File: ./src/DevAdmin/controllers/createTestMembersAndAccounts.ts
----------------------------------------
import express from "express";
import { CreateTestMembersAndAccountsService } from "../services/CreateTestMembersAndAccounts";

export async function CreateTestMembersAndAccountsController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewAccounts is provided in the request body
  if (!req.body.numNewAccounts) {
    return res.status(400).json({ message: "numNewAccounts is required" });
  }

  try {
    // Call the service to create test accounts
    const responseData = await CreateTestMembersAndAccountsService(
      req.body.numNewAccounts
    );

    // Send the response with the created test accounts
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test accounts:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/offerAndAcceptCredex.ts
----------------------------------------
import express from "express";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";

export async function OfferAndAcceptCredexController(
  req: express.Request,
  res: express.Response
) {
  try {
    /*
    const responseDataOffer = await OfferCredexService(req.body);
    if (typeof responseDataOffer.credex == "boolean") {
      throw new Error("Invalid response from OfferCredexService");
    }
    if (
      responseDataOffer.credex &&
      typeof responseDataOffer.credex.credexID === "string"
    ) {
      const responseDataAccept = await AcceptCredexService(
        responseDataOffer.credex.credexID
      );
      if (responseDataAccept) {
        res.json(responseDataAccept.acceptedCredexID);
      }
    } else {
      res.status(500).json(responseDataOffer.message);
    }
      */
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/DevAdmin/controllers/forceDCO.ts
----------------------------------------
import express from "express";
import { DailyCredcoinOffering } from "../../Core/DCO/DailyCredcoinOffering";

export async function ForceDcoController(
  req: express.Request,
  res: express.Response
) {
  try {
    const responseData = await DailyCredcoinOffering();
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/DevAdmin/controllers/createRandomFloatingCredexes.ts
----------------------------------------
import express from "express";
import { CreateRandomFloatingCredexesService } from "../services/CreateRandomFloatingCredexes";

export async function CreateRandomFloatingCredexesController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewTransactions is provided in the request body
  if (!req.body.numNewTransactions) {
    return res.status(400).json({ message: "numNewTransactions is required" });
  }

  try {
    // Call the service to create test transactions
    const responseData = await CreateRandomFloatingCredexesService(
      req.body.numNewTransactions
    );

    // Send the response with the created test transactions
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test transactions:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/growthTest.ts
----------------------------------------
import express from "express";
import { GrowthTestService } from "../services/GrowthTest";

export async function GrowthTestController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = [
    "numberDays",
    "accountGrowthRate",
    "USD_SECURED_fractionToPurchase",
    "USD_SECURED_amountPerPurchaseLow",
    "USD_SECURED_amountPerPurchaseHigh",
    "USD_SECURED_fractionToSell",
    "ZIG_SECURED_fractionToPurchase",
    "ZIG_SECURED_amountPerPurchaseLow",
    "ZIG_SECURED_amountPerPurchaseHigh",
    "ZIG_SECURED_fractionToSell",
    "dailyFloatingRandomTransactionsPerAccount",
  ];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }
  try {
    const responseData = await GrowthTestService(req.body);
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error in growthTest:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/clearDevDb.ts
----------------------------------------
import express from "express";
import { ClearDevDbService } from "../services/ClearDevDb";

export async function ClearDevDbController(
  req: express.Request,
  res: express.Response,
) {
  try {
    // Call the service to clear the development database
    await ClearDevDbService();

    // Send a success response
    res
      .status(200)
      .json({ message: "Development databases cleared successfully" });
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error clearing development databases:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/checkLedgerVsSearchBalances.ts
----------------------------------------
import express from "express";
import { CheckLedgerVsSearchBalances } from "../services/CheckLedgerVsSearchBalances";

export async function CheckLedgerVsSearchBalancesController(
  req: express.Request,
  res: express.Response
) {
  try {
    const balanceCheck = await CheckLedgerVsSearchBalances();

    // Send a success response
    res.status(200).json({ balanceCheck });
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error checking balances:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/forceMTQ.ts
----------------------------------------
import express from "express";
import { MinuteTransactionQueue } from "../../Core/MTQ/MinuteTransactionQueue";

export async function ForceMtqController(
  req: express.Request,
  res: express.Response
) {
  try {
    const responseData = await MinuteTransactionQueue();
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/DevAdmin/controllers/createTestLoop.ts
----------------------------------------
import express from "express";
import { CreateTestLoopService } from "../services/CreateTestLoop";

export async function CreateTestLoopController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewTransactions is provided in the request body
  if (!req.body.numNewTransactions) {
    return res.status(400).json({ message: "numNewTransactions is required" });
  }

  try {
    // Call the service to create test transactions
    const responseData = await CreateTestLoopService(
      req.body.numNewTransactions
    );

    // Send the response with the created test transactions
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test transactions:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/services/InEcosystemSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { GetSecuredAuthorizationService } from "../../Credex/services/GetSecuredAuthorization";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function InEcosystemSecuredCredexesService(
  denom: string,
  number: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Creating in-ecosystem ${denom} secured credexes: ${number}`);

  try {
    if (number > 0) {
      const result = await ledgerSpaceSession.run(
        `
        MATCH
          (issuer:Account)<-[transactionType:OWES]-
          (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH
          (issuer)-[transactionType:OWES]->
          (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
        WITH
          issuer,
          sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
        WHERE netIn > 0
        WITH
          issuer.accountID AS issuerAccountID
        ORDER BY rand() 
        LIMIT $number
        WITH collect(issuerAccountID) AS issuerAccountIDs
        UNWIND issuerAccountIDs AS issuerAccountID
        MATCH (randomCounterparty:Account)
        WHERE randomCounterparty.accountID <> issuerAccountID
        WITH issuerAccountID, randomCounterparty.accountID AS receiverAccountID
        ORDER BY rand()
        RETURN issuerAccountID, receiverAccountID
        LIMIT $number
        `,
        {
          number: neo4j.int(number),
          denom,
        }
      );

      if (result.records.length === 0) {
        console.log("No records found for circulation.");
        return;
      }

      const batchSize = 3;
      const records = result.records;

      for (let i = 0; i < records.length; i += batchSize) {
        const batch = records.slice(i, i + batchSize);

        const offerPromises = batch.map(async (record) => {
          const issuerAccountID: string = record.get("issuerAccountID");
          const receiverAccountID: string = record.get("receiverAccountID");

          try {
            const securableData = await GetSecuredAuthorizationService(
              issuerAccountID,
              denom
            );

            const maxSecurable = securableData.securableAmountInDenom;
            let InitialAmount;
            if (maxSecurable >= 1) {
              InitialAmount = random(maxSecurable);
            } else {
              InitialAmount = random(0.1, maxSecurable);
            }
            console.log("random initialAmount: " + InitialAmount);

            const credexSpecs = {
              issuerAccountID: issuerAccountID,
              receiverAccountID: receiverAccountID,
              Denomination: denom,
              InitialAmount: InitialAmount,
              credexType: "PURCHASE",
              securedCredex: true,
            };

            const newcredex = await OfferCredexService(credexSpecs);

            if (
              typeof newcredex.credex === "boolean" ||
              !newcredex.credex?.credexID
            ) {
              throw new Error("Invalid response from OfferCredexService");
            }

            await AcceptCredexService(newcredex.credex.credexID);
          } catch (error) {
            console.error("Error processing credex offer:", error);
            // Handle error as needed
          }
        });

        await Promise.all(offerPromises);
      }
    }
  } catch (error) {
    console.error("Error in InEcosystemSecuredCredexesService:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
*/
}



File: ./src/DevAdmin/services/SellSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { GetSecuredAuthorizationService } from "../../Credex/services/GetSecuredAuthorization";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function SellSecuredCredexesService(
  denom: string,
  number: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Selling ${denom} secured credexes for cash: ${number}`);

  try {
    if (number > 0) {
      const result = await ledgerSpaceSession.run(
        `
        MATCH
          (issuer:Account)<-[transactionType:OWES]-
          (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH
          (issuer)-[transactionType:OWES]->
          (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
        WITH
          issuer, securer,
          sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
        WHERE netIn > 0
        RETURN
          issuer.accountID AS issuerAccountID,
          securer.accountID AS receiverAccountID
          ORDER BY rand() LIMIT $number;
        `,
        {
          number: neo4j.int(number),
          denom,
        }
      );

      if (result.records.length === 0) {
        console.log("No records found for selling secured credexes.");
        return;
      }

      const batchSize = 3;
      const records = result.records;

      for (let i = 0; i < records.length; i += batchSize) {
        const batch = records.slice(i, i + batchSize);

        const offerPromises = batch.map(async (record) => {
          const issuerAccountID: string = record.get("issuerAccountID");
          const receiverAccountID: string = record.get("receiverAccountID");

          try {
            const securableData = await GetSecuredAuthorizationService(
              issuerAccountID,
              denom
            );

            const InitialAmount = random(
              1,
              securableData.securableAmountInDenom || 1
            );

            const credexSpecs = {
              issuerAccountID: issuerAccountID,
              receiverAccountID: receiverAccountID,
              Denomination: denom,
              InitialAmount: InitialAmount,
              credexType: "PURCHASE",
              securedCredex: true,
            };

            const newcredex = await OfferCredexService(credexSpecs);

            if (
              typeof newcredex.credex === "boolean" ||
              !newcredex.credex?.credexID
            ) {
              throw new Error("Invalid response from OfferCredexService");
            }

            await AcceptCredexService(newcredex.credex.credexID);
          } catch (error) {
            console.error("Error processing credex offer:", error);
            // Handle error as needed
          }
        });

        await Promise.all(offerPromises);
      }
    }
  } catch (error) {
    console.error("Error in SellSecuredCredexesService:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
  */
}



File: ./src/DevAdmin/services/CheckLedgerVsSearchBalances.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";

export async function CheckLedgerVsSearchBalances() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    // Query ledgerSpace for credex data
    const ledgerSpaceCredexesQuery = await ledgerSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDledger,
        credex.OutstandingAmount AS OutstandingAmountLedger
    `);

    // Query searchSpace for credex data
    const searchSpaceCredexesQuery = await searchSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDsearch,
        credex.outstandingAmount AS OutstandingAmountSearch
    `);

    // Process ledgerSpace results
    const ledgerSpaceCredexes = ledgerSpaceCredexesQuery.records.map(
      (record) => ({
        credexID: record.get("credexIDledger"),
        OutstandingAmount: record.get("OutstandingAmountLedger"),
      })
    );

    // Process searchSpace results
    const searchSpaceCredexes = searchSpaceCredexesQuery.records.map(
      (record) => ({
        credexID: record.get("credexIDsearch"),
        OutstandingAmount: record.get("OutstandingAmountSearch"),
      })
    );

    // Create a map for quick lookup from searchSpace
    const searchSpaceCredexMap = new Map(
      searchSpaceCredexes.map((credex) => [
        credex.credexID,
        credex.OutstandingAmount,
      ])
    );

    // Compare and analyze the data
    let matchingCount = 0;
    const mismatchedCredexes = [];

    for (const ledgerCredex of ledgerSpaceCredexes) {
      const searchOutstandingAmount = searchSpaceCredexMap.get(
        ledgerCredex.credexID
      );

      // If the credex does not exist in searchSpace and the amount in ledgerSpace is 0, count as a match
      if (
        searchOutstandingAmount === undefined &&
        ledgerCredex.OutstandingAmount === 0
      ) {
        matchingCount++;
      } else if (ledgerCredex.OutstandingAmount === searchOutstandingAmount) {
        matchingCount++;
      } else {
        mismatchedCredexes.push({
          credexID: ledgerCredex.credexID,
          OutstandingAmountLedger: ledgerCredex.OutstandingAmount,
          OutstandingAmountSearch: searchOutstandingAmount || 0,
        });
      }
    }

    // Return the results
    return {
      matchingCount,
      mismatchedCredexes,
    };
  } catch (error) {
    console.error("An error occurred during the execution:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}



File: ./src/DevAdmin/services/GrowthTest.ts
----------------------------------------
import { CreateTestMembersAndAccountsService } from "./CreateTestMembersAndAccounts";
import { CreateRandomFloatingCredexesService } from "./CreateRandomFloatingCredexes";
import { DailyCredcoinOffering } from "../../Core/DCO/DailyCredcoinOffering";
import { MinuteTransactionQueue } from "../../Core/MTQ/MinuteTransactionQueue";
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { PurchaseSecuredCredexesService } from "./PurchaseSecuredCredexes";
import { SellSecuredCredexesService } from "./SellSecuredCredexes";
import { InEcosystemSecuredCredexesService } from "./InEcosystemSecuredCredexes";

export async function GrowthTestService(variables: any) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    // Get current number of accounts
    const numberAccountsQuery = await ledgerSpaceSession.run(`
      MATCH (account:Account)
      RETURN count(account) AS numberAccounts
    `);
    let numberAccounts = parseFloat(
      numberAccountsQuery.records[0].get("numberAccounts")
    );

    for (let index = 0; index < variables.numberDays; index++) {
      let numberNewAccounts = Math.round(
        numberAccounts * variables.accountGrowthRate
      );
      if (numberNewAccounts < 1) {
        numberNewAccounts = 1;
      }

      console.log(`Day ${index + 1}`);
      console.log(`Current number of accounts: ${numberAccounts}`);
      console.log(`Creating new accounts: ${numberNewAccounts}`);
      numberAccounts += numberNewAccounts;

      await CreateTestMembersAndAccountsService(numberNewAccounts);

      const numberUSDpurchases = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToPurchase
      );
      await PurchaseSecuredCredexesService(
        "USD",
        numberUSDpurchases,
        variables.USD_SECURED_amountPerPurchaseLow,
        variables.USD_SECURED_amountPerPurchaseHigh
      );

      const numberUSDsecuredCirculate = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToCirculate
      );
      await InEcosystemSecuredCredexesService("USD", numberUSDsecuredCirculate);

      const numberUSDsales = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToSell
      );
      await SellSecuredCredexesService("USD", numberUSDsales);

      const numberZIGpurchases = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToPurchase
      );
      await PurchaseSecuredCredexesService(
        "ZIG",
        numberZIGpurchases,
        variables.ZIG_SECURED_amountPerPurchaseLow,
        variables.ZIG_SECURED_amountPerPurchaseHigh
      );

      const numberZIGsecuredCirculate = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToCirculate
      );
      await InEcosystemSecuredCredexesService("ZIG", numberZIGsecuredCirculate);

      const numberZIGsales = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToSell
      );
      await SellSecuredCredexesService("ZIG", numberZIGsales);

      const numberRandomFloatingTransactions = Math.round(
        numberAccounts * variables.dailyFloatingRandomTransactionsPerAccount
      );
      console.log(
        `Creating random floating credexes: ${numberRandomFloatingTransactions}`
      );
      if (numberRandomFloatingTransactions > 0) {
        await CreateRandomFloatingCredexesService(
          numberRandomFloatingTransactions
        );
      }

      await DailyCredcoinOffering();
      await MinuteTransactionQueue();
    }

    console.log("This run of GrowthTestService is complete");
  } catch (error) {
    console.error(
      "An error occurred during the GrowthTestService execution:",
      error
    );
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/DevAdmin/services/PurchaseSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function PurchaseSecuredCredexesService(
  denom: string,
  number: number,
  lowValue: number,
  highValue: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Purchasing ${denom} secured credexes: ${number}`);

  if (number > 0) {
    const getSecuredUSDCounterparties = await ledgerSpaceSession.run(
      `
        // Step 1: Select a random audited account
        MATCH (auditedAccount:Account)<-[:CREDEX_FOUNDATION_AUDITED]-(foundation:Account)
        WITH auditedAccount, rand() AS rand
        ORDER BY rand LIMIT 1

        // Step 2: Collect account IDs for purchasers
        MATCH (accounts:Account)
        WHERE accounts.accountID <> auditedAccount.accountID
        WITH auditedAccount, collect(accounts.accountID) AS allaccounts
        RETURN auditedAccount.accountID AS auditedID, allaccounts[0..$number] AS accountsToPurchaseUSDsecured
      `,
      {
        number: neo4j.int(number),
      }
    );

    const issuerAccountID =
      getSecuredUSDCounterparties.records[0].get("auditedID");
    const accountsToPurchaseUSDsecured =
      getSecuredUSDCounterparties.records[0].get(
        "accountsToPurchaseUSDsecured"
      );

    const batchSize = 3;

    for (let i = 0; i < accountsToPurchaseUSDsecured.length; i += batchSize) {
      const batch = accountsToPurchaseUSDsecured.slice(i, i + batchSize);

      const offerPromises = batch.map((receiverAccountID: string) => {
        const InitialAmount = random(lowValue, highValue);

        const credexSpecs = {
          issuerAccountID: issuerAccountID,
          receiverAccountID: receiverAccountID,
          Denomination: denom,
          InitialAmount: InitialAmount,
          credexType: "PURCHASE",
          securedCredex: true,
        };

        return OfferCredexService(credexSpecs);
      });

      const offerCredexArray = await Promise.all(offerPromises);

      const acceptPromises = offerCredexArray.map((newcredex) => {
        if (typeof newcredex.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
          return AcceptCredexService(newcredex.credex.credexID);
        } else {
          return Promise.reject(newcredex.message);
        }
      });

      await Promise.all(acceptPromises);
    }
  }

  await ledgerSpaceSession.close();
  */
}



File: ./src/DevAdmin/services/CreateTestMembersAndAccounts.ts
----------------------------------------
import axios from "axios";
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OnboardMemberService } from "../../Member/services/OnboardMember";
import { CreateAccountService } from "../../Account/services/CreateAccount";
import { random } from "lodash";

export async function CreateTestMembersAndAccountsService(numNewAccounts: number) {
  const batchSize = 3; // Size of each batch

  const numNewMembers = Math.round(numNewAccounts * 0.75)
  const numNewAccountsForExisting = numNewAccounts - numNewMembers;

  const memberPromises = [];
  for (let i = 0; i < numNewMembers; i++) {
    memberPromises.push(
      (async () => {
        // Fetch a new name for each iteration
        
        // comment out when daily limit reached        
        const nameObject = await axios.get(
          "https://api.parser.name/?api_key=f30409d63186d13cfa335a40e14dcd17&endpoint=generate"
        );
        const firstname = nameObject.data.data[0].name.firstname.name_ascii;
        const lastname = nameObject.data.data[0].name.lastname.name_ascii;
        /*
        // comment out when name coming from query above
        const randomNum1 = random(100, 999);
        const randomNum2 = random(100, 999);
        const firstname = "first" + randomNum1;
        const lastname = "last" + randomNum2;
        */
        const phone = "263" + Math.floor(100000000 + Math.random() * 900000000);
        // need to check if phone unique here and generate new if not

        const onboardedMember = await OnboardMemberService(
          firstname,
          lastname,
          phone
        );
        if (!onboardedMember.onboardedMemberID) {
          throw new Error("member could not be onboarded");
        }

        const consumptionAccount = await CreateAccountService(
          onboardedMember.onboardedMemberID,
          "PERSONAL_CONSUMPTION",
          `${firstname} ${lastname} Personal`,
          `${firstname}_${lastname}`,
          "USD"
        );

        if (!consumptionAccount.accountID) {
          console.log(consumptionAccount.message);
          throw new Error("new consumption account could not be created");
        }

        return {
          onboardedMemberID: onboardedMember.onboardedMemberID,
          consumptionAccountID: consumptionAccount.accountID,
        };
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewMembers - 1) {
      await Promise.all(memberPromises);
      memberPromises.length = 0; // Clear the array for the next batch
    }
  }

  const accountPromises = [];
  for (let i = 0; i < numNewAccountsForExisting; i++) {
    accountPromises.push(
      (async () => {
        var ledgerSpaceSession = ledgerSpaceDriver.session();
        const getRandomMemberQuery = await ledgerSpaceSession.run(`
          MATCH (members:Member)
          WITH members.memberID AS memberID, rand() AS rand
          ORDER BY rand LIMIT 1
          RETURN memberID
        `);
        await ledgerSpaceSession.close();

        const ownerID = getRandomMemberQuery.records[0].get("memberID");
        const businessName = "biz" + random(100000, 999999);

        const newAccount = await CreateAccountService(
          ownerID,
          "BUSINESS",
          businessName,
          businessName,
          "USD"
        );

        if (!newAccount.accountID) {
          console.log(newAccount.message);
          throw new Error("new account could not be created");
        }
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewAccountsForExisting - 1) {
      await Promise.all(accountPromises);
      accountPromises.length = 0; // Clear the array for the next batch
    }
  }
  return true;
}



File: ./src/DevAdmin/services/CreateRandomFloatingCredexes.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { random } from "lodash";
import moment from "moment-timezone";

async function getDateAndRandCounterparties() {
  var ledgerSpaceSession = ledgerSpaceDriver.session();
  const getDateAndRandomCounterpartiesQuery = await ledgerSpaceSession.run(`
    MATCH (accounts1:Account)
    WITH accounts1, rand() AS rand1
    ORDER BY rand1
    WITH accounts1.accountID AS accountID_1 LIMIT 1
    MATCH (accounts2:Account)
    WHERE accounts2.accountID <> accountID_1
    WITH accountID_1, accounts2, rand() AS rand2
    ORDER BY rand2
    WITH accountID_1, accounts2.accountID AS accountID_2 LIMIT 1
    MATCH (daynode:Daynode{Active:true})
    RETURN daynode.Date AS date, accountID_1, accountID_2
  `);

  await ledgerSpaceSession.close();

  return {
    accountID_1:
      getDateAndRandomCounterpartiesQuery.records[0].get("accountID_1"),
    accountID_2:
      getDateAndRandomCounterpartiesQuery.records[0].get("accountID_2"),
    date: getDateAndRandomCounterpartiesQuery.records[0].get("date"),
  };
}

export async function CreateRandomFloatingCredexesService(
  numNewTransactions: number
) {
  /*
  const credexesCreated = [];
  const batchSize = 3;
  const transactionPromises = [];

  for (let i = 0; i < numNewTransactions; i++) {
    transactionPromises.push(
      (async () => {
        const dateAndCounterparties = await getDateAndRandCounterparties();
        const date = dateAndCounterparties.date;
        const issuerAccountID = dateAndCounterparties.accountID_1;
        const receiverAccountID = dateAndCounterparties.accountID_2;
        const InitialAmount = random(1, 100);
        const Denomination = InitialAmount < 80 ? "USD" : "ZIG";

        // floating credex due in 8-34 days
        const credspanDays = random(8, 34);
        const dueDate = moment(date)
          .subtract(1, "months")
          .add(credspanDays, "days")
          .format("YYYY-MM-DD");

        const credexSpecs = {
          issuerAccountID: issuerAccountID,
          receiverAccountID: receiverAccountID,
          Denomination: Denomination,
          InitialAmount: InitialAmount,
          credexType: "PURCHASE",
          dueDate: dueDate,
          securedCredex: false,
        };

        const newcredex = await OfferCredexService(credexSpecs);
        if (typeof newcredex.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
          const credexCreatedData = await AcceptCredexService(
            newcredex.credex.credexID
          );
          return credexCreatedData;
        } else {
          return newcredex.message;
        }
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewTransactions - 1) {
      const batchResults = await Promise.all(transactionPromises);
      credexesCreated.push(
        ...batchResults.filter((result) => result !== undefined)
      );
      transactionPromises.length = 0; // Clear the array for the next batch
    }
  }

  console.log(`${numNewTransactions} new floating transactions created`);
  return credexesCreated;
  */
}



File: ./src/DevAdmin/services/CreateTestLoop.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { random } from "lodash";
import moment from "moment-timezone";
import * as neo4j from "neo4j-driver";

export async function CreateTestLoopService(numNewTransactions: number) {
  /*
  var ledgerSpaceSession = ledgerSpaceDriver.session();
  const getRandomCounterpartiesQuery = await ledgerSpaceSession.run(
    `
      MATCH (account:Account)
      WITH account, rand() AS rand1
      ORDER BY rand1
      RETURN account.accountID AS accountID LIMIT $numNewTransactions
    `,
    {
      numNewTransactions: neo4j.int(numNewTransactions),
    }
  );

  const getDaynodeDate = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.Date AS today
  `);
  const today = getDaynodeDate.records[0].get("today");

  let credexesCreated = [];
  // Iterate numNewTransactions times
  for (let i = 0; i < numNewTransactions; i++) {
    const issuerAccountID =
      getRandomCounterpartiesQuery.records[i].get("accountID");

    let receiverAccountID;
    if (getRandomCounterpartiesQuery.records[i + 1]) {
      receiverAccountID =
        getRandomCounterpartiesQuery.records[i + 1].get("accountID");
    } else {
      receiverAccountID =
        getRandomCounterpartiesQuery.records[0].get("accountID");
    }

    const credexSpecs = {
      issuerAccountID: issuerAccountID,
      receiverAccountID: receiverAccountID,
      Denomination: "USD",
      InitialAmount: random(1, 100),
      credexType: "PURCHASE",
      //securedCredex: true,
      dueDate: moment(today)
        .utc()
        .add(8, "days")
        .subtract(1, "month")
        .format("YYYY-MM-DD"),
    };

    console.log(
      "Amount: " + credexSpecs.InitialAmount + " " + credexSpecs.Denomination
    );
    const newcredex = await OfferCredexService(credexSpecs);
    if (typeof newcredex.credex == "boolean") {
      throw new Error("Invalid response from OfferCredexService");
    }
    if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
      const credexCreatedData = await AcceptCredexService(
        newcredex.credex.credexID
      );
      credexesCreated.push(credexCreatedData);
    } else {
      return newcredex.message;
    }
  }
  console.log(numNewTransactions + " new transactions created");
  return credexesCreated;
  */
}



File: ./src/DevAdmin/services/ClearDevDb.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";

export async function ClearDevDbService() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();
  await ledgerSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
  await searchSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
  await ledgerSpaceSession.close();
  await searchSpaceSession.close();

  //check success first
  console.log("LedgerSpace and SearchSpace DBs cleared");
  return true;
}



File: ./src/DevAdmin/devAdminRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { ClearDevDbController } from "./controllers/clearDevDb";
import { ForceDcoController } from "./controllers/forceDCO";
import { ForceMtqController } from "./controllers/forceMTQ";
import { OfferAndAcceptCredexController } from "./controllers/offerAndAcceptCredex";
import { CreateTestMembersAndAccountsController } from "./controllers/createTestMembersAndAccounts";
import { CreateRandomFloatingCredexesController } from "./controllers/createRandomFloatingCredexes";
import { CreateTestLoopController } from "./controllers/createTestLoop";
import { GrowthTestController } from "./controllers/growthTest";
import { CheckLedgerVsSearchBalancesController } from "./controllers/checkLedgerVsSearchBalances";

export default function DevAdminRoutes(app: express.Application, jsonParser: any) {
    app.delete(
      `${apiVersionOneRoute}clearDevDB`,
      jsonParser,
      ClearDevDbController
    );

    app.post(`${apiVersionOneRoute}forceDCO`, jsonParser, ForceDcoController);
    app.post(`${apiVersionOneRoute}forceMTQ`, jsonParser, ForceMtqController);

    app.post(
      `${apiVersionOneRoute}offerAndAcceptCredex`,
      jsonParser,
      OfferAndAcceptCredexController
    );

    app.post(
      `${apiVersionOneRoute}createTestMembersAndAccounts`,
      jsonParser,
      CreateTestMembersAndAccountsController
    );

    app.post(
      `${apiVersionOneRoute}createRandomFloatingCredexes`,
      jsonParser,
      CreateRandomFloatingCredexesController
    );

    app.post(
      `${apiVersionOneRoute}createTestLoop`,
      jsonParser,
      CreateTestLoopController
    );

    app.post(
      `${apiVersionOneRoute}growthTest`,
      jsonParser,
      GrowthTestController
    );

    app.get(
      `${apiVersionOneRoute}checkLedgerVsSearchBalances`,
      jsonParser,
      CheckLedgerVsSearchBalancesController
    );
}



File: ./src/AdminDashboard/controllers/ControllerList.md
----------------------------------------
1. AccountController:
   - getReceivedCredexOffers: Handles fetching received credex offers for an account.
   
2. MemberController:
   - getMemberDetails: Retrieves details of a member using memberHandle.
   - updateMemberTier: Updates a member's tier using the memberHandle or memberID.
   - updateMemberStatus: Changes a member's suspended/active status using memberID/memberHandle.
   - logMemberInteraction: Logs interactions with members, such as support calls, emails, or chat sessions.

3. CredexController:
   - getCredexDetails: Retrieves details of a credex using the credexID.

4. AccountActivityController:
   - getAccountActivityLog: Retrieves a log of all activities related to a specific account.
   - exportAccountData: Exports all account-related data for a member.





File: ./src/AdminDashboard/controllers/MemberController.ts
----------------------------------------
import { Request, Response } from 'express';
import GetMemberService from '../services/GetMemberService';
import UpdateMemberTierService from '../services/UpdateMemberTierService';


export async function getMemberDetails(req: Request, res: Response) {
  const { memberHandle } = req.query;

  if (!memberHandle) {
    return res.status(400).json({
      message: 'The memberHandle is required'
    });
  }

  try {
    const result = await GetMemberService(memberHandle as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getMemberDetails controller:', error);
    return res.status(500).json({
      message: 'Error fetching member details',
      error: (error as Error).message 
    });
  }
}

export async function updateMemberTier(req: Request, res: Response) {
  const { memberHandle, newTier } = req.body;

  if (!memberHandle || !newTier) {
    return res.status(400).json({
      message: 'The memberHandle and newTier are required'
    });
  }

  try {
    const result = await UpdateMemberTierService(memberHandle, newTier);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in updateMemberTier controller:', error);  
    return res.status(500).json({
      message: 'Error updating member tier',
      error: (error as Error).message 
    });
  }
}

/*
export async function updateMemberStatus(req: Request, res: Response) {
  const { memberHandle, newStatus } = req.body;

  if (!memberHandle || !newStatus) {
    return res.status(400).json({
      message: 'The memberHandle and newStatus are required'
    });
  }

  try {
    const result = await UpdateMemberStatusService(memberHandle, newStatus);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in updateMemberStatus controller:', error);
    return res.status(500).json({
      message: 'Error updating member status',
      error: (error as Error).message 
    });
  }
}


export async function logMemberInteraction(req: Request, res: Response) {
  const { memberHandle, interactionType, interactionDetails } = req.body;

  if (!memberHandle || !interactionType || !interactionDetails) {
    return res.status(400).json({
      message: 'The memberHandle, interactionType, and interactionDetails are required'
    });
  }

  try {
    const result = await LogMemberInteractionService(memberHandle, interactionType, interactionDetails);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in logMemberInteraction controller:', error);
    return res.status(500).json({
      message: 'Error logging member interaction',
      error: (error as Error).message 
    });
  }
}
  */



File: ./src/AdminDashboard/controllers/CredexController.ts
----------------------------------------
import { Request, Response } from 'express';
import GetCredexService from '../services/GetCredexService';
 

export async function getCredexDetails(req: Request, res: Response) {
  console.log("getCredexDetails controller hit");
  const { credexID } = req.query;

  if (!credexID) {
    return res.status(400).json({
      message: 'The credexID is required'
    });
  }

  try {
    const result = await GetCredexService(credexID as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getCredexDetails controller:', error);
    return res.status(500).json({
      message: 'Error fetching credex details',
      error: (error as Error).message 
    });
  }
}


File: ./src/AdminDashboard/controllers/AccountController.ts
----------------------------------------
import { Request, Response } from 'express';
import GetAccountService from '../services/GetAccountService';
import GetAccountReceivedCredexOffers from '../services/GetAccountReceivedCredexOffers';
import GetAccountSentCredexOffers from '../services/GetAccountSentCredexOffers';

export async function getAccountDetails(req: Request, res: Response) {
  const { accountID, accountHandle } = req.query;

  if (!accountHandle && !accountID) {
    return res.status(400).json({
      message: 'The AccountID or accountHandle is required'
    });
  }

  try {
    const result = await GetAccountService(accountHandle as string, accountID as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getAccountDetails controller:', error);
    return res.status(500).json({
      message: 'Error fetching account details',
      error: (error as Error).message 
    });
  }
}

export async function getReceivedCredexOffers(req: Request, res: Response) {
  const {accountHandle, accountID } = req.query;

  if (!accountHandle && !accountID) {
    return res.status(400).json({
      message: 'The AccountID or accountHandle is required'
    });
  }

  try {
    const result = await GetAccountReceivedCredexOffers(accountHandle as string, accountID as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getReceivedCredexOffers controller:', error);
    return res.status(500).json({
      message: 'Error fetching received credex offers',
      error: (error as Error).message 
    });
  }
}

export async function getSentCredexOffers(req: Request, res: Response) {
  const { accountID, accountHandle } = req.query;

  if ( !accountHandle) {
    return res.status(400).json({
      message: 'The AccountID or accountHandle is required'
    });
  }

  try {
    const result = await GetAccountSentCredexOffers(accountHandle as string, accountID as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getSentCredexOffers controller:', error);
    return res.status(500).json({
      message: 'Error fetching sent credex offers',
      error: (error as Error).message 
    });
  }
}


File: ./src/AdminDashboard/middleware/requestLogger.ts
----------------------------------------



File: ./src/AdminDashboard/middleware/authMiddleware.ts
----------------------------------------
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

const secretKey = process.env.JWT_SECRET_KEY || 'your-secret-key';

export function authMiddleware(req: Request, res: Response, next: NextFunction) {
  const token = req.headers['authorization'];
  if (!token) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const decoded = jwt.verify(token, secretKey);
    (req as any).user = decoded;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}


File: ./src/AdminDashboard/middleware/errorHandler.ts
----------------------------------------



File: ./src/AdminDashboard/middleware/validateRequest.ts
----------------------------------------



File: ./src/AdminDashboard/services/GetCredexService.ts
----------------------------------------
/* 
GetCredexService:
- Retrieve details of a credex using the credexID
*/

import { ledgerSpaceDriver } from "../../../config/neo4j"

export default async function GetCredexService(credexID: string): Promise<any> {
  if(!credexID){
    return {
      message: 'CredexID is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()

  try {
    const credexResult = await ledgerSpaceSession.run(
      `MATCH (credex:Credex {credexID:$credexID})<-[:OFFERED]-(sendingAccount:Account)
        WITH credex, sendingAccount
        MATCH (credex)-[:OFFERED]-> (receivingAccount:Account)
        RETURN 
          credex.credexID AS credexID,
          credex.credexType AS credexType,
          credex.Denomination AS credexDenomination,
          credex.InitialAmount AS credexInitialAmount,
          credex.OutstandingAmount AS credexOutstandingAmount,
          credex.CXXmultiplier AS credexCXXmultiplier,
          credex.WrittenOffAmount AS credexWrittenOffAmount,
          credex.DefaultedAmount AS credexDefaultedAmount,
          credex.RedeemedAmount AS credexRedeemedAmount,
          credex.queueStatus AS credexQueueStatus,
          credex.acceptedAt AS credexAcceptedAt,
          credex.createdAt AS credexCreatedAt,
          sendingAccount.accountID AS sendingAccountID,
          sendingAccount.accountName AS sendingAccountName,
          sendingAccount.accountHandle AS sendingAccountHandle,
          sendingAccount.accountType AS sendingAccountType,
          receivingAccount.accountID AS receivingAccountID,
          receivingAccount.accountName AS receivingAccountName,
          receivingAccount.accountHandle AS receivingAccountHandle,
          receivingAccount.accountType AS receivingAccountType`,
          { credexID }
    )

    const credex = credexResult.records.map((record) => {
      return {
        credexID: record.get("credexID"),
        credexType: record.get("credexType"),
        credexDenomination: record.get("credexDenomination"),
        credexInitialAmount: record.get("credexInitialAmount"),
        credexOutstandingAmount: record.get("credexOutstandingAmount"),
        credexCXXmultiplier: record.get("credexCXXmultiplier"),
        credexWrittenOffAmount: record.get("credexWrittenOffAmount"),
        credexDefaultedAmount: record.get("credexDefaultedAmount"),
        credexRedeemedAmount: record.get("credexRedeemedAmount"),
        credexQueueStatus: record.get("credexQueueStatus"),
        credexAcceptedAt: record.get("credexAcceptedAt"),
        credexCreatedAt: record.get("credexCreatedAt"),
        sendingAccountID: record.get("sendingAccountID"), 
        sendingAccountName: record.get("sendingAccountName"),
        sendingAccountHandle: record.get("sendingAccountHandle"),
        sendingAccountType: record.get("sendingAccountType"),
        receivingAccountID: record.get("receivingAccountID"),
        receivingAccountName: record.get("receivingAccountName"),
        receivingAccountHandle: record.get("receivingAccountHandle"),
        receivingAccountType: record.get("receivingAccountType")
      }
    }); 

    if(!credex.length) {
      return {
        message: 'Credex not found'
      }
    }

    return {
      message: 'Credex retrieved successfully',
      data: {
        credex
      }
    }
  }
  catch (error) {
    console.error(error)
    return {
      message: 'Error retrieving credex',
      error: error
    }
  }
}


File: ./src/AdminDashboard/services/GetAccountService.ts
----------------------------------------
/*
  ToDo:
    - Add the accountID to the query
    
*/

/* 
 Query an account using the accountID or accountHandle to get all information associated with the account
*/

import { ledgerSpaceDriver } from "../../../config/neo4j"

export default async function GetAccount(accountHandle: string, accountID: string): Promise<any> {
  if(!accountHandle && !accountID){
    return {
      message: 'The AccountID or accountHandle is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()

  const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
  const parameters = accountHandle ? { accountHandle } : { accountID };

 try {
  const query =
  `MATCH (account:Account {${accountMatchCondition}})<-[:OWNS]-(member:Member)
    WITH account, member
    OPTIONAL MATCH (account)-[:OWES]->(owedCredex)-[:OWES]->(owedAccount)
    WITH member, account, COLLECT(owedCredex.credexID) AS owedCredexes, COLLECT(owedAccount.accountID) AS owedAccounts
    RETURN
      member.memberID AS accountOwnerID,
      member.memberHandle AS accountOwnerHandle,
      member.memberTier AS accountOwnerTier,
      account.accountID AS accountID,
      account.accountName AS accountName,
      account.accountHandle AS accountHandle,
      account.accountType AS accountType,
      account.createdAt AS accountCreatedAt,
      account.updatedAt AS accountUpdatedAt,
      COUNT(owedCredexes) AS numberOfCredexOwed,
      owedCredexes,
      owedAccounts

    `;

    const  accountResult = await ledgerSpaceSession.run(query, parameters)  

  const account = accountResult.records.map((record) => {
    return {
      accountOwnerID: record.get("accountOwnerID"),
      accountOwnerHandle: record.get("accountOwnerHandle"),
      accountOwnerTier: record.get("accountOwnerTier"),
      accountID: record.get("accountID"),
      accountName: record.get("accountName"),
      accountHandle: record.get("accountHandle"), 
      accountType: record.get("accountType"),
      accountCreatedAt: record.get("accountCreatedAt"),
      accountUpdatedAt: record.get("accountUpdatedAt"),
      numberOfCredexOwed: record.get("numberOfCredexOwed"),
      owedCredexes: record.get("owedCredexes"),
      owedAccounts: record.get("owedAccounts")
    }
  })

  if(!account.length) {
    return {
      message: 'Account not found'
    }
  }

  return {
    message: 'Account fetched successfully',
    data: account 
  }
 } catch (error) {
  return {
    message: 'Error fetching account',
    error: error
  }
 }
}


File: ./src/AdminDashboard/services/GetMemberService.ts
----------------------------------------
/*
 Query a member using memberHandle  

*/

import { ledgerSpaceDriver } from "../../../config/neo4j"


export default async function GetMemberService(memberHandle: string):Promise<any> {
  if(!memberHandle){
    return {
      message: 'The memberHandle is required'
    }
  }
  
  const ledgerSpaceSession = ledgerSpaceDriver.session()
  try {
    const result = await ledgerSpaceSession.run(
      `Match (member:Member)
          WHERE member.memberHandle = $memberHandle
          WITH member
          MATCH (member)-[:OWNS]->(account:Account)
            Return
              member.memberID AS memberID,
              member.memberHandle AS memmberHandle,
              member.firstname AS firstname,
              member.lastname AS lastname,
              member.phone AS phone, 
              member.memberTier AS memberTier,
              count(account) AS numberOfAccounts,
              member.defaultDenom AS defaultDenom,
              member.updatedAt AS updatedAt,        
              member.createdAt AS createdAt
      `,
      { memberHandle }
    );

    const records = result.records.map((record) => {
      return {
       memberID: record.get("memberID"),
       memberHandle: record.get("memmberHandle"),
       firstname: record.get("firstname"),
       lastname: record.get("lastname"),
       phone: record.get("phone"),
       memberTier: record.get("memberTier"),
       defaultDenom: record.get("defaultDenom"),
       updatedAt: record.get("updatedAt"),
       createdAt: record.get("createdAt"),
      }
    });

    if(!records.length){
      return {
        message: 'User not found',
      }
    }

    return {
      message: 'User fetched successfully',
      data: records
    }
  
  } catch (error) {
    console.error('Error fetching user:', error);
    return {
      message: 'Error fetching user',
      error: error,
    };
    
  }
  finally {
    await ledgerSpaceSession.close()
  }
}


File: ./src/AdminDashboard/services/UpdateMemberTierService.ts
----------------------------------------
/* 
Update a members tier using the memberHandle or memberID
*/
import { ledgerSpaceDriver } from "../../../config/neo4j"

export default async function UpdateMemberTierService(memberHandle: string, newTier: string): Promise<any> {
  if(!memberHandle || !newTier){
    return {
      message: 'The memberHandle and memberTier are required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()

  try {
    const result = await ledgerSpaceSession.run(
      `MATCH (member:Member {memberHandle: $memberHandle})
       SET member.memberTier = $newTier 
       RETURN member.memberID AS memberID, member.memberHandle AS memberHandle, member.memberTier AS memberTier`,
       {memberHandle, newTier}
    )

    const member = result.records.map((record) => {
      return {
        memberID: record.get("memberID"),
        memberHandle: record.get("memberHandle"),
        memberTier: record.get("memberTier")
      }
    })    

    return {
      message: 'Member tier updated successfully',
      data: member
    }
  } catch (error) {
    return {
      message: `Error updating member tier ${memberHandle}, ${newTier}`,
      error: error
    }
  } finally {
    await ledgerSpaceSession.close()
  }
}


File: ./src/AdminDashboard/services/ServicesList.md
----------------------------------------
1. GetAccountService: 
  - Retrieve details of the account
  - 
2. GetMemberAccounts:
  - Retrieve accounts owned by user
  - 
3. GetMemberService:
  - retreive details of a member using memmberID
  -
4. GetSentCredexOffers:
  - using accountID retreive sent credexOffers
  - 
5. GetReceivedCredexOffers:
  - using accountID retreive received credexOffers
  - 
6. UpdateMemberTier:
  - Using MemmberHandle update MemberTier
  -
7. UpdateMemberStatus
  - using memberID/memberHandle change members suspended/active status
  -
8. UpdateAccountStatus:
  - using accountID/accountHandle change members
  -
9. GetAccountActivityLogService:
  **Purpose:** Retrieve a log of all activities related to a specific account, useful for auditing and support inquiries.
  **Parameters**: `accountID` (required), `dateRange` (optional)
  **Response:** Returns a list of activities including timestamps, actions taken, and any associated details.
10. ExportAccountData:
  **Purpose:** Export all account-related data for a member, useful for compliance with data portability regulations.
  **Parameters:** accountID, format (optional, e.g., CSV, JSON)
  **Response:** Provides a downloadable link to the exported data.
11. LogMemberInteraction:
  **Purpose:** Allow the operations team to log interactions with members, such as support calls, emails, or chat sessions.
  **Parameters:** memberID or memberHandle, interactionType, interactionDetails (required)
  **Response:** Confirms the interaction has been logged.
12. GetAccountActivityLog:
  **Purpose:** Retrieve a log of all activities related to a specific account, useful for auditing and support inquiries.
  **Parameters:** accountID (required), dateRange (optional)
  **Response:** Returns a list of activities including timestamps, actions taken, and any associated details.


File: ./src/AdminDashboard/services/GetAccountReceivedCredexOffers.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j"

export default async function GetAccountReceivedCredexOffers( accountHandle?: string, accountID?: string): Promise<any> {
  if (!accountHandle && !accountID) {
    return {
      message: 'Either accountHandle or accountID is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()
  
  const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
  const parameters = accountHandle ? { accountHandle } : { accountID };

  try {
    const query = `
      MATCH (account:Account {${accountMatchCondition}})<-[:OFFERED]-(receivedCredexOffer)<-[:OFFERED]-(sendingAccount)
      RETURN
        receivedCredexOffer.credexID AS receivedCredexOfferID,
        receivedCredexOffer.credexType AS receivedCredexOfferType,
        receivedCredexOffer.Denomination AS receivedCredexOfferDenomination,
        receivedCredexOffer.InitialAmount AS receivedCredexOfferInitialAmount,
        receivedCredexOffer.OutstandingAmount AS receivedCredexOfferOutstandingAmount,
        receivedCredexOffer.DefaultedAmount AS receivedCredexOfferDefaultedAmount,
        receivedCredexOffer.RedeemedAmount AS receivedCredexOfferRedeemedAmount,
        receivedCredexOffer.queueStatus AS receivedCredexOfferQueueStatus,
        receivedCredexOffer.CXXmultiplier AS receivedCredexOfferCXXmultiplier,
        receivedCredexOffer.WrittenOffAmount AS receivedCredexOfferWrittenOffAmount,
        receivedCredexOffer.dueDate AS receivedCredexOfferDueDate,
        receivedCredexOffer.createdAt AS receivedCredexOfferCreatedAt,
        sendingAccount.accountID AS sendingAccountID,
        sendingAccount.defaultDenom AS sendingAccountDefaultDenom,
        sendingAccount.accountHandle AS sendingAccountHandle
    `;

    const accountReceivedCredexOffersResult = await ledgerSpaceSession.run(query, parameters);

    const accountReceivedCredexOffers = accountReceivedCredexOffersResult.records.map((record) => ({
      receivedCredexOfferID: record.get("receivedCredexOfferID"),
      receivedCredexOfferType: record.get("receivedCredexOfferType"),
      receivedCredexOfferDenomination: record.get("receivedCredexOfferDenomination"),
      receivedCredexOfferInitialAmount: record.get("receivedCredexOfferInitialAmount"),
      receivedCredexOfferOutstandingAmount: record.get("receivedCredexOfferOutstandingAmount"),
      receivedCredexOfferDefaultedAmount: record.get("receivedCredexOfferDefaultedAmount"),
      receivedCredexOfferRedeemedAmount: record.get("receivedCredexOfferRedeemedAmount"),
      receivedCredexOfferQueueStatus: record.get("receivedCredexOfferQueueStatus"),
      receivedCredexOfferCXXmultiplier: record.get("receivedCredexOfferCXXmultiplier"),
      receivedCredexOfferWrittenOffAmount: record.get("receivedCredexOfferWrittenOffAmount"),
      receivedCredexOfferDueDate: record.get("receivedCredexOfferDueDate"),
      receivedCredexOfferCreatedAt: record.get("receivedCredexOfferCreatedAt"),
      sendingAccountID: record.get("sendingAccountID"),
      sendingAccountDefaultDenom: record.get("sendingAccountDefaultDenom"),
      sendingAccountHandle: record.get("sendingAccountHandle")
    }));

    if(!accountReceivedCredexOffers.length) {
      return {
        message: 'Account received credex offers not found'
      }
    }

    return {
      message: 'Account received credex offers fetched successfully',
      data: {
        accountReceivedCredexOffers
      }
    }
  } catch (error) {
    console.error('Error fetching account received credex offers:', error);
    return {
      message: 'Error fetching account received credex offers',
      error: error
    }
  } finally {
    await ledgerSpaceSession.close()
  }
}



File: ./src/AdminDashboard/services/GetMemberAccountsOwnerByMemberSevice.ts
----------------------------------------
/* 
Query to a member to get acounts ownde by use using memberID
*/

import { ledgerSpaceDriver } from "../../../config/neo4j"


export default async function GetMemberAccountsOwnerByMemberSevice(memberID:string) {
  if(!memberID){
    return{
      message:'The memberID is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()

  try {
    const accountsOwnedByMemberResult = await ledgerSpaceSession.run(
      `MATCH (member:Member {memberID:$memberID})-[:OWNS] ->(account:Account)
        RETURN
          account.accountID AS accountID,
          account.accountHandle AS accountHandle,
          account.accountName AS accountName,
          account.defaultDenom AS defaultDenom,
          account.accountType AS accountType,
          account.queueStatus AS queueStatus,
          account.createdAt AS createdAt,
          account.updatedAt AS updatedAt
      `,{memberID}
    );
  
    const accountsOwnedByMember = accountsOwnedByMemberResult.records.map((record) => {
      return {
        accountID: record.get("accountID"),
        accountHandle: record.get("accountHandle"),
        accountName: record.get("accountName"),
        defaultDenom: record.get("defaultDenom"),
        accountType: record.get("accountType"),
        queueStatus: record.get("queueStatus"),
        createdAt: record.get("createdAt"),
        updatedAt: record.get("updatedAt")
      }
    })

    if(!accountsOwnedByMember.length) {
      return {
        message: 'Accounts owned by member not found'
      }
    }
  
    return {
      message:'Accounts owned by member fetched successfully',
      data:accountsOwnedByMember,
    }
  } catch (error) {
    console.error('Error fetching accounts owned by member:', error);
    return {
      message:'Error fetching accounts owned by member',
      error:error
    }
  } finally {
    await ledgerSpaceSession.close()
  }
}


File: ./src/AdminDashboard/services/GetAccountSentCredexOffers.ts
----------------------------------------
/*
  ToDo:
    - Add the accountID to the query
    
*/

/* 
 Query an account to get all sent credex offers
*/

import { ledgerSpaceDriver } from "../../../config/neo4j"

export default async function GetAccountService( accountHandle: string, accountID: string): Promise<any> {
  if(!accountHandle){
    return {
      message: 'The AccountID or accountHandle is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()
  // Get all outgoing credex offers from the account using the accountID or accountHandle to get the account and then get the receivingNode which can be a member or an account
  
   
  const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
  const parameters = accountHandle ? { accountHandle } : { accountID };
  
  try {
    const query = 
      `MATCH (account:Account {${accountMatchCondition}})-[:OFFERED]->(offeredCredex)-[:OFFERED]->(receivingAccount) 
        RETURN
        offeredCredex.credexID AS offeredCredexID,
        offeredCredex.credexType AS offeredCredexType,
        offeredCredex.Denomination AS offeredCredexDenomination,
        offeredCredex.InitialAmount AS offeredCredexInitialAmount,
        offeredCredex.OutstandingAmount AS offeredCredexOutstandingAmount,
        offeredCredex.DefaultedAmount AS offeredCredexDefaultedAmount,
        offeredCredex.RedeemedAmount AS offeredCredexRedeemedAmount,
        offeredCredex.queueStatus AS offeredCredexQueueStatus,
        offeredCredex.CXXmultiplier AS offeredCredexCXXmultiplier,
        offeredCredex.WrittenOffAmount AS offeredCredexWrittenOffAmount,
        offeredCredex.dueDate AS offeredCredexDueDate,
        offeredCredex.createdAt AS offeredCredexCreatedAt,
        receivingAccount.accountID AS receivingAccountID,
        receivingAccount.defaultDenom AS receivingAccountDefaultDenom,
        receivingAccount.accountHandle AS receivingAccountHandle

      `;
      const accountOfferedCredexResult = await ledgerSpaceSession.run(query, parameters)
    
   const accountOfferedCredex = accountOfferedCredexResult.records.map((record) => {
    return {
     offeredCredexID: record.get("offeredCredexID"),
     offeredCredexType: record.get("offeredCredexType"),
     offeredCredexDenomination: record.get("offeredCredexDenomination"),
     offeredCredexInitialAmount: record.get("offeredCredexInitialAmount"),
     offeredCredexOutstandingAmount: record.get("offeredCredexOutstandingAmount"),
     offeredCredexDefaultedAmount: record.get("offeredCredexDefaultedAmount"),
     offeredCredexRedeemedAmount: record.get("offeredCredexRedeemedAmount"),
     offeredCredexQueueStatus: record.get("offeredCredexQueueStatus"),
     offeredCredexCXXmultiplier: record.get("offeredCredexCXXmultiplier"),
     offeredCredexWrittenOffAmount: record.get("offeredCredexWrittenOffAmount"),
     offeredCredexDueDate: record.get("offeredCredexDueDate"),
     offeredCredexCreatedAt: record.get("offeredCredexCreatedAt"),
     receivingAccountID: record.get("receivingAccountID"),
     receivingAccountDefaultDenom: record.get("receivingAccountDefaultDenom"),
     receivingAccountHandle: record.get("receivingAccountHandle"),
    }
   });

   if(!accountOfferedCredex.length) {
    return {
      message: 'Account sent credex offers not found'
    }
   }
  

    return {
      message: 'Account credex offers fetched successfully',
      data: {
        accountOfferedCredex,
      }
    }

  } catch (error) {
    console.error('Error fetching account:', error);
    return {
      message: 'Error fetching account',
      error: error,
    };
  } finally {
    await ledgerSpaceSession.close();
  }
}


File: ./src/AdminDashboard/adminDashboardRoutes.ts
----------------------------------------
import express from "express"
import { apiVersionOneRoute } from ".."
import { authMiddleware } from "./middleware/authMiddleware";
import { getCredexDetails } from "./controllers/CredexController";
import { getMemberDetails, updateMemberTier } from "./controllers/MemberController";
import { getAccountDetails, getReceivedCredexOffers, getSentCredexOffers } from "./controllers/AccountController";
/*
function logRoute(req: express.Request, res: express.Response, next: express.NextFunction) {
  console.log("getCredexDetails route hit");
  next();
}
*/


export default function AdminDashboardRoutes(app: express.Application, jsonParser:any){
  app.get(`${apiVersionOneRoute}getCredexDetails`,
    //logRoute,
    jsonParser,     
    getCredexDetails
  );

  app.get(`${apiVersionOneRoute}getMemberDetails`,
    jsonParser,      
    getMemberDetails
  );

  
  app.patch(`${apiVersionOneRoute}updateMemberTier`,
    jsonParser,    
    updateMemberTier
  );

  app.get(`${apiVersionOneRoute}getAccountDetails`,
    jsonParser,     
    getAccountDetails
  );

  app.get(`${apiVersionOneRoute}getReceivedCredexOffers`,
    jsonParser,      
    getReceivedCredexOffers
  );

  app.get(`${apiVersionOneRoute}getSentCredexOffers`,
    jsonParser,    
    getSentCredexOffers
  );

  /*
  app.get(`${apiVersionOneRoute}getAccountActivityLog`,
    jsonParser, 
    authMiddleware, 
    getAccountActivityLog
  );
  */

  /*
  app.put(`${apiVersionOneRoute}updateMemberStatus`,
    jsonParser, 
    authMiddleware, 
    updateMemberStatus
  );
  */
}


File: ./update_combined_code.sh
----------------------------------------
#!/bin/bash

# Define the output file
output_file="combined_code.txt"

# Get the current branch name
current_branch=$(git rev-parse --abbrev-ref HEAD)

# Clear the existing content of the output file
> "$output_file"

# Add the current branch information
echo "Current Branch: $current_branch" >> "$output_file"
echo "----------------------------------------" >> "$output_file"

# Find all files with extensions .ts, .js, .json, .yaml, .yml, .md, and .sh
# Exclude node_modules directory and .git directory
find . -type f \( -name "*.ts" -o -name "*.js" -o -name "*.json" -o -name "*.yaml" -o -name "*.yml" -o -name "*.md" -o -name "*.sh" \) -not -path "*/node_modules/*" -not -path "*/.git/*" | while read -r file; do
    echo "File: $file" >> "$output_file"
    echo "----------------------------------------" >> "$output_file"
    cat "$file" >> "$output_file"
    echo -e "\n\n" >> "$output_file"
done

echo "Combined code file updated: $output_file for branch: $current_branch"


File: ./package-lock.json
----------------------------------------
{
  "name": "credex-core-express",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "credex-core-express",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "@types/cors": "^2.8.17",
        "@types/jsonwebtoken": "^9.0.6",
        "axios": "^1.6.8",
        "bcrypt": "^5.1.1",
        "body-parser": "^1.20.2",
        "cheerio": "^1.0.0-rc.12",
        "cors": "^2.8.5",
        "dotenv": "^16.4.5",
        "express": "^4.19.2",
        "express-rate-limit": "^7.4.0",
        "helmet": "^7.1.0",
        "jsonwebtoken": "^9.0.2",
        "lodash": "^4.17.21",
        "moment-timezone": "^0.5.45",
        "neo4j-driver": "^5.20.0",
        "node-cron": "^3.0.3",
        "swagger-jsdoc": "^6.2.8",
        "swagger-ui-express": "^5.0.1",
        "uuid": "^10.0.0",
        "winston": "^3.14.2",
        "winston-daily-rotate-file": "^5.0.0"
      },
      "devDependencies": {
        "@types/body-parser": "^1.19.5",
        "@types/express": "^4.17.21",
        "@types/lodash": "^4.17.1",
        "@types/node-cron": "^3.0.11",
        "@types/swagger-jsdoc": "^6.0.4",
        "@types/swagger-ui-express": "^4.1.6",
        "@types/uuid": "^10.0.0",
        "@types/winston": "^2.4.4",
        "ts-node": "^10.9.2",
        "typescript": "^5.4.5"
      }
    },
    "node_modules/@apidevtools/json-schema-ref-parser": {
      "version": "9.1.2",
      "resolved": "https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-9.1.2.tgz",
      "integrity": "sha512-r1w81DpR+KyRWd3f+rk6TNqMgedmAxZP5v5KWlXQWlgMUUtyEJch0DKEci1SorPMiSeM8XPl7MZ3miJ60JIpQg==",
      "dependencies": {
        "@jsdevtools/ono": "^7.1.3",
        "@types/json-schema": "^7.0.6",
        "call-me-maybe": "^1.0.1",
        "js-yaml": "^4.1.0"
      }
    },
    "node_modules/@apidevtools/openapi-schemas": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@apidevtools/openapi-schemas/-/openapi-schemas-2.1.0.tgz",
      "integrity": "sha512-Zc1AlqrJlX3SlpupFGpiLi2EbteyP7fXmUOGup6/DnkRgjP9bgMM/ag+n91rsv0U1Gpz0H3VILA/o3bW7Ua6BQ==",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@apidevtools/swagger-methods": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@apidevtools/swagger-methods/-/swagger-methods-3.0.2.tgz",
      "integrity": "sha512-QAkD5kK2b1WfjDS/UQn/qQkbwF31uqRjPTrsCs5ZG9BQGAkjwvqGFjjPqAuzac/IYzpPtRzjCP1WrTuAIjMrXg=="
    },
    "node_modules/@apidevtools/swagger-parser": {
      "version": "10.0.3",
      "resolved": "https://registry.npmjs.org/@apidevtools/swagger-parser/-/swagger-parser-10.0.3.tgz",
      "integrity": "sha512-sNiLY51vZOmSPFZA5TF35KZ2HbgYklQnTSDnkghamzLb3EkNtcQnrBQEj5AOCxHpTtXpqMCRM1CrmV2rG6nw4g==",
      "dependencies": {
        "@apidevtools/json-schema-ref-parser": "^9.0.6",
        "@apidevtools/openapi-schemas": "^2.0.4",
        "@apidevtools/swagger-methods": "^3.0.2",
        "@jsdevtools/ono": "^7.1.3",
        "call-me-maybe": "^1.0.1",
        "z-schema": "^5.0.1"
      },
      "peerDependencies": {
        "openapi-types": ">=7"
      }
    },
    "node_modules/@colors/colors": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/@colors/colors/-/colors-1.6.0.tgz",
      "integrity": "sha512-Ir+AOibqzrIsL6ajt3Rz3LskB7OiMVHqltZmspbW/TJuTVuyOMirVqAkjfY6JISiLHgyNqicAC8AyHHGzNd/dA==",
      "engines": {
        "node": ">=0.1.90"
      }
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@dabh/diagnostics": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@dabh/diagnostics/-/diagnostics-2.0.3.tgz",
      "integrity": "sha512-hrlQOIi7hAfzsMqlGSFyVucrx38O+j6wiGOf//H2ecvIEqYN4ADBSS2iLMh5UFyDunCNniUIPk/q3riFv45xRA==",
      "dependencies": {
        "colorspace": "1.1.x",
        "enabled": "2.0.x",
        "kuler": "^2.0.0"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz",
      "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==",
      "dev": true
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@jsdevtools/ono": {
      "version": "7.1.3",
      "resolved": "https://registry.npmjs.org/@jsdevtools/ono/-/ono-7.1.3.tgz",
      "integrity": "sha512-4JQNk+3mVzK3xh2rqd6RB4J46qUR19azEHBneZyTZM+c456qOrbbM/5xcR8huNCCcbVt7+UmizG6GuUvPvKUYg=="
    },
    "node_modules/@mapbox/node-pre-gyp": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@mapbox/node-pre-gyp/-/node-pre-gyp-1.0.11.tgz",
      "integrity": "sha512-Yhlar6v9WQgUp/He7BdgzOz8lqMQ8sU+jkCq7Wx8Myc5YFJLbEe7lgui/V7G1qB1DJykHSGwreceSaD60Y0PUQ==",
      "dependencies": {
        "detect-libc": "^2.0.0",
        "https-proxy-agent": "^5.0.0",
        "make-dir": "^3.1.0",
        "node-fetch": "^2.6.7",
        "nopt": "^5.0.0",
        "npmlog": "^5.0.1",
        "rimraf": "^3.0.2",
        "semver": "^7.3.5",
        "tar": "^6.1.11"
      },
      "bin": {
        "node-pre-gyp": "bin/node-pre-gyp"
      }
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.11.tgz",
      "integrity": "sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==",
      "dev": true
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.4.tgz",
      "integrity": "sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==",
      "dev": true
    },
    "node_modules/@types/body-parser": {
      "version": "1.19.5",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz",
      "integrity": "sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==",
      "dev": true,
      "dependencies": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/connect": {
      "version": "3.4.38",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
      "dev": true,
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/cors": {
      "version": "2.8.17",
      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.17.tgz",
      "integrity": "sha512-8CGDvrBj1zgo2qE+oS3pOCyYNqCPryMWY2bGfwA0dcfopWGgxs+78df0Rs3rc9THP4JkOhLsAa+15VdpAqkcUA==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/express": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.21.tgz",
      "integrity": "sha512-ejlPM315qwLpaQlQDTjPdsUFSc6ZsP4AN6AlWnogPjQ7CVi7PYF3YVz+CY3jE2pwYf7E/7HlDAN0rV2GxTG0HQ==",
      "dev": true,
      "dependencies": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^4.17.33",
        "@types/qs": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "4.19.5",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.19.5.tgz",
      "integrity": "sha512-y6W03tvrACO72aijJ5uF02FRq5cgDR9lUxddQ8vyF+GvmjJQqbzDcJngEjURc+ZsG31VI3hODNZJ2URj86pzmg==",
      "dev": true,
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/http-errors": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz",
      "integrity": "sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==",
      "dev": true
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA=="
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.6",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.6.tgz",
      "integrity": "sha512-/5hndP5dCjloafCXns6SZyESp3Ldq7YjH3zwzwczYnjxIT0Fqzk5ROSYVGfFyczIue7IUEj8hkvLbPoLQ18vQw==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/lodash": {
      "version": "4.17.7",
      "resolved": "https://registry.npmjs.org/@types/lodash/-/lodash-4.17.7.tgz",
      "integrity": "sha512-8wTvZawATi/lsmNu10/j2hk1KEP0IvjubqPE3cu1Xz7xfXXt5oCq3SNUz4fMIP4XGF9Ky+Ue2tBA3hcS7LSBlA==",
      "dev": true
    },
    "node_modules/@types/mime": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
      "dev": true
    },
    "node_modules/@types/node": {
      "version": "22.5.2",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.5.2.tgz",
      "integrity": "sha512-acJsPTEqYqulZS/Yp/S3GgeE6GZ0qYODUR8aVr/DkhHQ8l9nd4j5x1/ZJy9/gHrRlFMqkO6i0I3E27Alu4jjPg==",
      "dependencies": {
        "undici-types": "~6.19.2"
      }
    },
    "node_modules/@types/node-cron": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@types/node-cron/-/node-cron-3.0.11.tgz",
      "integrity": "sha512-0ikrnug3/IyneSHqCBeslAhlK2aBfYek1fGo4bP4QnZPmiqSGRK+Oy7ZMisLWkesffJvQ1cqAcBnJC+8+nxIAg==",
      "dev": true
    },
    "node_modules/@types/qs": {
      "version": "6.9.15",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.15.tgz",
      "integrity": "sha512-uXHQKES6DQKKCLh441Xv/dwxOq1TVS3JPUMlEqoEglvlhR6Mxnlew/Xq/LRVHpLyk7iK3zODe1qYHIMltO7XGg==",
      "dev": true
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
      "dev": true
    },
    "node_modules/@types/send": {
      "version": "0.17.4",
      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz",
      "integrity": "sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==",
      "dev": true,
      "dependencies": {
        "@types/mime": "^1",
        "@types/node": "*"
      }
    },
    "node_modules/@types/serve-static": {
      "version": "1.15.7",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz",
      "integrity": "sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==",
      "dev": true,
      "dependencies": {
        "@types/http-errors": "*",
        "@types/node": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/swagger-jsdoc": {
      "version": "6.0.4",
      "resolved": "https://registry.npmjs.org/@types/swagger-jsdoc/-/swagger-jsdoc-6.0.4.tgz",
      "integrity": "sha512-W+Xw5epcOZrF/AooUM/PccNMSAFOKWZA5dasNyMujTwsBkU74njSJBpvCCJhHAJ95XRMzQrrW844Btu0uoetwQ==",
      "dev": true
    },
    "node_modules/@types/swagger-ui-express": {
      "version": "4.1.6",
      "resolved": "https://registry.npmjs.org/@types/swagger-ui-express/-/swagger-ui-express-4.1.6.tgz",
      "integrity": "sha512-UVSiGYXa5IzdJJG3hrc86e8KdZWLYxyEsVoUI4iPXc7CO4VZ3AfNP8d/8+hrDRIqz+HAaSMtZSqAsF3Nq2X/Dg==",
      "dev": true,
      "dependencies": {
        "@types/express": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/triple-beam": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/@types/triple-beam/-/triple-beam-1.3.5.tgz",
      "integrity": "sha512-6WaYesThRMCl19iryMYP7/x2OVgCtbIVflDGFpWnb9irXI3UjYE4AzmYuiUKY1AJstGijoY+MgUszMgRxIYTYw=="
    },
    "node_modules/@types/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/@types/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-7gqG38EyHgyP1S+7+xomFtL+ZNHcKv6DwNaCZmJmo1vgMugyF3TCnXVg4t1uk89mLNwnLtnY3TpOpCOyp1/xHQ==",
      "dev": true
    },
    "node_modules/@types/winston": {
      "version": "2.4.4",
      "resolved": "https://registry.npmjs.org/@types/winston/-/winston-2.4.4.tgz",
      "integrity": "sha512-BVGCztsypW8EYwJ+Hq+QNYiT/MUyCif0ouBH+flrY66O5W+KIXAMML6E/0fJpm7VjIzgangahl5S03bJJQGrZw==",
      "deprecated": "This is a stub types definition. winston provides its own type definitions, so you do not need this installed.",
      "dev": true,
      "dependencies": {
        "winston": "*"
      }
    },
    "node_modules/abbrev": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz",
      "integrity": "sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q=="
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/acorn": {
      "version": "8.12.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.12.1.tgz",
      "integrity": "sha512-tcpGyI9zbizT9JbV6oYE477V6mTlXvvi0T0G3SNIYE2apm/G5huBa1+K89VGeovbg+jycCrfhl3ADxErOuO6Jg==",
      "dev": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.3.3",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.3.tgz",
      "integrity": "sha512-MxXdReSRhGO7VlFe1bRG/oI7/mdLV9B9JJT0N8vZOhF7gFRR5l3M8W9G8JxmKV+JC5mGqJ0QvqfSOLsCPa4nUw==",
      "dev": true,
      "dependencies": {
        "acorn": "^8.11.0"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/agent-base": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-6.0.2.tgz",
      "integrity": "sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==",
      "dependencies": {
        "debug": "4"
      },
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/agent-base/node_modules/debug": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.6.tgz",
      "integrity": "sha512-O/09Bd4Z1fBrU4VzkhFqVgpPzaGbw6Sm9FEkBT1A/YBXQFGuuSxa1dN2nxgxS34JmKXqYx8CZAwEVoJFImUXIg==",
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/agent-base/node_modules/ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/aproba": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/aproba/-/aproba-2.0.0.tgz",
      "integrity": "sha512-lYe4Gx7QT+MKGbDsA+Z+he/Wtef0BiwDOlK/XkBrdfsh9J/jPPXbX0tE9x9cl27Tmu5gg3QUbUrQYa/y+KOHPQ=="
    },
    "node_modules/are-we-there-yet": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/are-we-there-yet/-/are-we-there-yet-2.0.0.tgz",
      "integrity": "sha512-Ci/qENmwHnsYo9xKIcUJN5LeDKdJ6R1Z1j9V/J5wyq8nh/mYPEpIKJbBZXtZjG04HiK7zV/p6Vs9952MrMeUIw==",
      "deprecated": "This package is no longer supported.",
      "dependencies": {
        "delegates": "^1.0.0",
        "readable-stream": "^3.6.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q=="
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg=="
    },
    "node_modules/async": {
      "version": "3.2.6",
      "resolved": "https://registry.npmjs.org/async/-/async-3.2.6.tgz",
      "integrity": "sha512-htCUDlxyyCLMgaM3xXg0C0LW2xqfuQ6p05pCEIsXuyQ+a1koYKTuBMzRNwmybfLgvJDMd0r1LTn4+E0Ti6C2AA=="
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "node_modules/axios": {
      "version": "1.7.7",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.7.7.tgz",
      "integrity": "sha512-S4kL7XrjgBmvdGut0sN3yJxqYzrDOnivkBiN0OFs6hLiUam3UPvswUo0kqGyhqUZGEOytHyumEdXsAkgCOUf3Q==",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.0",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw=="
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/bcrypt": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/bcrypt/-/bcrypt-5.1.1.tgz",
      "integrity": "sha512-AGBHOG5hPYZ5Xl9KXzU5iKq9516yEmvCKDg3ecP5kX2aB6UqTeXZxk2ELnDgDm6BQSMlLt9rDB4LoSMx0rYwww==",
      "hasInstallScript": true,
      "dependencies": {
        "@mapbox/node-pre-gyp": "^1.0.11",
        "node-addon-api": "^5.0.0"
      },
      "engines": {
        "node": ">= 10.0.0"
      }
    },
    "node_modules/body-parser": {
      "version": "1.20.2",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.2.tgz",
      "integrity": "sha512-ml9pReCu3M61kGlqoTm2umSXTlRTuGTx0bfYj+uIUKKYycG5NtSbeetV3faSU6R7ajOPw0g/J1PvK4qNy7s5bA==",
      "dependencies": {
        "bytes": "3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "on-finished": "2.4.1",
        "qs": "6.11.0",
        "raw-body": "2.5.2",
        "type-is": "~1.6.18",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/boolbase": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/boolbase/-/boolbase-1.0.0.tgz",
      "integrity": "sha512-JZOSA7Mo9sNGB8+UjSgzdLtokWAky1zbztM3WRLCbZ70/3cTANmQmOdR7y2g+J0e2WXywy1yS468tY+IruqEww=="
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/buffer": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz",
      "integrity": "sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.2.1"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA=="
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.7.tgz",
      "integrity": "sha512-GHTSNSYICQ7scH7sZ+M2rFopRoLh8t2bLSW6BbgrtLsahOIB5iyAVJf9GjWK3cYTDaMj4XdBpM1cA6pIS0Kv2w==",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "set-function-length": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/call-me-maybe": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-me-maybe/-/call-me-maybe-1.0.2.tgz",
      "integrity": "sha512-HpX65o1Hnr9HH25ojC1YGs7HCQLq0GCOibSaWER0eNpgJ/Z1MZv2mTc7+xh6WOPxbRVcmgbv4hGU+uSQ/2xFZQ=="
    },
    "node_modules/cheerio": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/cheerio/-/cheerio-1.0.0.tgz",
      "integrity": "sha512-quS9HgjQpdaXOvsZz82Oz7uxtXiy6UIsIQcpBj7HRw2M63Skasm9qlDocAM7jNuaxdhpPU7c4kJN+gA5MCu4ww==",
      "dependencies": {
        "cheerio-select": "^2.1.0",
        "dom-serializer": "^2.0.0",
        "domhandler": "^5.0.3",
        "domutils": "^3.1.0",
        "encoding-sniffer": "^0.2.0",
        "htmlparser2": "^9.1.0",
        "parse5": "^7.1.2",
        "parse5-htmlparser2-tree-adapter": "^7.0.0",
        "parse5-parser-stream": "^7.1.2",
        "undici": "^6.19.5",
        "whatwg-mimetype": "^4.0.0"
      },
      "engines": {
        "node": ">=18.17"
      },
      "funding": {
        "url": "https://github.com/cheeriojs/cheerio?sponsor=1"
      }
    },
    "node_modules/cheerio-select": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/cheerio-select/-/cheerio-select-2.1.0.tgz",
      "integrity": "sha512-9v9kG0LvzrlcungtnJtpGNxY+fzECQKhK4EGJX2vByejiMX84MFNQw4UxPJl3bFbTMw+Dfs37XaIkCwTZfLh4g==",
      "dependencies": {
        "boolbase": "^1.0.0",
        "css-select": "^5.1.0",
        "css-what": "^6.1.0",
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.3",
        "domutils": "^3.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/chownr": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
      "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/color": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/color/-/color-3.2.1.tgz",
      "integrity": "sha512-aBl7dZI9ENN6fUGC7mWpMTPNHmWUSNan9tuWN6ahh5ZLNk9baLJOnSMlrQkHcrfFgz2/RigjUVAjdx36VcemKA==",
      "dependencies": {
        "color-convert": "^1.9.3",
        "color-string": "^1.6.0"
      }
    },
    "node_modules/color-convert": {
      "version": "1.9.3",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
      "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
      "dependencies": {
        "color-name": "1.1.3"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
      "integrity": "sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw=="
    },
    "node_modules/color-string": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/color-string/-/color-string-1.9.1.tgz",
      "integrity": "sha512-shrVawQFojnZv6xM40anx4CkoDP+fZsw/ZerEMsW/pyzsRbElpsL/DBVW7q3ExxwusdNXI3lXpuhEZkzs8p5Eg==",
      "dependencies": {
        "color-name": "^1.0.0",
        "simple-swizzle": "^0.2.2"
      }
    },
    "node_modules/color-support": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/color-support/-/color-support-1.1.3.tgz",
      "integrity": "sha512-qiBjkpbMLO/HL68y+lh4q0/O1MZFj2RX6X/KmMa3+gJD3z+WwI1ZzDHysvqHGS3mP6mznPckpXmw1nI9cJjyRg==",
      "bin": {
        "color-support": "bin.js"
      }
    },
    "node_modules/colorspace": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/colorspace/-/colorspace-1.1.4.tgz",
      "integrity": "sha512-BgvKJiuVu1igBUF2kEjRCZXol6wiiGbY5ipL/oVPwm0BL9sIpMIzM8IK7vwuxIIzOXMV3Ey5w+vxhm0rR/TN8w==",
      "dependencies": {
        "color": "^3.1.3",
        "text-hex": "1.0.x"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/commander": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-6.2.0.tgz",
      "integrity": "sha512-zP4jEKbe8SHzKJYQmq8Y9gYjtO/POJLgIdKgV7B9qNmABVFVc+ctqSX6iXh4mCpJfRBOabiZ2YKPg8ciDw6C+Q==",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg=="
    },
    "node_modules/console-control-strings": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/console-control-strings/-/console-control-strings-1.1.0.tgz",
      "integrity": "sha512-ty/fTekppD2fIwRvnZAVdeOiGd1c7YXEixbgJTNzqcxJWKQnjJ/V1bNEEE6hygpM3WjwHFUVK6HTjWSzV4a8sQ=="
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.6.0.tgz",
      "integrity": "sha512-U71cyTamuh1CRNCfpGY6to28lxvNwPG4Guz/EVjgf3Jmzv0vlDp1atT9eS5dDjMYHucpHbWns6Lwf3BKz6svdw==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ=="
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true
    },
    "node_modules/css-select": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/css-select/-/css-select-5.1.0.tgz",
      "integrity": "sha512-nwoRF1rvRRnnCqqY7updORDsuqKzqYJ28+oSMaJMMgOauh3fvwHqMS7EZpIPqK8GL+g9mKxF1vP/ZjSeNjEVHg==",
      "dependencies": {
        "boolbase": "^1.0.0",
        "css-what": "^6.1.0",
        "domhandler": "^5.0.2",
        "domutils": "^3.0.1",
        "nth-check": "^2.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/css-what": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/css-what/-/css-what-6.1.0.tgz",
      "integrity": "sha512-HTUrgRJ7r4dsZKU6GjmpfRK1O76h97Z8MfS1G0FozR+oF2kG6Vfe8JE6zwrkbxigziPHinCJ+gCPjA9EaBDtRw==",
      "engines": {
        "node": ">= 6"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/define-data-property": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/define-data-property/-/define-data-property-1.1.4.tgz",
      "integrity": "sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/delegates": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delegates/-/delegates-1.0.0.tgz",
      "integrity": "sha512-bd2L678uiWATM6m5Z1VzNCErI3jiGzt6HGY8OVICs40JQq/HALfbyNJmp0UDakEY4pMMaN0Ly5om/B1VI/+xfQ=="
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.0.3.tgz",
      "integrity": "sha512-bwy0MGW55bG41VqxxypOsdSdGqLwXPI/focwgTYCFMbdUiBAxLg9CFzG08sz2aqzknwiX7Hkl0bQENjg8iLByw==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/dom-serializer": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/dom-serializer/-/dom-serializer-2.0.0.tgz",
      "integrity": "sha512-wIkAryiqt/nV5EQKqQpo3SToSOV9J0DnbJqwK7Wv/Trc92zIAYZ4FlMu+JPFW1DfGFt81ZTCGgDEabffXeLyJg==",
      "dependencies": {
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.2",
        "entities": "^4.2.0"
      },
      "funding": {
        "url": "https://github.com/cheeriojs/dom-serializer?sponsor=1"
      }
    },
    "node_modules/domelementtype": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/domelementtype/-/domelementtype-2.3.0.tgz",
      "integrity": "sha512-OLETBj6w0OsagBwdXnPdN0cnMfF9opN69co+7ZrbfPGrdpPVNBUj02spi6B1N7wChLQiPn4CSH/zJvXw56gmHw==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/fb55"
        }
      ]
    },
    "node_modules/domhandler": {
      "version": "5.0.3",
      "resolved": "https://registry.npmjs.org/domhandler/-/domhandler-5.0.3.tgz",
      "integrity": "sha512-cgwlv/1iFQiFnU96XXgROh8xTeetsnJiDsTc7TYCLFd9+/WNkIqPTxiM/8pSd8VIrhXGTf1Ny1q1hquVqDJB5w==",
      "dependencies": {
        "domelementtype": "^2.3.0"
      },
      "engines": {
        "node": ">= 4"
      },
      "funding": {
        "url": "https://github.com/fb55/domhandler?sponsor=1"
      }
    },
    "node_modules/domutils": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/domutils/-/domutils-3.1.0.tgz",
      "integrity": "sha512-H78uMmQtI2AhgDJjWeQmHwJJ2bLPD3GMmO7Zja/ZZh84wkm+4ut+IUnUdRa8uCGX88DiVx1j6FRe1XfxEgjEZA==",
      "dependencies": {
        "dom-serializer": "^2.0.0",
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.3"
      },
      "funding": {
        "url": "https://github.com/fb55/domutils?sponsor=1"
      }
    },
    "node_modules/dotenv": {
      "version": "16.4.5",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-16.4.5.tgz",
      "integrity": "sha512-ZmdL2rui+eB2YwhsWzjInR8LldtZHGDoQ1ugH85ppHKwpUHL7j7rN0Ti9NCnGiQbhaZ11FpR+7ao1dNsmduNUg==",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow=="
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A=="
    },
    "node_modules/enabled": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/enabled/-/enabled-2.0.0.tgz",
      "integrity": "sha512-AKrN98kuwOzMIdAizXGI86UFBoo26CL21UM763y1h/GMSJ4/OHU9k2YlsmBpyScFo/wbLzWQJBMCW4+IO3/+OQ=="
    },
    "node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/encoding-sniffer": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/encoding-sniffer/-/encoding-sniffer-0.2.0.tgz",
      "integrity": "sha512-ju7Wq1kg04I3HtiYIOrUrdfdDvkyO9s5XM8QAj/bN61Yo/Vb4vgJxy5vi4Yxk01gWHbrofpPtpxM8bKger9jhg==",
      "dependencies": {
        "iconv-lite": "^0.6.3",
        "whatwg-encoding": "^3.1.1"
      },
      "funding": {
        "url": "https://github.com/fb55/encoding-sniffer?sponsor=1"
      }
    },
    "node_modules/encoding-sniffer/node_modules/iconv-lite": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
      "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/entities": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/entities/-/entities-4.5.0.tgz",
      "integrity": "sha512-V0hjH4dGPh9Ao5p0MoRY6BVqtwCjhz6vI5LT8AJ55H+4g9/4vbHx1I54fS0XuclLhDHArPQCiMjDxjaL8fPxhw==",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.0.tgz",
      "integrity": "sha512-jxayLKShrEqqzJ0eumQbVhTYQM27CfT1T35+gCgDFoL82JLsXqTJ76zv6A0YLOgEnLUMvLzsDsGIrl8NFpT2gQ==",
      "dependencies": {
        "get-intrinsic": "^1.2.4"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow=="
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "4.19.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.19.2.tgz",
      "integrity": "sha512-5T6nhjsT+EOMzuck8JjBHARTHfMht0POzlA60WV2pMD3gyXw2LZnZ+ueGdNxG+0calOJcWKbpFcuzLZ91YWq9Q==",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "1.20.2",
        "content-disposition": "0.5.4",
        "content-type": "~1.0.4",
        "cookie": "0.6.0",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.2.0",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "merge-descriptors": "1.0.1",
        "methods": "~1.1.2",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.7",
        "proxy-addr": "~2.0.7",
        "qs": "6.11.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "0.18.0",
        "serve-static": "1.15.0",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      }
    },
    "node_modules/express-rate-limit": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-7.4.0.tgz",
      "integrity": "sha512-v1204w3cXu5gCDmAvgvzI6qjzZzoMWKnyVDk3ACgfswTQLYiGen+r8w0VnXnGMmzEN/g8fwIQ4JrFFd4ZP6ssg==",
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "url": "https://github.com/sponsors/express-rate-limit"
      },
      "peerDependencies": {
        "express": "4 || 5 || ^5.0.0-beta.1"
      }
    },
    "node_modules/fecha": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/fecha/-/fecha-4.2.3.tgz",
      "integrity": "sha512-OP2IUU6HeYKJi3i0z4A19kHMQoLVs4Hc+DPqqxI2h/DPZHTm/vjsfC6P0b4jCMy14XizLBqvndQ+UilD7707Jw=="
    },
    "node_modules/file-stream-rotator": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/file-stream-rotator/-/file-stream-rotator-0.6.1.tgz",
      "integrity": "sha512-u+dBid4PvZw17PmDeRcNOtCP9CCK/9lRN2w+r1xIS7yOL9JFrIBKTvrYsxT4P0pGtThYTn++QS5ChHaUov3+zQ==",
      "dependencies": {
        "moment": "^2.29.1"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.2.0.tgz",
      "integrity": "sha512-5uXcUVftlQMFnWC9qu/svkWv3GTd2PfUhK/3PLkYNAe7FbqJMt3515HaxE6eRL74GdsriiwujiawdaB1BpEISg==",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "2.0.1",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/fn.name": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/fn.name/-/fn.name-1.1.0.tgz",
      "integrity": "sha512-GRnmB5gPyJpAhTQdSZTSp9uaPSvl09KoYcMQtsB9rQoOmzs9dH6ffeccH+Z+cv6P68Hu5bC6JjRh4Ah/mHSNRw=="
    },
    "node_modules/follow-redirects": {
      "version": "1.15.6",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.6.tgz",
      "integrity": "sha512-wWN62YITEaOpSK584EZXJafH1AGpO8RVgElfkuXbTOrPX4fIfOyEpW/CsiNd8JdYrAoOvafRTOEnvsO++qCqFA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.0.tgz",
      "integrity": "sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fs-minipass": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-2.1.0.tgz",
      "integrity": "sha512-V/JgOLFCS+R6Vcq0slCuaeWEdNC3ouDlJMNIsacH2VtALiu9mV4LPrHc5cDl8k5aw6J8jwgWWpiTo5RYhmIzvg==",
      "dependencies": {
        "minipass": "^3.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/fs-minipass/node_modules/minipass": {
      "version": "3.3.6",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.3.6.tgz",
      "integrity": "sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw=="
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gauge": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/gauge/-/gauge-3.0.2.tgz",
      "integrity": "sha512-+5J6MS/5XksCuXq++uFRsnUd7Ovu1XenbeuIuNRJxYWjgQbPuFhT14lAvsWfqfAmnwluf1OwMjz39HjfLPci0Q==",
      "deprecated": "This package is no longer supported.",
      "dependencies": {
        "aproba": "^1.0.3 || ^2.0.0",
        "color-support": "^1.1.2",
        "console-control-strings": "^1.0.0",
        "has-unicode": "^2.0.1",
        "object-assign": "^4.1.1",
        "signal-exit": "^3.0.0",
        "string-width": "^4.2.3",
        "strip-ansi": "^6.0.1",
        "wide-align": "^1.1.2"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.2.4.tgz",
      "integrity": "sha512-5uYhsJH8VJBTv7oslg4BznJYhDoRI6waYCxMmCdnTrcCrHA/fCFKoTFz2JKKE0HdDFUF7/oQuhzumXJK7paBRQ==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "has-proto": "^1.0.1",
        "has-symbols": "^1.0.3",
        "hasown": "^2.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "deprecated": "Glob versions prior to v9 are no longer supported",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/gopd": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz",
      "integrity": "sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==",
      "dependencies": {
        "get-intrinsic": "^1.1.3"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-property-descriptors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.2.tgz",
      "integrity": "sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==",
      "dependencies": {
        "es-define-property": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-proto": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has-proto/-/has-proto-1.0.3.tgz",
      "integrity": "sha512-SJ1amZAJUiZS+PhsVLf5tGydlaVB8EdFpaSO4gmiUKUOxk8qzn5AIy4ZeJUmh22znIdk/uMAUT2pl3FxzVUH+Q==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-unicode": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/has-unicode/-/has-unicode-2.0.1.tgz",
      "integrity": "sha512-8Rf9Y83NBReMnx0gFzA8JImQACstCYWUplepDa9xprwwtmgEZUF0h/i5xSA625zB/I37EtrswSST6OXxwaaIJQ=="
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/helmet": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/helmet/-/helmet-7.1.0.tgz",
      "integrity": "sha512-g+HZqgfbpXdCkme/Cd/mZkV0aV3BZZZSugecH03kl38m/Kmdx8jKjBikpDj2cr+Iynv4KpYEviojNdTJActJAg==",
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/htmlparser2": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/htmlparser2/-/htmlparser2-9.1.0.tgz",
      "integrity": "sha512-5zfg6mHUoaer/97TxnGpxmbR7zJtPwIYFMZ/H5ucTlPZhKvtum05yiPK3Mgai3a0DyVxv7qYqoweaEd2nrYQzQ==",
      "funding": [
        "https://github.com/fb55/htmlparser2?sponsor=1",
        {
          "type": "github",
          "url": "https://github.com/sponsors/fb55"
        }
      ],
      "dependencies": {
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.3",
        "domutils": "^3.1.0",
        "entities": "^4.5.0"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-5.0.1.tgz",
      "integrity": "sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==",
      "dependencies": {
        "agent-base": "6",
        "debug": "4"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/https-proxy-agent/node_modules/debug": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.6.tgz",
      "integrity": "sha512-O/09Bd4Z1fBrU4VzkhFqVgpPzaGbw6Sm9FEkBT1A/YBXQFGuuSxa1dN2nxgxS34JmKXqYx8CZAwEVoJFImUXIg==",
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/https-proxy-agent/node_modules/ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-arrayish": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.3.2.tgz",
      "integrity": "sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ=="
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-stream": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jsonwebtoken/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "node_modules/jwa": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.1.tgz",
      "integrity": "sha512-qiLX/xhEEFKUAJ6FiBMbes3w9ATzyk5W7Hvzpa/SLYdxNtng+gcurvrI7TbACjIXlsJyr05/S1oUhZrc63evQA==",
      "dependencies": {
        "buffer-equal-constant-time": "1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/kuler": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/kuler/-/kuler-2.0.0.tgz",
      "integrity": "sha512-Xq9nH7KlWZmXAtodXDDRE7vs6DU1gTU8zYDHDiWLSip45Egwq3plLHzPn27NgvzL2r1LMPC1vdqh98sQxtqj4A=="
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    },
    "node_modules/lodash.get": {
      "version": "4.4.2",
      "resolved": "https://registry.npmjs.org/lodash.get/-/lodash.get-4.4.2.tgz",
      "integrity": "sha512-z+Uw/vLuy6gQe8cfaFWD7p0wVv8fJl3mbzXh33RS+0oW2wvUqiRXiQ69gLWSLpgB5/6sU+r6BlQR0MBILadqTQ=="
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w=="
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg=="
    },
    "node_modules/lodash.isequal": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.isequal/-/lodash.isequal-4.5.0.tgz",
      "integrity": "sha512-pDo3lu8Jhfjqls6GkMgpahsF9kCyayhgykjyLMNFTKWrpVdAQtYyB4muAMWozBB4ig/dtWAmsMxLEI8wuz+DYQ=="
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA=="
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw=="
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA=="
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw=="
    },
    "node_modules/lodash.mergewith": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.mergewith/-/lodash.mergewith-4.6.2.tgz",
      "integrity": "sha512-GK3g5RPZWTRSeLSpgP8Xhra+pnjBC56q9FZYe1d5RN3TJ35dbkGy3YqBSMbyCrlbi+CM9Z3Jk5yTL7RCsqboyQ=="
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg=="
    },
    "node_modules/logform": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/logform/-/logform-2.6.1.tgz",
      "integrity": "sha512-CdaO738xRapbKIMVn2m4F6KTj4j7ooJ8POVnebSgKo3KBz5axNXRAL7ZdRjIV6NOr2Uf4vjtRkxrFETOioCqSA==",
      "dependencies": {
        "@colors/colors": "1.6.0",
        "@types/triple-beam": "^1.3.2",
        "fecha": "^4.2.0",
        "ms": "^2.1.1",
        "safe-stable-stringify": "^2.3.1",
        "triple-beam": "^1.3.0"
      },
      "engines": {
        "node": ">= 12.0.0"
      }
    },
    "node_modules/logform/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "node_modules/make-dir": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-3.1.0.tgz",
      "integrity": "sha512-g3FeP20LNwhALb/6Cz6Dd4F2ngze0jz7tbzrD2wAV+o9FeNHe4rL+yK2md0J/fiSf1sa1ADhXqi5+oVwOM/eGw==",
      "dependencies": {
        "semver": "^6.0.0"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-dir/node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.1.tgz",
      "integrity": "sha512-cCi6g3/Zr1iqQi6ySbseM1Xvooa98N0w31jzUYrXPX2xqObmFGHJ0tQ5u74H3mVh7wLouTseZyYIq39g8cNp1w=="
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minipass": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-5.0.0.tgz",
      "integrity": "sha512-3FnjYuehv9k6ovOEbyOswadCDPX1piCfhV8ncmYtHOjuPwylVWsghTLo7rabjC3Rx5xD4HDx8Wm1xnMF7S5qFQ==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/minizlib": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-2.1.2.tgz",
      "integrity": "sha512-bAxsR8BVfj60DWXHE3u30oHzfl4G7khkSuPW+qvpd7jFRHm7dLxOjUk1EHACJ/hxLY8phGJ0YhYHZo7jil7Qdg==",
      "dependencies": {
        "minipass": "^3.0.0",
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/minizlib/node_modules/minipass": {
      "version": "3.3.6",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.3.6.tgz",
      "integrity": "sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/mkdirp": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
      "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
      "bin": {
        "mkdirp": "bin/cmd.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/moment": {
      "version": "2.30.1",
      "resolved": "https://registry.npmjs.org/moment/-/moment-2.30.1.tgz",
      "integrity": "sha512-uEmtNhbDOrWPFS+hdjFCBfy9f2YoyzRpwcl+DqpC6taX21FzsTLQVbMV/W7PzNSX6x/bhC1zA3c2UQ5NzH6how==",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/moment-timezone": {
      "version": "0.5.45",
      "resolved": "https://registry.npmjs.org/moment-timezone/-/moment-timezone-0.5.45.tgz",
      "integrity": "sha512-HIWmqA86KcmCAhnMAN0wuDOARV/525R2+lOLotuGFzn4HO+FH+/645z2wx0Dt3iDv6/p61SIvKnDstISainhLQ==",
      "dependencies": {
        "moment": "^2.29.4"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A=="
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/neo4j-driver": {
      "version": "5.24.0",
      "resolved": "https://registry.npmjs.org/neo4j-driver/-/neo4j-driver-5.24.0.tgz",
      "integrity": "sha512-RNJAhA9Z1xTqL2QiT+MZhB91OiFBSGhnxc9jn6QvXSnD0/HNP31XkDsnUsbJUW4Y4CqEUgLVUymIelMcDIpOBQ==",
      "dependencies": {
        "neo4j-driver-bolt-connection": "5.24.0",
        "neo4j-driver-core": "5.24.0",
        "rxjs": "^7.8.1"
      }
    },
    "node_modules/neo4j-driver-bolt-connection": {
      "version": "5.24.0",
      "resolved": "https://registry.npmjs.org/neo4j-driver-bolt-connection/-/neo4j-driver-bolt-connection-5.24.0.tgz",
      "integrity": "sha512-w66Tl5trAc3wHVma1Xb3kMqhQEvgPmMdJaSiX5upp5+ZrZfyXJczghdZdqqYqVobySyeiN3DVQ1VXJLuV6SamQ==",
      "dependencies": {
        "buffer": "^6.0.3",
        "neo4j-driver-core": "5.24.0",
        "string_decoder": "^1.3.0"
      }
    },
    "node_modules/neo4j-driver-core": {
      "version": "5.24.0",
      "resolved": "https://registry.npmjs.org/neo4j-driver-core/-/neo4j-driver-core-5.24.0.tgz",
      "integrity": "sha512-X/UdHo0Cwk1aCQPTzSxkleuXAwJ7Es0/1goi3ckrFU/h+Va9QUkPGub07ohG9tXBi4wMhQFbtFn/yKLFlVwTlg=="
    },
    "node_modules/node-addon-api": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/node-addon-api/-/node-addon-api-5.1.0.tgz",
      "integrity": "sha512-eh0GgfEkpnoWDq+VY8OyvYhFEzBk6jIYbRKdIlyTiAXIVJ8PyBaKb0rp7oDtoddbdoHWhq8wwr+XZ81F1rpNdA=="
    },
    "node_modules/node-cron": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/node-cron/-/node-cron-3.0.3.tgz",
      "integrity": "sha512-dOal67//nohNgYWb+nWmg5dkFdIwDm8EpeGYMekPMrngV3637lqnX0lbUcCtgibHTz6SEz7DAIjKvKDFYCnO1A==",
      "dependencies": {
        "uuid": "8.3.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/node-cron/node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/nopt": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/nopt/-/nopt-5.0.0.tgz",
      "integrity": "sha512-Tbj67rffqceeLpcRXrT7vKAN8CwfPeIBgM7E6iBkmKLV7bEMwpGgYLGv0jACUsECaa/vuxP0IjEont6umdMgtQ==",
      "dependencies": {
        "abbrev": "1"
      },
      "bin": {
        "nopt": "bin/nopt.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/npmlog": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/npmlog/-/npmlog-5.0.1.tgz",
      "integrity": "sha512-AqZtDUWOMKs1G/8lwylVjrdYgqA4d9nu8hc+0gzRxlDb1I10+FHBGMXs6aiQHFdCUUlqH99MUMuLfzWDNDtfxw==",
      "deprecated": "This package is no longer supported.",
      "dependencies": {
        "are-we-there-yet": "^2.0.0",
        "console-control-strings": "^1.1.0",
        "gauge": "^3.0.0",
        "set-blocking": "^2.0.0"
      }
    },
    "node_modules/nth-check": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/nth-check/-/nth-check-2.1.1.tgz",
      "integrity": "sha512-lqjrjmaOoAnWfMmBPL+XNnynZh2+swxiX3WUE0s4yEHI6m+AwrK2UZOimIRl3X/4QctVqS8AiZjFqyOGrMXb/w==",
      "dependencies": {
        "boolbase": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/fb55/nth-check?sponsor=1"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-hash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/object-hash/-/object-hash-3.0.0.tgz",
      "integrity": "sha512-RSn9F68PjH9HqtltsSnqYC1XXoWe9Bju5+213R98cNGttag9q9yAOTzdbsqvIa7aNm5WffBZFpWYr2aWrklWAw==",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.2.tgz",
      "integrity": "sha512-IRZSRuzJiynemAXPYtPe5BoI/RESNYR7TYm50MC5Mqbd3Jmw5y790sErYw3V6SryFJD64b74qQQs9wn5Bg/k3g==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/one-time": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/one-time/-/one-time-1.0.0.tgz",
      "integrity": "sha512-5DXOiRKwuSEcQ/l0kGCF6Q3jcADFv5tSmRaJck/OqkVFcOzutB134KRSfF0xDrL39MNnqxbHBbUUcjZIhTgb2g==",
      "dependencies": {
        "fn.name": "1.x.x"
      }
    },
    "node_modules/openapi-types": {
      "version": "12.1.3",
      "resolved": "https://registry.npmjs.org/openapi-types/-/openapi-types-12.1.3.tgz",
      "integrity": "sha512-N4YtSYJqghVu4iek2ZUvcN/0aqH1kRDuNqzcycDxhOUpg7GdvLa2F3DgS6yBNhInhv2r/6I0Flkn7CqL8+nIcw==",
      "peer": true
    },
    "node_modules/parse5": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/parse5/-/parse5-7.1.2.tgz",
      "integrity": "sha512-Czj1WaSVpaoj0wbhMzLmWD69anp2WH7FXMB9n1Sy8/ZFF9jolSQVMu1Ij5WIyGmcBmhk7EOndpO4mIpihVqAXw==",
      "dependencies": {
        "entities": "^4.4.0"
      },
      "funding": {
        "url": "https://github.com/inikulin/parse5?sponsor=1"
      }
    },
    "node_modules/parse5-htmlparser2-tree-adapter": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/parse5-htmlparser2-tree-adapter/-/parse5-htmlparser2-tree-adapter-7.0.0.tgz",
      "integrity": "sha512-B77tOZrqqfUfnVcOrUvfdLbz4pu4RopLD/4vmu3HUPswwTA8OH0EMW9BlWR2B0RCoiZRAHEUu7IxeP1Pd1UU+g==",
      "dependencies": {
        "domhandler": "^5.0.2",
        "parse5": "^7.0.0"
      },
      "funding": {
        "url": "https://github.com/inikulin/parse5?sponsor=1"
      }
    },
    "node_modules/parse5-parser-stream": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/parse5-parser-stream/-/parse5-parser-stream-7.1.2.tgz",
      "integrity": "sha512-JyeQc9iwFLn5TbvvqACIF/VXG6abODeB3Fwmv/TGdLk2LfbWkaySGY72at4+Ty7EkPZj854u4CrICqNk2qIbow==",
      "dependencies": {
        "parse5": "^7.0.0"
      },
      "funding": {
        "url": "https://github.com/inikulin/parse5?sponsor=1"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.7.tgz",
      "integrity": "sha512-5DFkuoqlv1uYQKxy8omFBeJPQcdoE07Kv2sferDCrAq1ohOU+MSDswDIbnx3YAM60qIOnYa53wBhXW0EbMonrQ=="
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg=="
    },
    "node_modules/qs": {
      "version": "6.11.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.11.0.tgz",
      "integrity": "sha512-MvjoMCJwEarSbUYk5O+nmoSzSutSsTwF85zcHPQ9OrlFoZOYIjaqBAJIqIXjptyD5vThxGq52Xu/MaJzRkIk4Q==",
      "dependencies": {
        "side-channel": "^1.0.4"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.2.tgz",
      "integrity": "sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "deprecated": "Rimraf versions prior to v4 are no longer supported",
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/rxjs": {
      "version": "7.8.1",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.8.1.tgz",
      "integrity": "sha512-AA3TVj+0A2iuIoQkWEK/tqFjBq2j+6PO6Y0zJcvzLAFhEFIO3HL0vls9hWLncZbAAbK0mar7oZ4V079I/qPMxg==",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/safe-stable-stringify": {
      "version": "2.5.0",
      "resolved": "https://registry.npmjs.org/safe-stable-stringify/-/safe-stable-stringify-2.5.0.tgz",
      "integrity": "sha512-b3rppTKm9T+PsVCBEOUR46GWI7fdOs00VKZ1+9c1EWDaDMvjQc6tUwuFyIprgGgTcWoVHSKrU8H31ZHA2e0RHA==",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "node_modules/semver": {
      "version": "7.6.3",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.6.3.tgz",
      "integrity": "sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "0.18.0",
      "resolved": "https://registry.npmjs.org/send/-/send-0.18.0.tgz",
      "integrity": "sha512-qqWzuOjSFOuqPjFe4NOsMLafToQQwBSOEpS+FwEt3A2V3vKubTquT3vmLTQpFgMXp8AlFWFuP1qKaJZOtPpVXg==",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "2.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "node_modules/serve-static": {
      "version": "1.15.0",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.15.0.tgz",
      "integrity": "sha512-XGuRDNjXUijsUL0vl6nSD7cwURuzEgglbOaFuZM9g3kwDXOWVTck0jLzjPzGD+TazWbboZYu52/9/XPdUgne9g==",
      "dependencies": {
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.18.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/set-blocking": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz",
      "integrity": "sha512-KiKBS8AnWGEyLzofFfmvKwpdPzqiy16LvQfK3yv/fVH7Bj13/wl3JSR1J+rfgRE9q7xUJK4qvgS8raSOeLUehw=="
    },
    "node_modules/set-function-length": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/set-function-length/-/set-function-length-1.2.2.tgz",
      "integrity": "sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "gopd": "^1.0.1",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/side-channel": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.0.6.tgz",
      "integrity": "sha512-fDW/EZ6Q9RiO8eFG8Hj+7u/oW+XrPTIChwCOM2+th2A6OblDtYYIpve9m+KvI9Z4C9qSEXlaGR6bTEYHReuglA==",
      "dependencies": {
        "call-bind": "^1.0.7",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.4",
        "object-inspect": "^1.13.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ=="
    },
    "node_modules/simple-swizzle": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/simple-swizzle/-/simple-swizzle-0.2.2.tgz",
      "integrity": "sha512-JA//kQgZtbuY83m+xT+tXJkmJncGMTFT+C+g2h2R9uxkYIrE2yy9sgmcLhCnw57/WSD+Eh3J97FPEDFnbXnDUg==",
      "dependencies": {
        "is-arrayish": "^0.3.1"
      }
    },
    "node_modules/stack-trace": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/stack-trace/-/stack-trace-0.0.10.tgz",
      "integrity": "sha512-KGzahc7puUKkzyMt+IqAep+TVNbKP+k2Lmwhub39m1AsTSkaDutx56aDCo+HLDzf/D26BIHTJWNiTG1KAJiQCg==",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/swagger-jsdoc": {
      "version": "6.2.8",
      "resolved": "https://registry.npmjs.org/swagger-jsdoc/-/swagger-jsdoc-6.2.8.tgz",
      "integrity": "sha512-VPvil1+JRpmJ55CgAtn8DIcpBs0bL5L3q5bVQvF4tAW/k/9JYSj7dCpaYCAv5rufe0vcCbBRQXGvzpkWjvLklQ==",
      "dependencies": {
        "commander": "6.2.0",
        "doctrine": "3.0.0",
        "glob": "7.1.6",
        "lodash.mergewith": "^4.6.2",
        "swagger-parser": "^10.0.3",
        "yaml": "2.0.0-1"
      },
      "bin": {
        "swagger-jsdoc": "bin/swagger-jsdoc.js"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/swagger-jsdoc/node_modules/glob": {
      "version": "7.1.6",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.6.tgz",
      "integrity": "sha512-LwaxwyZ72Lk7vZINtNNrywX0ZuLyStrdDtabefZKAY5ZGJhVtgdznluResxNmPitE0SAO+O26sWTHeKSI2wMBA==",
      "deprecated": "Glob versions prior to v9 are no longer supported",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/swagger-parser": {
      "version": "10.0.3",
      "resolved": "https://registry.npmjs.org/swagger-parser/-/swagger-parser-10.0.3.tgz",
      "integrity": "sha512-nF7oMeL4KypldrQhac8RyHerJeGPD1p2xDh900GPvc+Nk7nWP6jX2FcC7WmkinMoAmoO774+AFXcWsW8gMWEIg==",
      "dependencies": {
        "@apidevtools/swagger-parser": "10.0.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/swagger-ui-dist": {
      "version": "5.17.14",
      "resolved": "https://registry.npmjs.org/swagger-ui-dist/-/swagger-ui-dist-5.17.14.tgz",
      "integrity": "sha512-CVbSfaLpstV65OnSjbXfVd6Sta3q3F7Cj/yYuvHMp1P90LztOLs6PfUnKEVAeiIVQt9u2SaPwv0LiH/OyMjHRw=="
    },
    "node_modules/swagger-ui-express": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/swagger-ui-express/-/swagger-ui-express-5.0.1.tgz",
      "integrity": "sha512-SrNU3RiBGTLLmFU8GIJdOdanJTl4TOmT27tt3bWWHppqYmAZ6IDuEuBvMU6nZq0zLEe6b/1rACXCgLZqO6ZfrA==",
      "dependencies": {
        "swagger-ui-dist": ">=5.0.0"
      },
      "engines": {
        "node": ">= v0.10.32"
      },
      "peerDependencies": {
        "express": ">=4.0.0 || >=5.0.0-beta"
      }
    },
    "node_modules/tar": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/tar/-/tar-6.2.1.tgz",
      "integrity": "sha512-DZ4yORTwrbTj/7MZYq2w+/ZFdI6OZ/f9SFHR+71gIVUZhOQPHzVCLpvRnPgyaMpfWxxk/4ONva3GQSyNIKRv6A==",
      "dependencies": {
        "chownr": "^2.0.0",
        "fs-minipass": "^2.0.0",
        "minipass": "^5.0.0",
        "minizlib": "^2.1.1",
        "mkdirp": "^1.0.3",
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/text-hex": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/text-hex/-/text-hex-1.0.0.tgz",
      "integrity": "sha512-uuVGNWzgJ4yhRaNSiubPY7OjISw4sw4E5Uv0wbjp+OzcbmVU/rsT8ujgcXJhn9ypzsgr5vlzpPqP+MBBKcGvbg=="
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "node_modules/triple-beam": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/triple-beam/-/triple-beam-1.4.1.tgz",
      "integrity": "sha512-aZbgViZrg1QNcG+LULa7nhZpJTZSLm/mXnHXnbAbjmN5aSa0y7V+wvv6+4WaBtpISJzThKy+PIPxc1Nq1EJ9mg==",
      "engines": {
        "node": ">= 14.0.0"
      }
    },
    "node_modules/ts-node": {
      "version": "10.9.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
      "dev": true,
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/tslib": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.7.0.tgz",
      "integrity": "sha512-gLXCKdN1/j47AiHiOkJN69hJmcbGTHI0ImLmbYLHykhgeN0jVGola9yVjFgzCUklsZQMW55o+dW7IXv3RCXDzA=="
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typescript": {
      "version": "5.5.4",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.5.4.tgz",
      "integrity": "sha512-Mtq29sKDAEYP7aljRgtPOpTvOfbwRWlS6dPRzwjdE+C0R4brX/GUyhHSecbHMFLNBLcJIPt9nl9yG5TZ1weH+Q==",
      "dev": true,
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici": {
      "version": "6.19.8",
      "resolved": "https://registry.npmjs.org/undici/-/undici-6.19.8.tgz",
      "integrity": "sha512-U8uCCl2x9TK3WANvmBavymRzxbfFYG+tAu+fgx3zxQy3qdagQqBLwJVrdyO1TBfUXvfKveMKJZhpvUYoOjM+4g==",
      "engines": {
        "node": ">=18.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.19.8",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.19.8.tgz",
      "integrity": "sha512-ve2KP6f/JnbPBFyobGHuerC9g1FYGn/F8n1LWTwNxCEzd6IfqTwUQcNXgEtmmQ6DlRrC1hrSrBnCZPokRrDHjw=="
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw=="
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-8XkAphELsDnEGrDxUOHB3RGvXz6TeuYSGEZBOjtTtPm2lwhGBjLgOzLHB63IUWfBpNucQjND6d3AOudO+H3RWQ==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true
    },
    "node_modules/validator": {
      "version": "13.12.0",
      "resolved": "https://registry.npmjs.org/validator/-/validator-13.12.0.tgz",
      "integrity": "sha512-c1Q0mCiPlgdTVVVIJIrBuxNicYE+t/7oKeI9MWLj3fh/uq2Pxh/3eeWbVZ4OcGW1TUf53At0njHw5SMdA3tmMg==",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "node_modules/whatwg-encoding": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/whatwg-encoding/-/whatwg-encoding-3.1.1.tgz",
      "integrity": "sha512-6qN4hJdMwfYBtE3YBTTHhoeuUrDBPZmbQaxWAqSALV/MeEnR5z1xd8UKud2RAkFoPkmB+hli1TZSnyi84xz1vQ==",
      "dependencies": {
        "iconv-lite": "0.6.3"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/whatwg-encoding/node_modules/iconv-lite": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
      "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/whatwg-mimetype": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-mimetype/-/whatwg-mimetype-4.0.0.tgz",
      "integrity": "sha512-QaKxh0eNIi2mE9p2vEdzfagOKHCcj1pJ56EEHGQOVxp8r9/iszLUUV7v89x9O1p/T+NlTM5W7jW6+cz4Fq1YVg==",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "node_modules/wide-align": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/wide-align/-/wide-align-1.1.5.tgz",
      "integrity": "sha512-eDMORYaPNZ4sQIuuYPDHdQvf4gyCF9rEEV/yPxGfwPkRodwEgiMUUXTx/dex+Me0wxx53S+NgUHaP7y3MGlDmg==",
      "dependencies": {
        "string-width": "^1.0.2 || 2 || 3 || 4"
      }
    },
    "node_modules/winston": {
      "version": "3.14.2",
      "resolved": "https://registry.npmjs.org/winston/-/winston-3.14.2.tgz",
      "integrity": "sha512-CO8cdpBB2yqzEf8v895L+GNKYJiEq8eKlHU38af3snQBQ+sdAIUepjMSguOIJC7ICbzm0ZI+Af2If4vIJrtmOg==",
      "dependencies": {
        "@colors/colors": "^1.6.0",
        "@dabh/diagnostics": "^2.0.2",
        "async": "^3.2.3",
        "is-stream": "^2.0.0",
        "logform": "^2.6.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.7.0"
      },
      "engines": {
        "node": ">= 12.0.0"
      }
    },
    "node_modules/winston-daily-rotate-file": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/winston-daily-rotate-file/-/winston-daily-rotate-file-5.0.0.tgz",
      "integrity": "sha512-JDjiXXkM5qvwY06733vf09I2wnMXpZEhxEVOSPenZMii+g7pcDcTBt2MRugnoi8BwVSuCT2jfRXBUy+n1Zz/Yw==",
      "dependencies": {
        "file-stream-rotator": "^0.6.1",
        "object-hash": "^3.0.0",
        "triple-beam": "^1.4.1",
        "winston-transport": "^4.7.0"
      },
      "engines": {
        "node": ">=8"
      },
      "peerDependencies": {
        "winston": "^3"
      }
    },
    "node_modules/winston-transport": {
      "version": "4.7.1",
      "resolved": "https://registry.npmjs.org/winston-transport/-/winston-transport-4.7.1.tgz",
      "integrity": "sha512-wQCXXVgfv/wUPOfb2x0ruxzwkcZfxcktz6JIMUaPLmcNhO4bZTwA/WtDWK74xV3F2dKu8YadrFv0qhwYjVEwhA==",
      "dependencies": {
        "logform": "^2.6.1",
        "readable-stream": "^3.6.2",
        "triple-beam": "^1.3.0"
      },
      "engines": {
        "node": ">= 12.0.0"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ=="
    },
    "node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
    },
    "node_modules/yaml": {
      "version": "2.0.0-1",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.0.0-1.tgz",
      "integrity": "sha512-W7h5dEhywMKenDJh2iX/LABkbFnBxasD27oyXWDS/feDsxiw0dD5ncXdYXgkvAsXIY2MpW/ZKkr9IU30DBdMNQ==",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/z-schema": {
      "version": "5.0.5",
      "resolved": "https://registry.npmjs.org/z-schema/-/z-schema-5.0.5.tgz",
      "integrity": "sha512-D7eujBWkLa3p2sIpJA0d1pr7es+a7m0vFAnZLlCEKq/Ij2k0MLi9Br2UPxoxdYystm5K1yeBGzub0FlYUEWj2Q==",
      "dependencies": {
        "lodash.get": "^4.4.2",
        "lodash.isequal": "^4.5.0",
        "validator": "^13.7.0"
      },
      "bin": {
        "z-schema": "bin/z-schema"
      },
      "engines": {
        "node": ">=8.0.0"
      },
      "optionalDependencies": {
        "commander": "^9.4.1"
      }
    },
    "node_modules/z-schema/node_modules/commander": {
      "version": "9.5.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-9.5.0.tgz",
      "integrity": "sha512-KRs7WVDKg86PWiuAqhDrAQnTXZKraVcCc6vFdL14qrZ/DcWwuRo7VoiYXalXO7S5GKpqYiVEwCbgFDfxNHKJBQ==",
      "optional": true,
      "engines": {
        "node": "^12.20.0 || >=14"
      }
    }
  }
}



File: ./compose.yaml
----------------------------------------
# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Docker Compose reference guide at
# https://docs.docker.com/go/compose-spec-reference/

# Here the instructions define your application as a service called "server".
# This service is built from the Dockerfile in the current directory.
# You can add other services your application may depend on here, such as a
# database or a cache. For examples, see the Awesome Compose repository:
# https://github.com/docker/awesome-compose
services:
  server:
    build:
      context: .
    environment:
      NODE_ENV: production
      WHATSAPP_BOT_API_KEY: ${WHATSAPP_BOT_API_KEY}
      NEO_4J_LEDGER_SPACE_BOLT_URL: ${NEO_4J_LEDGER_SPACE_BOLT_URL}
      NEO_4J_LEDGER_SPACE_USER: ${NEO_4J_LEDGER_SPACE_USER}
      NEO_4J_LEDGER_SPACE_PASS: ${NEO_4J_LEDGER_SPACE_PASS}
      NEO_4J_SEARCH_SPACE_BOLT_URL: ${NEO_4J_SEARCH_SPACE_BOLT_URL}
      NEO_4J_SEARCH_SPACE_USER: ${NEO_4J_SEARCH_SPACE_USER}
      NEO_4J_SEARCH_SPACE_PASS: ${NEO_4J_SEARCH_SPACE_PASS}
      DEPLOYMENT: ${DEPLOYMENT}
      OPEN_EXCHANGE_RATES_API: ${OPEN_EXCHANGE_RATES_API}      
    ports:
      - 5000:5000
# The commented out section below is an example of how to define a PostgreSQL
# database that your application can use. `depends_on` tells Docker Compose to
# start the database before your application. The `db-data` volume persists the
# database data between container restarts. The `db-password` secret is used
# to set the database password. You must create `db/password.txt` and add
# a password of your choosing to it before running `docker-compose up`.
#     depends_on:
#       db:
#         condition: service_healthy
#   db:
#     image: postgres
#     restart: always
#     user: postgres
#     secrets:
#       - db-password
#     volumes:
#       - db-data:/var/lib/postgresql/data
#     environment:
#       - POSTGRES_DB=example
#       - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
#     expose:
#       - 5432
#     healthcheck:
#       test: [ "CMD", "pg_isready" ]
#       interval: 10s
#       timeout: 5s
#       retries: 5
# volumes:
#   db-data:
# secrets:
#   db-password:
#     file: db/password.txt




File: ./logs/.6b77785a74c362881f6fb7e95a7530280abbf9ed-audit.json
----------------------------------------
{
    "keep": {
        "days": true,
        "amount": 14
    },
    "auditLog": "logs/.6b77785a74c362881f6fb7e95a7530280abbf9ed-audit.json",
    "files": [
        {
            "date": 1725722060892,
            "name": "logs/error-2024-09-07.log",
            "hash": "a2cccfde538dcdd8ebb66c0a58d9f730b1f83c7531df1e290a19d96b9233c441"
        },
        {
            "date": 1725753605527,
            "name": "logs/error-2024-09-08.log",
            "hash": "21c74ef049a33ba83f5ada2a63e9dc808aaf9d87c05847438eabb85c4c3a1a5f"
        }
    ],
    "hashType": "sha256"
}


File: ./logs/.ca6dad43b7d35307d69543a741eb24d3ce997028-audit.json
----------------------------------------
{
    "keep": {
        "days": true,
        "amount": 14
    },
    "auditLog": "logs/.ca6dad43b7d35307d69543a741eb24d3ce997028-audit.json",
    "files": [
        {
            "date": 1725722060895,
            "name": "logs/combined-2024-09-07.log",
            "hash": "94c093d3457a97948aeef51a108635c130ed14512391ba3cc5562aba32bd78d8"
        },
        {
            "date": 1725753600101,
            "name": "logs/combined-2024-09-08.log",
            "hash": "6c955f6d361884146fa09d55e9d3747ca56c8413a481ffb235ab3512112f8d7a"
        }
    ],
    "hashType": "sha256"
}


File: ./README.Docker.md
----------------------------------------
### Building and running your application

When you're ready, start your application by running:
`docker compose up --build`.

Your application will be available at http://localhost:5000.

### Deploying your application to the cloud

First, build your image, e.g.: `docker build -t myapp .`.
If your cloud uses a different CPU architecture than your development
machine (e.g., you are on a Mac M1 and your cloud provider is amd64),
you'll want to build the image for that platform, e.g.:
`docker build --platform=linux/amd64 -t myapp .`.

Then, push it to your registry, e.g. `docker push myregistry.com/myapp`.

Consult Docker's [getting started](https://docs.docker.com/go/get-started-sharing/)
docs for more detail on building and pushing.

### References
* [Docker's Node.js guide](https://docs.docker.com/language/nodejs/)


