name: Initial Deployment to AWS

on:
  workflow_dispatch:

jobs:
  deploy:
    name: Initial AWS Deployment
    runs-on: ubuntu-latest
    env:
      TF_VAR_aws_region: ${{ secrets.AWS_REGION }}
      TF_VAR_neo4j_enterprise_license: ${{ secrets.NEO4J_ENTERPRISE_LICENSE }}
      TF_VAR_open_exchange_rates_api: ${{ secrets.OPEN_EXCHANGE_RATES_API }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set environment
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/prod" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
          fi

      - name: Generate Secrets
        run: |
          chmod +x .github/workflows/generate_secrets.sh
          ./.github/workflows/generate_secrets.sh ${{ env.ENVIRONMENT }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.TF_VAR_aws_region }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Pre-deployment Checks
        id: pre_deployment_checks
        run: |
          cd terraform
          
          # Function to check if a resource exists in AWS
          resource_exists() {
            local resource_type=$1
            local resource_name=$2
            
            case $resource_type in
              "aws_acm_certificate")
                aws acm list-certificates --query 'CertificateSummaryList[?DomainName==`'"$resource_name"'`].CertificateArn' --output text | grep -q .
                ;;
              "aws_security_group")
                aws ec2 describe-security-groups --filters "Name=group-name,Values=$resource_name" --query 'SecurityGroups[0].GroupId' --output text | grep -q .
                ;;
              "aws_instance")
                aws ec2 describe-instances --filters "Name=tag:Name,Values=$resource_name" "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].[InstanceId]' --output text | grep -q .
                ;;
              "aws_ecs_cluster")
                aws ecs list-clusters --query "clusterArns[?contains(@, '$resource_name')]" --output text | grep -q .
                ;;
              "aws_ecs_service")
                aws ecs list-services --cluster "credex-cluster-${{ env.ENVIRONMENT }}" --query "serviceArns[?contains(@, '$resource_name')]" --output text | grep -q .
                ;;
              "aws_lb")
                aws elbv2 describe-load-balancers --query "LoadBalancers[?LoadBalancerName=='$resource_name'].LoadBalancerArn" --output text | grep -q .
                ;;
              *)
                echo "Unknown resource type: $resource_type"
                return 1
                ;;
            esac
          }
          
          # Check for existing resources
          echo "Checking for existing resources..."
          
          if resource_exists "aws_acm_certificate" "${TF_VAR_domain}" || \
             resource_exists "aws_security_group" "credex-alb-sg-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_security_group" "credex-core-ecs-tasks-sg-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_security_group" "credex-neo4j-sg-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_ecs_cluster" "credex-cluster-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_ecs_service" "credex-core-service-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_lb" "credex-alb-${{ env.ENVIRONMENT }}"; then
            echo "Error: Some resources already exist. This script is intended for initial deployment only."
            exit 1
          fi
          
          # Check for Neo4j instances
          neo4j_instance_count=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=Neo4j-${{ env.ENVIRONMENT }}-*" "Name=instance-state-name,Values=running" --query 'length(Reservations[].Instances[])' --output text)
          
          if [ "$neo4j_instance_count" -gt 0 ]; then
            echo "Error: Neo4j instances already exist. This script is intended for initial deployment only."
            exit 1
          fi

      - name: Terraform Init and Workspace Selection
        run: |
          cd terraform
          terraform init
          terraform workspace select ${{ env.ENVIRONMENT }} || terraform workspace new ${{ env.ENVIRONMENT }}

      - name: Terraform Plan
        id: plan
        run: |
          cd terraform
          terraform plan -out=tfplan

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: tf-outputs
        run: |
          cd terraform
          echo "Retrieving Terraform outputs..."
          terraform output -json > tf_outputs.json
          echo "tf_outputs=$(cat tf_outputs.json | jq -c .)" >> $GITHUB_OUTPUT

      - name: Update ECS Task Definition
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          # Update ECS task definition
          TASK_DEF=$(aws ecs describe-task-definition --task-definition credex-core-${{ env.ENVIRONMENT }} --query taskDefinition)
          NEW_TASK_DEF=$(echo $TASK_DEF | jq '.containerDefinitions[0].environment += [
            {"name": "NEO_4J_LEDGER_SPACE_BOLT_URL", "value": "${{ secrets.NEO_4J_LEDGER_SPACE_BOLT_URL }}"},
            {"name": "NEO_4J_SEARCH_SPACE_BOLT_URL", "value": "${{ secrets.NEO_4J_SEARCH_SPACE_BOLT_URL }}"},
            {"name": "NEO_4J_LEDGER_SPACE_USER", "value": "${{ secrets.NEO_4J_LEDGER_SPACE_USER }}"},
            {"name": "NEO_4J_LEDGER_SPACE_PASS", "value": "${{ secrets.NEO_4J_LEDGER_SPACE_PASS }}"},
            {"name": "NEO_4J_SEARCH_SPACE_USER", "value": "${{ secrets.NEO_4J_SEARCH_SPACE_USER }}"},
            {"name": "NEO_4J_SEARCH_SPACE_PASS", "value": "${{ secrets.NEO_4J_SEARCH_SPACE_PASS }}"},
            {"name": "JWT_SECRET", "value": "${{ secrets.JWT_SECRET }}"}
          ]')
          echo $NEW_TASK_DEF > new-task-def.json
          aws ecs register-task-definition --cli-input-json file://new-task-def.json

      - name: Deploy Application
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          echo "Deploying application to ${{ env.ENVIRONMENT }} from branch ${{ github.ref_name }}"
          # Update ECS service to use the new task definition
          aws ecs update-service --cluster credex-cluster-${{ env.ENVIRONMENT }} --service credex-core-service-${{ env.ENVIRONMENT }} --task-definition credex-core-${{ env.ENVIRONMENT }}

      - name: Run Post-Deployment Tests
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          echo "Running post-deployment tests for ${{ env.ENVIRONMENT }}"
          # Add your test commands here

      - name: Log Deployment
        if: success()
        run: |
          echo "Initial deployment to ${{ env.ENVIRONMENT }} from branch ${{ github.ref_name }} completed successfully at $(date)"

      - name: Notify on Failure
        if: failure()
        run: |
          echo "Initial deployment to ${{ env.ENVIRONMENT }} from branch ${{ github.ref_name }} failed. Please check the logs for more information."
          # Add notification mechanism here (e.g., send an email, Slack message, etc.)
