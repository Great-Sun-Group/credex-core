# Deployment Process

This document outlines the deployment process for the credex-core application across development, staging, and production environments.

## Modular Terraform Structure

The Terraform configuration is organized into the following modules:

1. Root Module (terraform/)
2. Shared Resources Module (terraform/shared_resources/)
3. Neo4j Module (terraform/neo4j/)

For detailed information about the Terraform structure, refer to the TERRAFORM.md file in the root directory.

## Deployment Workflows

The deployment process is managed through three main GitHub Actions workflows:

1. **foundations.yml**: Deploys shared resources (VPC, networking, security groups, ALB)
2. **databases.yml**: Deploys Neo4j instances and related resources
3. **app.yml**: Deploys the application (ECS tasks, services, and ECR)

### Foundations Workflow (foundations.yml)

This workflow is responsible for setting up the basic infrastructure:

1. **Environment Detection**: Automatically detects the target environment based on the branch.
2. **AWS Credentials Configuration**: Sets up AWS credentials for Terraform.
3. **Terraform Initialization and Apply**: Initializes Terraform and applies the shared resources module.
4. **Output Infrastructure Information**: Provides information about the created resources.

### Databases Workflow (databases.yml)

This workflow sets up the Neo4j databases:

1. **Environment Detection**: Determines the target environment.
2. **AWS Credentials Configuration**: Sets up AWS credentials.
3. **Terraform Initialization and Apply**: Applies the Neo4j module.
4. **Neo4j Information Output**: Provides connection details for the Neo4j instances.

### Application Deployment Workflow (app.yml)

This workflow deploys the application:

1. **Environment Detection**: Determines the target environment.
2. **AWS Credentials and ECR Login**: Sets up AWS credentials and logs into ECR.
3. **Docker Build and Push**: Builds the application Docker image and pushes it to ECR.
4. **Application Deployment**: Updates the ECS task definition and service with the new image.

## Handling of Secrets and Configuration

- Environment-specific secrets are stored as GitHub Secrets for each environment.
- The following secrets are manually set for each environment:
  - AWS_ACCESS_KEY
  - AWS_SECRET_ACCESS_KEY
  - NEO4J_ENTERPRISE_LICENSE
  - OPEN_EXCHANGE_RATES_API
  - JWT_SECRET
  - NEO_4J_LEDGER_SPACE_USER (once generated by databases.yml)
  - NEO_4J_LEDGER_SPACE_PASS (once generated by databases.yml)
  - NEO_4J_LEDGER_SPACE_BOLT_URL (once generated by databases.yml)
  - NEO_4J_SEARCH_SPACE_USER (once generated by databases.yml)
  - NEO_4J_SEARCH_SPACE_PASS (once generated by databases.yml)
  - NEO_4J_SEARCH_SPACE_BOLT_URL (once generated by databases.yml)
- The AWS_REGION is hardcoded in the `terraform/variables.tf` file.
- Domain names are constructed using variables in `terraform/variables.tf`.
- All secrets are never exposed in logs or code repositories.

## Hardcoded Variables

The following variables are defined in the `terraform/variables.tf` file:

- aws_region: "af-south-1"
- domain_base: "mycredex.app"
- subdomain_prefix:
  - development: "dev.api"
  - staging: "stage.api"
  - production: "api"

These variables are used to construct the domain names for each environment:
- Development: dev.api.mycredex.app
- Staging: stage.api.mycredex.app
- Production: api.mycredex.app

## Post-Deployment Verification

After each deployment, verify that the application is functioning correctly:

1. Check the GitHub Actions logs for any deployment errors.
2. Verify that the ECS tasks are running correctly in the AWS console.
3. Access the application and perform basic functionality tests.
4. Verify the application's connection to both LedgerSpace and SearchSpace Neo4j databases.
5. Monitor the application logs for any unexpected errors.
6. Review the Terraform output for any unexpected changes or warnings.
7. Confirm that the correct domain name is being used for the deployed environment.

## Continuous Improvement

Regularly review and update the deployment process to:
- Incorporate new best practices in infrastructure-as-code and CI/CD.
- Optimize resource usage and costs.
- Enhance security measures.
- Improve deployment speed and reliability.
