name: Initial Deployment to AWS

on:
  workflow_dispatch:

jobs:
  deploy:
    name: Initial AWS Deployment
    runs-on: ubuntu-latest
    env:
      TF_VAR_domain_base: mycredex.app
      TF_VAR_subdomain_development: dev.api
      TF_VAR_subdomain_staging: stage.api
      TF_VAR_subdomain_production: api
      TF_VAR_neo4j_instance_count_development: 2
      TF_VAR_neo4j_instance_count_staging: 2
      TF_VAR_neo4j_instance_count_production: 2
      TF_VAR_neo4j_instance_type_development: t3.xlarge
      TF_VAR_neo4j_instance_type_staging: r5.2xlarge
      TF_VAR_neo4j_instance_type_production: r5.12xlarge
      TF_VAR_log_level_development: debug
      TF_VAR_log_level_staging: info
      TF_VAR_log_level_production: info

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set Environment
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/prod" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
          fi

      - name: Set GitHub Environment
        run: |
          echo "GITHUB_ENV=${{ env.ENVIRONMENT }}" >> $GITHUB_ENV
          echo "Setting GitHub Environment to: ${{ env.ENVIRONMENT }}"

      - name: Use GitHub Environment
        uses: actions/github-script@v6
        with:
          script: |
            core.exportVariable('GITHUB_JOB_ENV', '${{ env.ENVIRONMENT }}')

      - name: Set Environment Variables
        env:
          GITHUB_ENV: ${{ env.GITHUB_JOB_ENV }}
        run: |
          echo "NODE_ENV=${{ env.ENVIRONMENT }}" >> $GITHUB_ENV
          echo "TF_VAR_environment=${{ env.ENVIRONMENT }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ secrets.AWS_REGION }}" >> $GITHUB_ENV
          echo "TF_VAR_open_exchange_rates_api=${{ secrets.OPEN_EXCHANGE_RATES_API }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_enterprise_license=${{ secrets.NEO4J_ENTERPRISE_LICENSE }}" >> $GITHUB_ENV

      - name: Debug - Print Environment Variables
        run: |
          echo "NODE_ENV: ${{ env.NODE_ENV }}"
          echo "TF_VAR_environment: ${{ env.TF_VAR_environment }}"
          echo "GitHub Environment: ${{ env.GITHUB_ENV }}"
          echo "AWS_REGION: ${{ env.AWS_REGION }}"
          echo "OPEN_EXCHANGE_RATES_API is set: ${{ env.TF_VAR_open_exchange_rates_api != '' }}"
          echo "NEO4J_ENTERPRISE_LICENSE is set: ${{ env.TF_VAR_neo4j_enterprise_license != '' }}"

      - name: Check Required Secrets
        run: |
          required_secrets=("AWS_ACCESS_KEY_ID" "AWS_SECRET_ACCESS_KEY" "AWS_REGION" "OPEN_EXCHANGE_RATES_API" "NEO4J_ENTERPRISE_LICENSE")
          missing_secrets=()
          
          for secret in "${required_secrets[@]}"; do
            if [ -z "${{ secrets[secret] }}" ]; then
              missing_secrets+=("$secret")
            fi
          done
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "Error: The following required secrets are missing: ${missing_secrets[*]}"
            echo "Please set these secrets in your GitHub repository settings."
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Debug - Check AWS Configuration
        run: |
          echo "Checking AWS credentials..."
          if aws sts get-caller-identity &> /dev/null; then
            echo "AWS credentials are valid"
            aws sts get-caller-identity
          else
            echo "Error: AWS credentials are invalid or not set correctly"
            echo "AWS_ACCESS_KEY_ID is set: ${{ secrets.AWS_ACCESS_KEY_ID != '' }}"
            echo "AWS_SECRET_ACCESS_KEY is set: ${{ secrets.AWS_SECRET_ACCESS_KEY != '' }}"
            echo "AWS_REGION is set: ${{ env.AWS_REGION != '' }}"
            exit 1
          fi
          aws configure list

      - name: Generate Secrets
        run: |
          chmod +x .github/workflows/generate_secrets.sh
          ./.github/workflows/generate_secrets.sh ${{ env.NODE_ENV }}

      - name: Set Terraform variables
        run: |
          echo "TF_VAR_jwt_secret=${{ secrets.JWT_SECRET }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_ledger_space_user=${{ secrets.NEO_4J_LEDGER_SPACE_USER }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_ledger_space_pass=${{ secrets.NEO_4J_LEDGER_SPACE_PASS }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_search_space_user=${{ secrets.NEO_4J_SEARCH_SPACE_USER }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_search_space_pass=${{ secrets.NEO_4J_SEARCH_SPACE_PASS }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_public_key=${{ secrets.NEO4J_PUBLIC_KEY }}" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Pre-deployment Checks
        id: pre_deployment_checks
        run: |
          cd terraform

          # Function to check if a resource exists in AWS
          resource_exists() {
            local resource_type=$1
            local resource_name=$2
            
            case $resource_type in
              "aws_acm_certificate")
                aws acm list-certificates --query 'CertificateSummaryList[?DomainName==`'"$resource_name"'`].CertificateArn' --output text | grep -q .
                ;;
              "aws_security_group")
                aws ec2 describe-security-groups --filters "Name=group-name,Values=$resource_name" --query 'SecurityGroups[0].GroupId' --output text | grep -q .
                ;;
              "aws_instance")
                aws ec2 describe-instances --filters "Name=tag:Name,Values=$resource_name" "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].[InstanceId]' --output text | grep -q .
                ;;
              "aws_ecs_cluster")
                aws ecs list-clusters --query "clusterArns[?contains(@, '$resource_name')]" --output text | grep -q .
                ;;
              "aws_ecs_service")
                aws ecs list-services --cluster "credex-cluster-${{ env.TF_VAR_environment }}" --query "serviceArns[?contains(@, '$resource_name')]" --output text | grep -q .
                ;;
              "aws_lb")
                aws elbv2 describe-load-balancers --query "LoadBalancers[?LoadBalancerName=='$resource_name'].LoadBalancerArn" --output text | grep -q .
                ;;
              *)
                echo "Unknown resource type: $resource_type"
                return 1
                ;;
            esac
          }

          # Check for existing resources
          echo "Checking for existing resources..."

          if resource_exists "aws_acm_certificate" "${TF_VAR_domain_base}" || \
             resource_exists "aws_security_group" "credex-alb-sg-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_security_group" "credex-core-ecs-tasks-sg-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_security_group" "credex-neo4j-sg-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_ecs_cluster" "credex-cluster-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_ecs_service" "credex-core-service-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_lb" "credex-alb-${{ env.TF_VAR_environment }}"; then
            echo "Error: Some resources already exist. This script is intended for initial deployment only."
            exit 1
          fi

          # Check for Neo4j instances
          neo4j_instance_count=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=Neo4j-${{ env.TF_VAR_environment }}-*" "Name=instance-state-name,Values=running" --query 'length(Reservations[].Instances[])' --output text)

          if [ "$neo4j_instance_count" -gt 0 ]; then
            echo "Error: Neo4j instances already exist. This script is intended for initial deployment only."
            exit 1
          fi

      - name: Terraform Init and Workspace Selection
        run: |
          cd terraform
          terraform init
          terraform workspace select ${{ env.TF_VAR_environment }} || terraform workspace new ${{ env.TF_VAR_environment }}

      - name: Terraform Plan (Infrastructure)
        id: plan_infra
        run: |
          cd terraform
          terraform plan -out=tfplan_infra -target=module.neo4j -target=module.networking

      - name: Terraform Apply (Infrastructure)
        run: |
          cd terraform
          terraform apply -auto-approve tfplan_infra

      - name: Get Terraform Outputs
        id: tf-outputs
        run: |
          cd terraform
          echo "Retrieving Terraform outputs..."
          terraform output -json > tf_outputs.json
          echo "tf_outputs=$(cat tf_outputs.json | jq -c .)" >> $GITHUB_OUTPUT

      - name: Set Neo4j Bolt URLs
        run: |
          NEO4J_LEDGER_IP=$(echo '${{ steps.tf-outputs.outputs.tf_outputs }}' | jq -r '.neo4j_ledger_space_bolt_url.value' | sed 's|bolt://||' | sed 's|:7687||')
          NEO4J_SEARCH_IP=$(echo '${{ steps.tf-outputs.outputs.tf_outputs }}' | jq -r '.neo4j_search_space_bolt_url.value' | sed 's|bolt://||' | sed 's|:7687||')
          gh secret set NEO_4J_LEDGER_SPACE_BOLT_URL -b"bolt://${NEO4J_LEDGER_IP}:7687" --env ${{ env.TF_VAR_environment }}
          gh secret set NEO_4J_SEARCH_SPACE_BOLT_URL -b"bolt://${NEO4J_SEARCH_IP}:7687" --env ${{ env.TF_VAR_environment }}
          echo "TF_VAR_neo4j_ledger_space_bolt_url=bolt://${NEO4J_LEDGER_IP}:7687" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_search_space_bolt_url=bolt://${NEO4J_SEARCH_IP}:7687" >> $GITHUB_ENV

      - name: Terraform Plan (ECS)
        id: plan_ecs
        run: |
          cd terraform
          terraform plan -out=tfplan_ecs -target=module.ecs

      - name: Terraform Apply (ECS)
        run: |
          cd terraform
          terraform apply -auto-approve tfplan_ecs

      - name: Update ECS Task Definition
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          TASK_DEF=$(aws ecs describe-task-definition --task-definition credex-core-${{ env.TF_VAR_environment }} --query taskDefinition)
          NEW_TASK_DEF=$(echo $TASK_DEF | jq '.containerDefinitions[0].environment += [
            {"name": "NEO_4J_LEDGER_SPACE_BOLT_URL", "value": "${{ env.TF_VAR_neo4j_ledger_space_bolt_url }}"},
            {"name": "NEO_4J_SEARCH_SPACE_BOLT_URL", "value": "${{ env.TF_VAR_neo4j_search_space_bolt_url }}"},
            {"name": "NEO_4J_LEDGER_SPACE_USER", "value": "${{ env.TF_VAR_neo4j_ledger_space_user }}"},
            {"name": "NEO_4J_LEDGER_SPACE_PASS", "value": "${{ env.TF_VAR_neo4j_ledger_space_pass }}"},
            {"name": "NEO_4J_SEARCH_SPACE_USER", "value": "${{ env.TF_VAR_neo4j_search_space_user }}"},
            {"name": "NEO_4J_SEARCH_SPACE_PASS", "value": "${{ env.TF_VAR_neo4j_search_space_pass }}"},
            {"name": "JWT_SECRET", "value": "${{ env.TF_VAR_jwt_secret }}"},
            {"name": "OPEN_EXCHANGE_RATES_API", "value": "${{ env.TF_VAR_open_exchange_rates_api }}"}
          ]')
          echo $NEW_TASK_DEF > new-task-def.json
          aws ecs register-task-definition --cli-input-json file://new-task-def.json

      - name: Deploy Application
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          echo "Deploying application to ${{ env.TF_VAR_environment }} from branch ${{ github.ref_name }}"
          aws ecs update-service --cluster credex-cluster-${{ env.TF_VAR_environment }} --service credex-core-service-${{ env.TF_VAR_environment }} --task-definition credex-core-${{ env.TF_VAR_environment }}

      - name: Run Post-Deployment Tests
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          echo "Running post-deployment tests for ${{ env.TF_VAR_environment }}"
          # Add your test commands here

      - name: Log Deployment
        if: success()
        run: |
          echo "Initial deployment to ${{ env.TF_VAR_environment }} from branch ${{ github.ref_name }} completed successfully at $(date)"

      - name: Notify on Failure
        if: failure()
        run: |
          echo "Initial deployment to ${{ env.TF_VAR_environment }} from branch ${{ github.ref_name }} failed. Please check the logs for more information."
          # Add notification mechanism here (e.g., send an email, Slack message, etc.)
