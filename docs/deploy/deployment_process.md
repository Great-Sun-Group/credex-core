# Deployment Process

This document outlines the deployment process for the credex-core application across development, staging, and production environments.

## Modular Terraform Structure

The Terraform configuration is organized into the following modules:

1. Connectors Module (terraform/modules/connectors/)
2. Databases Module (terraform/modules/databases/)
3. App Module (terraform/modules/app/)

Each module has its own main.tf, variables.tf, and outputs.tf files. The root directory contains separate .tf files for each module, as well as provider.tf and backend.tf for shared configurations.

## Deployment Workflows

The deployment process is managed through three main GitHub Actions workflows:

1. **connectors.yml**: Deploys infrequently changed infrastructure (VPC, networking, security groups)
2. **databases.yml**: Deploys database resources, including Neo4j instances
3. **app.yml**: Deploys the application (ECS tasks, services, and ECR)

### Connectors Workflow (connectors.yml)

This workflow is responsible for setting up the basic infrastructure:

1. **Environment Detection**: Automatically detects the target environment based on the branch.
2. **AWS Credentials Configuration**: Sets up AWS credentials for Terraform.
3. **Terraform Workspace Selection**: Selects or creates the 'connectors' workspace.
4. **Terraform Initialization and Apply**: Initializes Terraform and applies the connectors module.
5. **Output Infrastructure Information**: Provides information about the created resources.

### Databases Workflow (databases.yml)

This workflow sets up the database resources:

1. **Environment Detection**: Determines the target environment.
2. **AWS Credentials Configuration**: Sets up AWS credentials.
3. **Terraform Workspace Selection**: Selects or creates the 'databases' workspace.
4. **Terraform Initialization and Apply**: Applies the databases module.
5. **Database Information Output**: Provides connection details for the database instances.

### Application Deployment Workflow (app.yml)

This workflow deploys the application:

1. **Environment Detection**: Determines the target environment.
2. **AWS Credentials and ECR Login**: Sets up AWS credentials and logs into ECR.
3. **Terraform Workspace Selection**: Selects or creates the 'app' workspace.
4. **Docker Build and Push**: Builds the application Docker image and pushes it to ECR.
5. **Terraform Initialization and Apply**: Applies the app module, updating ECS task definitions and services.

## Terraform Workspaces

We use Terraform workspaces to manage different environments (development, staging, production) consistently across all workflows. Each workflow selects or creates a new Terraform workspace based on the current environment, ensuring that each environment has its own isolated set of resources managed by Terraform.

## Handling of Secrets and Configuration

- Environment-specific secrets are stored as GitHub Secrets for each environment.
- The following secrets are manually set for each environment:
  - AWS_ACCESS_KEY
  - AWS_SECRET_ACCESS_KEY
  - NEO4J_ENTERPRISE_LICENSE
  - OPEN_EXCHANGE_RATES_API
  - JWT_SECRET
  - NEO_4J_LEDGER_SPACE_USER (once generated by databases.yml)
  - NEO_4J_LEDGER_SPACE_PASS (once generated by databases.yml)
  - NEO_4J_LEDGER_SPACE_BOLT_URL (once generated by databases.yml)
  - NEO_4J_SEARCH_SPACE_USER (once generated by databases.yml)
  - NEO_4J_SEARCH_SPACE_PASS (once generated by databases.yml)
  - NEO_4J_SEARCH_SPACE_BOLT_URL (once generated by databases.yml)
- The AWS_REGION is defined in the `terraform/variables.tf` file.
- Domain names are constructed using variables in `terraform/variables.tf`.
- All secrets are never exposed in logs or code repositories.

## Environment-Specific Variables

Environment-specific variables are stored in separate .tfvars files in the `terraform/environments/` directory:
- development.tfvars
- staging.tfvars
- production.tfvars

These files contain environment-specific configurations, such as instance sizes, scaling parameters, and other settings that may differ between environments.

## Post-Deployment Verification

After each deployment, verify that the application is functioning correctly:

1. Check the GitHub Actions logs for any deployment errors.
2. Verify that the ECS tasks are running correctly in the AWS console.
3. Access the application and perform basic functionality tests.
4. Verify the application's connection to both LedgerSpace and SearchSpace Neo4j databases.
5. Monitor the application logs for any unexpected errors.
6. Review the Terraform output for any unexpected changes or warnings.
7. Confirm that the correct domain name is being used for the deployed environment.

## Continuous Improvement

Regularly review and update the deployment process to:
- Incorporate new best practices in infrastructure-as-code and CI/CD.
- Optimize resource usage and costs.
- Enhance security measures.
- Improve deployment speed and reliability.
- Refine the modular structure of Terraform configurations for better maintainability.
