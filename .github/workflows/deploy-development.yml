name: Deploy to AWS Development

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "development"

env:
  ECS_CLUSTER: credex-cluster-development
  ECS_SERVICE: credex-core-service-development
  CONTAINER_NAME: credex-core
  TF_VAR_environment: development

jobs:
  deploy:
    name: Deploy to AWS Development
    runs-on: ubuntu-latest
    environment: development
    env:
      TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
      TF_VAR_whatsapp_bot_api_key: ${{ secrets.WHATSAPP_BOT_API_KEY }}
      TF_VAR_open_exchange_rates_api: ${{ secrets.OPEN_EXCHANGE_RATES_API }}
      TF_VAR_neo4j_ledger_space_user: ${{ secrets.NEO_4J_LEDGER_SPACE_USER }}
      TF_VAR_neo4j_ledger_space_pass: ${{ secrets.NEO_4J_LEDGER_SPACE_PASS }}
      TF_VAR_neo4j_search_space_user: ${{ secrets.NEO_4J_SEARCH_SPACE_USER }}
      TF_VAR_neo4j_search_space_pass: ${{ secrets.NEO_4J_SEARCH_SPACE_PASS }}
      TF_VAR_neo4j_enterprise_license: ${{ secrets.NEO4J_ENTERPRISE_LICENSE }}
      TF_VAR_neo4j_public_key: ${{ secrets.NEO4J_PUBLIC_KEY }}
      TF_VAR_neo4j_ledger_space_bolt_url: ${{ secrets.NEO4J_LEDGER_SPACE_BOLT_URL }}
      TF_VAR_neo4j_search_space_bolt_url: ${{ secrets.NEO4J_SEARCH_SPACE_BOLT_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          ref: dev

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: af-south-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1

      - name: Terraform Init
        run: terraform init
        working-directory: ./terraform

      - name: Import existing CloudWatch Log Group
        run: |
          LOG_GROUP_NAME="/ecs/credex-core-development"
          if aws logs describe-log-groups --log-group-name-prefix $LOG_GROUP_NAME | grep -q $LOG_GROUP_NAME; then
            echo "Importing existing CloudWatch Log Group"
            terraform import aws_cloudwatch_log_group.ecs_logs $LOG_GROUP_NAME
          else
            echo "CloudWatch Log Group does not exist, it will be created by Terraform"
          fi
        working-directory: ./terraform

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -out=tfplan
        working-directory: ./terraform

      - name: Terraform Apply
        id: apply
        run: |
          echo "Applying Terraform changes..."
          terraform apply -auto-approve tfplan
          echo "Terraform apply completed."
          
          echo "Outputting SSM parameter names..."
          SSM_NAMES=$(terraform output -json ssm_parameter_names | jq -r '.[]')
          echo "SSM_NAMES<<EOF" >> $GITHUB_OUTPUT
          echo "$SSM_NAMES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "Outputting VPC ID..."
          VPC_ID=$(terraform output -raw vpc_id)
          echo "VPC_ID=$VPC_ID" >> $GITHUB_OUTPUT
        working-directory: ./terraform

      - name: Verify CloudWatch Log Group
        run: |
          LOG_GROUP_NAME="/ecs/credex-core-development"
          if aws logs describe-log-groups --log-group-name-prefix $LOG_GROUP_NAME | grep -q $LOG_GROUP_NAME; then
            echo "CloudWatch Log Group $LOG_GROUP_NAME exists."
          else
            echo "Error: CloudWatch Log Group $LOG_GROUP_NAME does not exist."
            exit 1
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Get ECR Repository URL
        id: get-ecr-url
        run: |
          echo "Raw Terraform output:"
          terraform output -raw ecr_repository_url
          
          ECR_REPO_URL=$(terraform output -raw ecr_repository_url | grep -oP '[\w.-]+\.dkr\.ecr\.[\w-]+\.amazonaws\.com/[\w-]+' | head -n 1)
          if [ -z "$ECR_REPO_URL" ]; then
            echo "Failed to extract ECR Repository URL"
            exit 1
          fi
          echo "ECR_REPO_URL=$ECR_REPO_URL" >> $GITHUB_OUTPUT
          echo "Extracted ECR Repository URL: $ECR_REPO_URL"
        working-directory: ./terraform

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building and pushing to: $ECR_REPO_URL"
          docker build -t $ECR_REPO_URL:$IMAGE_TAG .
          docker push $ECR_REPO_URL:$IMAGE_TAG
          echo "image=$ECR_REPO_URL:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Update ECS task definition
        id: task-def
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          EXECUTION_ROLE_ARN=$(terraform output -raw ecs_execution_role_arn)
          TASK_ROLE_ARN=$(terraform output -raw ecs_task_role_arn)
          
          if [ -z "$EXECUTION_ROLE_ARN" ] || [ -z "$TASK_ROLE_ARN" ]; then
            echo "Failed to extract Role ARNs"
            exit 1
          fi
          
          echo "Extracted Execution Role ARN: $EXECUTION_ROLE_ARN"
          echo "Extracted Task Role ARN: $TASK_ROLE_ARN"
          
          if [ -f "task-definition.json" ]; then
            jq --arg exec_role "$EXECUTION_ROLE_ARN" --arg task_role "$TASK_ROLE_ARN" \
              '. + {executionRoleArn: $exec_role, taskRoleArn: $task_role}' task-definition.json > task-definition-updated.json
            mv task-definition-updated.json task-definition.json

            DEPLOY_ID=$(date +%s)
            
            # Use SSM parameter values instead of environment variables
            NEO4J_LEDGER_SPACE_BOLT_URL=$(aws ssm get-parameter --name "/credex/${TF_VAR_environment}/neo4j_ledger_space_bolt_url" --with-decryption --query "Parameter.Value" --output text)
            NEO4J_SEARCH_SPACE_BOLT_URL=$(aws ssm get-parameter --name "/credex/${TF_VAR_environment}/neo4j_search_space_bolt_url" --with-decryption --query "Parameter.Value" --output text)
            
            sed -i.bak \
              -e 's|${CONTAINER_IMAGE}|'${ECR_REPO_URL}:${IMAGE_TAG}'|' \
              -e 's|${NODE_ENV}|development|' \
              -e 's|${LOG_LEVEL}|debug|' \
              -e 's|${AWS_REGION}|af-south-1|' \
              -e 's|${JWT_SECRET}|'${TF_VAR_jwt_secret}'|' \
              -e 's|${WHATSAPP_BOT_API_KEY}|'${TF_VAR_whatsapp_bot_api_key}'|' \
              -e 's|${OPEN_EXCHANGE_RATES_API}|'${TF_VAR_open_exchange_rates_api}'|' \
              -e 's|${NEO_4J_LEDGER_SPACE_BOLT_URL}|'${NEO4J_LEDGER_SPACE_BOLT_URL}'|' \
              -e 's|${NEO_4J_LEDGER_SPACE_USER}|'${TF_VAR_neo4j_ledger_space_user}'|' \
              -e 's|${NEO_4J_LEDGER_SPACE_PASS}|'${TF_VAR_neo4j_ledger_space_pass}'|' \
              -e 's|${NEO_4J_SEARCH_SPACE_BOLT_URL}|'${NEO4J_SEARCH_SPACE_BOLT_URL}'|' \
              -e 's|${NEO_4J_SEARCH_SPACE_USER}|'${TF_VAR_neo4j_search_space_user}'|' \
              -e 's|${NEO_4J_SEARCH_SPACE_PASS}|'${TF_VAR_neo4j_search_space_pass}'|' \
              task-definition.json
            
            jq --arg deploy_id "$DEPLOY_ID" '.containerDefinitions[0].environment += [{"name": "DEPLOY_ID", "value": $deploy_id}]' task-definition.json > task-definition-updated.json
            mv task-definition-updated.json task-definition.json
            
            echo "Updated task definition:"
            cat task-definition.json
            
            echo "task-definition=./terraform/task-definition.json" >> $GITHUB_OUTPUT
          else
            echo "task-definition.json not found"
            exit 1
          fi
        working-directory: ./terraform

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ./terraform/task-definition.json
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Check ECS Service Status
        run: |
          ./terraform/check_ecs_status.sh ${{ env.ECS_CLUSTER }} ${{ env.ECS_SERVICE }}

      - name: Run Neo4j Validation Tests
        env:
          NEO4J_HOST: ${{ steps.apply.outputs.neo4j_host }}
          NEO4J_USER: ${{ secrets.NEO_4J_LEDGER_SPACE_USER }}
          NEO4J_PASSWORD: ${{ secrets.NEO_4J_LEDGER_SPACE_PASS }}
        run: |
          chmod +x ./tests/neo4j_validation.sh
          ./tests/neo4j_validation.sh

      - name: Run Post-Deployment Tests
        env:
          API_URL: ${{ steps.apply.outputs.api_url }}
        run: |
          npm install axios jest
          node .github/workflows/post_deployment_tests.js

      - name: Log deployment
        if: success()
        run: |
          echo "Deployment to development triggered by ${{ github.actor }} at $(date)" >> deployment_log.txt
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add deployment_log.txt
          git commit -m "Log deployment to development"
          git push
        working-directory: ./terraform

      - name: Notify on Failure
        if: failure()
        run: |
          echo "Deployment failed. Please check the logs for more information."
          # Add notification mechanism here (e.g., send an email, Slack message, etc.)
