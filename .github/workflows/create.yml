name: Initial Deployment to AWS

on:
  workflow_dispatch:

jobs:
  deploy:
    name: Initial AWS Deployment
    runs-on: ubuntu-latest
    env:
      # Secrets from Github Environment
      TF_VAR_neo4j_enterprise_license: ${{ secrets.NEO4J_ENTERPRISE_LICENSE }}
      TF_VAR_open_exchange_rates_api: ${{ secrets.OPEN_EXCHANGE_RATES_API }}

      # Where to deploy
      AWS_REGION: af-south-1

      # Domain config, used to assemble subdomains like
      # dev.api.mycredex.app
      TF_VAR_domain_base: mycredex.app
      TF_VAR_subdomain_development: dev.api
      TF_VAR_subdomain_staging: stage.api
      TF_VAR_subdomain_production: api

      # Neo4j instance count: Defines the number of Neo4j instances to be deployed for each environment.
      # This is compliant with the Neo4j Startup Software License Agreement, which allows:
      # - Up to 6 instances for development
      # - Up to 3 instances for non-production testing (staging)
      # - Up to 3 instances for production
      TF_VAR_neo4j_instance_count_development: 2
      TF_VAR_neo4j_instance_count_staging: 2
      TF_VAR_neo4j_instance_count_production: 2

      # Neo4j instance types: Specifies the AWS EC2 instance types for Neo4j in each environment.
      # These are chosen to comply with the 24 Cores / 256 GB RAM limit of the Neo4j license:
      # - t3.xlarge for development (4 vCPU, 16 GB RAM)
      # - r5.2xlarge for staging (8 vCPU, 64 GB RAM)
      # - r5.12xlarge for production (48 vCPU, 384 GB RAM, but will be limited to 24 cores in user_data)
      TF_VAR_neo4j_instance_type_development: t3.xlarge
      TF_VAR_neo4j_instance_type_staging: r5.2xlarge
      TF_VAR_neo4j_instance_type_production: r5.12xlarge
      
      # Log levels for different environments:
      # - debug for development to provide detailed information for troubleshooting
      # - info for staging and production to provide general operational information
      TF_VAR_log_level_development: debug
      TF_VAR_log_level_staging: info
      TF_VAR_log_level_production: info

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set environment
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/prod" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
          fi
          echo "TF_VAR_environment=$ENVIRONMENT" >> $GITHUB_ENV

      - name: Debug - Print Environment Variables
        run: |
          echo "ENVIRONMENT: ${{ env.ENVIRONMENT }}"
          echo "TF_VAR_environment: ${{ env.TF_VAR_environment }}"
          echo "AWS_REGION: ${{ env.AWS_REGION }}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Debug - Check AWS Configuration
        run: |
          aws sts get-caller-identity
          aws configure list

      - name: Generate Secrets
        run: |
          chmod +x .github/workflows/generate_secrets.sh
          ./.github/workflows/generate_secrets.sh ${{ env.ENVIRONMENT }}

      - name: Set Terraform variables
        run: |
          echo "TF_VAR_jwt_secret=${{ secrets.JWT_SECRET }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_ledger_space_user=${{ secrets.NEO_4J_LEDGER_SPACE_USER }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_ledger_space_pass=${{ secrets.NEO_4J_LEDGER_SPACE_PASS }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_search_space_user=${{ secrets.NEO_4J_SEARCH_SPACE_USER }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_search_space_pass=${{ secrets.NEO_4J_SEARCH_SPACE_PASS }}" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_public_key=${{ secrets.NEO4J_PUBLIC_KEY }}" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Pre-deployment Checks
        id: pre_deployment_checks
        run: |
          cd terraform
          
          # Function to check if a resource exists in AWS
          resource_exists() {
            local resource_type=$1
            local resource_name=$2
            
            case $resource_type in
              "aws_acm_certificate")
                aws acm list-certificates --query 'CertificateSummaryList[?DomainName==`'"$resource_name"'`].CertificateArn' --output text | grep -q .
                ;;
              "aws_security_group")
                aws ec2 describe-security-groups --filters "Name=group-name,Values=$resource_name" --query 'SecurityGroups[0].GroupId' --output text | grep -q .
                ;;
              "aws_instance")
                aws ec2 describe-instances --filters "Name=tag:Name,Values=$resource_name" "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].[InstanceId]' --output text | grep -q .
                ;;
              "aws_ecs_cluster")
                aws ecs list-clusters --query "clusterArns[?contains(@, '$resource_name')]" --output text | grep -q .
                ;;
              "aws_ecs_service")
                aws ecs list-services --cluster "credex-cluster-${{ env.ENVIRONMENT }}" --query "serviceArns[?contains(@, '$resource_name')]" --output text | grep -q .
                ;;
              "aws_lb")
                aws elbv2 describe-load-balancers --query "LoadBalancers[?LoadBalancerName=='$resource_name'].LoadBalancerArn" --output text | grep -q .
                ;;
              *)
                echo "Unknown resource type: $resource_type"
                return 1
                ;;
            esac
          }
          
          # Check for existing resources
          echo "Checking for existing resources..."
          
          if resource_exists "aws_acm_certificate" "${TF_VAR_domain_base}" || \
             resource_exists "aws_security_group" "credex-alb-sg-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_security_group" "credex-core-ecs-tasks-sg-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_security_group" "credex-neo4j-sg-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_ecs_cluster" "credex-cluster-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_ecs_service" "credex-core-service-${{ env.ENVIRONMENT }}" || \
             resource_exists "aws_lb" "credex-alb-${{ env.ENVIRONMENT }}"; then
            echo "Error: Some resources already exist. This script is intended for initial deployment only."
            exit 1
          fi
          
          # Check for Neo4j instances
          neo4j_instance_count=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=Neo4j-${{ env.ENVIRONMENT }}-*" "Name=instance-state-name,Values=running" --query 'length(Reservations[].Instances[])' --output text)
          
          if [ "$neo4j_instance_count" -gt 0 ]; then
            echo "Error: Neo4j instances already exist. This script is intended for initial deployment only."
            exit 1
          fi

      - name: Terraform Init and Workspace Selection
        run: |
          cd terraform
          terraform init
          terraform workspace select ${{ env.ENVIRONMENT }} || terraform workspace new ${{ env.ENVIRONMENT }}

      - name: Terraform Plan (Infrastructure)
        id: plan_infra
        run: |
          cd terraform
          terraform plan -out=tfplan_infra -target=module.neo4j -target=module.networking

      - name: Terraform Apply (Infrastructure)
        run: |
          cd terraform
          terraform apply -auto-approve tfplan_infra

      - name: Get Terraform Outputs
        id: tf-outputs
        run: |
          cd terraform
          echo "Retrieving Terraform outputs..."
          terraform output -json > tf_outputs.json
          echo "tf_outputs=$(cat tf_outputs.json | jq -c .)" >> $GITHUB_OUTPUT

      - name: Set Neo4j Bolt URLs
        run: |
          NEO4J_LEDGER_IP=$(echo '${{ steps.tf-outputs.outputs.tf_outputs }}' | jq -r '.neo4j_ledger_space_bolt_url.value' | sed 's|bolt://||' | sed 's|:7687||')
          NEO4J_SEARCH_IP=$(echo '${{ steps.tf-outputs.outputs.tf_outputs }}' | jq -r '.neo4j_search_space_bolt_url.value' | sed 's|bolt://||' | sed 's|:7687||')
          gh secret set NEO_4J_LEDGER_SPACE_BOLT_URL -b"bolt://${NEO4J_LEDGER_IP}:7687" --env ${{ env.ENVIRONMENT }}
          gh secret set NEO_4J_SEARCH_SPACE_BOLT_URL -b"bolt://${NEO4J_SEARCH_IP}:7687" --env ${{ env.ENVIRONMENT }}
          echo "TF_VAR_neo4j_ledger_space_bolt_url=bolt://${NEO4J_LEDGER_IP}:7687" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_search_space_bolt_url=bolt://${NEO4J_SEARCH_IP}:7687" >> $GITHUB_ENV

      - name: Terraform Plan (ECS)
        id: plan_ecs
        run: |
          cd terraform
          terraform plan -out=tfplan_ecs -target=module.ecs

      - name: Terraform Apply (ECS)
        run: |
          cd terraform
          terraform apply -auto-approve tfplan_ecs

      - name: Update ECS Task Definition
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          TASK_DEF=$(aws ecs describe-task-definition --task-definition credex-core-${{ env.ENVIRONMENT }} --query taskDefinition)
          NEW_TASK_DEF=$(echo $TASK_DEF | jq '.containerDefinitions[0].environment += [
            {"name": "NEO_4J_LEDGER_SPACE_BOLT_URL", "value": "${{ env.TF_VAR_neo4j_ledger_space_bolt_url }}"},
            {"name": "NEO_4J_SEARCH_SPACE_BOLT_URL", "value": "${{ env.TF_VAR_neo4j_search_space_bolt_url }}"},
            {"name": "NEO_4J_LEDGER_SPACE_USER", "value": "${{ env.TF_VAR_neo4j_ledger_space_user }}"},
            {"name": "NEO_4J_LEDGER_SPACE_PASS", "value": "${{ env.TF_VAR_neo4j_ledger_space_pass }}"},
            {"name": "NEO_4J_SEARCH_SPACE_USER", "value": "${{ env.TF_VAR_neo4j_search_space_user }}"},
            {"name": "NEO_4J_SEARCH_SPACE_PASS", "value": "${{ env.TF_VAR_neo4j_search_space_pass }}"},
            {"name": "JWT_SECRET", "value": "${{ env.TF_VAR_jwt_secret }}"},
            {"name": "OPEN_EXCHANGE_RATES_API", "value": "${{ env.TF_VAR_open_exchange_rates_api }}"}
          ]')
          echo $NEW_TASK_DEF > new-task-def.json
          aws ecs register-task-definition --cli-input-json file://new-task-def.json

      - name: Deploy Application
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          echo "Deploying application to ${{ env.ENVIRONMENT }} from branch ${{ github.ref_name }}"
          aws ecs update-service --cluster credex-cluster-${{ env.ENVIRONMENT }} --service credex-core-service-${{ env.ENVIRONMENT }} --task-definition credex-core-${{ env.ENVIRONMENT }}

      - name: Run Post-Deployment Tests
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          echo "Running post-deployment tests for ${{ env.ENVIRONMENT }}"
          # Add your test commands here

      - name: Log Deployment
        if: success()
        run: |
          echo "Initial deployment to ${{ env.ENVIRONMENT }} from branch ${{ github.ref_name }} completed successfully at $(date)"

      - name: Notify on Failure
        if: failure()
        run: |
          echo "Initial deployment to ${{ env.ENVIRONMENT }} from branch ${{ github.ref_name }} failed. Please check the logs for more information."
          # Add notification mechanism here (e.g., send an email, Slack message, etc.)
