Current Branch: 273-update-folder-structure
----------------------------------------
File: src/utils/__tests__/validators.test.ts
----------------------------------------
import { validateUUID, validateMemberHandle, validateAccountName, validateAccountHandle } from '../validators';

describe('Validators', () => {
  describe('validateUUID', () => {
    it('should return true for valid UUIDs', () => {
      expect(validateUUID('123e4567-e89b-12d3-a456-426614174000')).toBe(true);
      expect(validateUUID('550e8400-e29b-41d4-a716-446655440000')).toBe(true);
    });

    it('should return false for invalid UUIDs', () => {
      expect(validateUUID('not-a-uuid')).toBe(false);
      expect(validateUUID('123e4567-e89b-12d3-a456-42661417400')).toBe(false);
      expect(validateUUID('123e4567-e89b-12d3-a456-4266141740000')).toBe(false);
    });
  });

  describe('validateMemberHandle', () => {
    it('should return true for valid member handles', () => {
      expect(validateMemberHandle('john_doe')).toBe(true);
      expect(validateMemberHandle('user123')).toBe(true);
      expect(validateMemberHandle('a.b.c')).toBe(true);
    });

    it('should return false for invalid member handles', () => {
      expect(validateMemberHandle('jo')).toBe(false);
      expect(validateMemberHandle('user_name_too_long_123456789012345678901234567890')).toBe(false);
      expect(validateMemberHandle('Invalid-Handle')).toBe(false);
      expect(validateMemberHandle('user@name')).toBe(false);
    });
  });

  describe('validateAccountName', () => {
    it('should return true for valid account names', () => {
      expect(validateAccountName('John Doe')).toBe(true);
      expect(validateAccountName('Company Name 123')).toBe(true);
      expect(validateAccountName('A'.repeat(50))).toBe(true);
    });

    it('should return false for invalid account names', () => {
      expect(validateAccountName('Jo')).toBe(false);
      expect(validateAccountName('A'.repeat(51))).toBe(false);
      expect(validateAccountName('')).toBe(false);
    });
  });

  describe('validateAccountHandle', () => {
    it('should return true for valid account handles', () => {
      expect(validateAccountHandle('johndoe')).toBe(true);
      expect(validateAccountHandle('company_123')).toBe(true);
      expect(validateAccountHandle('a.b.c')).toBe(true);
    });

    it('should return false for invalid account handles', () => {
      expect(validateAccountHandle('jo')).toBe(false);
      expect(validateAccountHandle('handle_too_long_123456789012345678901234567890')).toBe(false);
      expect(validateAccountHandle('Invalid-Handle')).toBe(false);
      expect(validateAccountHandle('handle@invalid')).toBe(false);
    });
  });
});


File: src/utils/validators.ts
----------------------------------------
export function validateUUID(uuid: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}

export function validateMemberHandle(handle: string): boolean {
  const handleRegex = /^[a-z0-9._]{3,30}$/;
  return handleRegex.test(handle);
}

export function validateAccountName(name: string): boolean {
  return name.length >= 3 && name.length <= 50;
}

export function validateAccountHandle(handle: string): boolean {
  const handleRegex = /^[a-z0-9._]{3,30}$/;
  return handleRegex.test(handle);
}


File: src/utils/denomUtils.ts
----------------------------------------
import { Denomination } from '../constants/denominations';

/**
 * Formats a numerical amount according to the specified denomination.
 * @param amount - The numerical amount to format.
 * @param code - The denomination code.
 * @returns A formatted string representation of the amount.
 */
export const denomFormatter = (amount: number, code: string): string => {
  // Ensure amount is a finite number
  if (!isFinite(amount)) {
    amount = 0;
  }

  /**
   * Formats a currency amount with the specified precision and regionalization.
   * @param amount - The amount to format.
   * @param precision - The number of decimal places to round to.
   * @param regionalization - The locale string for number formatting.
   * @returns A formatted string representation of the amount.
   */
  const formatCurrencyAmount = (
    amount: number,
    precision: number,
    regionalization: string
  ): string => {
    return new Intl.NumberFormat(regionalization, {
      minimumFractionDigits: precision,
      maximumFractionDigits: precision,
    }).format(amount);
  };

  const getDenominations = (options: { code: string }): Denomination[] => {
    // This function needs to be imported from denominations.ts
    // For now, we'll just return a mock implementation
    return [{ code, regionalization: 'en-US', fulldescription: '', sourceForRate: '' }];
  };

  const denomData = getDenominations({ code });
  const regionalization =
    denomData.length > 0 ? denomData[0].regionalization : "en-US";

  let precision: number;
  switch (code) {
    case "CXX":
      precision = 3;
      break;
    case "XAU":
      precision = 4;
      break;
    default:
      precision = 2;
  }

  return formatCurrencyAmount(amount, precision, regionalization);
};


File: src/index.ts
----------------------------------------
// Import required modules and dependencies
import express from "express";
import http from "http";
import MemberRoutes from "./api/Member/memberRoutes";
import AccountRoutes from "./api/Account/accountRoutes";
import CredexRoutes from "./api/Credex/credexRoutes";
import TestRoutes from "./tests/testRoutes";
import RecurringRoutes from "./api/Avatar/recurringRoutes";
import logger, { expressLogger } from "../config/logger";
import bodyParser from "body-parser";
import startCronJobs from "./core-cron/cronJobs";
import authenticate from "../config/authenticate";
import helmet from "helmet";
import cors from "cors";
import rateLimit from "express-rate-limit";
import AdminDashboardRoutes from "./api/AdminDashboard/adminDashboardRoutes";
import { errorHandler, notFoundHandler } from "../middleware/errorHandler";
import { config } from "../config/config";
import swaggerUi from "swagger-ui-express";
import { swaggerSpec } from "../config/swagger";

// Create an Express application
export const app = express();

// Create a JSON parser middleware
const jsonParser = bodyParser.json();

// Define the API version route prefix
export const apiVersionOneRoute = "/api/v1/";

// Apply security middleware
app.use(helmet()); // Helps secure Express apps with various HTTP headers
app.use(cors()); // Enable Cross-Origin Resource Sharing (CORS)

// Apply custom logging middleware
app.use(expressLogger);

// Serve Swagger UI for API documentation
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Apply authentication middleware to all routes under the API version prefix
app.use(apiVersionOneRoute, authenticate);

// Set up rate limiting to prevent abuse
// NOTE: With all requests coming from a single WhatsApp chatbot, rate limiting might cause issues
// Consider adjusting or removing rate limiting based on your specific use case
const limiter = rateLimit({
  windowMs: config.rateLimit.windowMs, // Time window for rate limiting
  max: config.rateLimit.max, // Maximum number of requests per window
  message: "Too many requests from this IP, please try again after 15 minutes",
});
app.use(limiter);

// Start cron jobs for scheduled tasks (e.g., daily credcoin offering, minute transaction queue)
startCronJobs();

// Apply route handlers for different modules
app.use(`${apiVersionOneRoute}member`, jsonParser, MemberRoutes);
AccountRoutes(app, jsonParser);
CredexRoutes(app, jsonParser);
AdminDashboardRoutes(app, jsonParser);
RecurringRoutes(app, jsonParser);

// Conditionally apply Test routes based on deployment environment
if (config.deployment === "demo" || config.deployment === "dev") {
  TestRoutes(app, jsonParser);
}

// Apply error handling middleware
app.use(notFoundHandler); // Handle 404 errors
app.use(errorHandler); // Handle all other errors

// Create HTTP server
const server = http.createServer(app);

// Start the server
if (require.main === module) {
  server.listen(config.port, () => {
    logger.info(`Server is running on http://localhost:${config.port}`);
    logger.info(
      `API documentation available at http://localhost:${config.port}/api-docs`
    );
    logger.info(`Server started at ${new Date().toISOString()}`);
    logger.info(`Environment: ${config.nodeEnv}`);
    logger.info(`Deployment type: ${config.deployment}`);
  });
}

// Handle uncaught exceptions
process.on("uncaughtException", (error) => {
  logger.error("Uncaught Exception:", error);
  // Perform any necessary cleanup
  // TODO: Implement a more robust error reporting mechanism (e.g., send to a monitoring service)
  // Gracefully shut down the server
  server.close(() => {
    logger.info("Server closed due to uncaught exception");
    process.exit(1);
  });
});

// Handle unhandled rejections
process.on("unhandledRejection", (reason, promise) => {
  logger.error("Unhandled Rejection at:", promise, "reason:", reason);
  // Perform any necessary cleanup
  // TODO: Implement a more robust error reporting mechanism (e.g., send to a monitoring service)
});

// Implement graceful shutdown
process.on("SIGTERM", () => {
  logger.info("SIGTERM signal received: closing HTTP server");
  server.close(() => {
    logger.info("HTTP server closed");
    // Perform any additional cleanup (e.g., close database connections)
    process.exit(0);
  });
});



File: src/constants/accountTypes.ts
----------------------------------------
export const accountTypes = ["PERSONAL_CONSUMPTION", "BUSINESS", "CREDEX_FOUNDATION"];

export function checkPermittedAccountType(credexTypeToCheck: string): boolean {
  return accountTypes.includes(credexTypeToCheck);
}


File: src/constants/denominations.ts
----------------------------------------
import { filter } from "lodash";

/**
 * Options for querying denominations.
 */
type DenomOptions = {
  code?: string;
  sourceForRate?: string;
  formatAsList?: boolean;
};

/**
 * Represents a currency denomination.
 */
export type Denomination = {
  code: string;
  fulldescription: string;
  regionalization: string;
  sourceForRate: string;
};

/**
 * Array of supported denominations in the Credex system.
 */
const denominations: Denomination[] = [
  {
    code: "CXX",
    fulldescription: "CXX (Credcoin)",
    regionalization: "en-CA",
    sourceForRate: "DCO",
  },
  {
    code: "CAD",
    fulldescription: "CAD (Canadian Dollars)",
    regionalization: "en-CA",
    sourceForRate: "OpenExchangeRates",
  },
  {
    code: "USD",
    fulldescription: "USD (United States Dollars)",
    regionalization: "en-US",
    sourceForRate: "OpenExchangeRates",
  },
  {
    code: "XAU",
    fulldescription: "XAU (Troy Gold Ounces)",
    regionalization: "en-CA",
    sourceForRate: "OpenExchangeRates",
  },
  {
    code: "ZIG",
    fulldescription: "ZIG (Zimbabwe Gold Official Rate)",
    regionalization: "en-CA",
    sourceForRate: "RBZ",
  },
];

/**
 * Retrieves denominations based on provided options.
 * @param options - Options for filtering denominations.
 * @returns An array of Denomination objects or a comma-separated string of denomination codes.
 */
export function getDenominations(
  options: DenomOptions
): string | Denomination[] {
  let result = denominations;

  if (options.code) {
    result = result.filter((denom) => denom.code === options.code);
  }

  if (options.sourceForRate) {
    result = result.filter(
      (denom) => denom.sourceForRate === options.sourceForRate
    );
  }

  if (options.formatAsList) {
    return result.map((denom) => denom.code).join(",");
  }

  return result;
}

/**
 * Retrieves the full description of a denomination by its code.
 * @param code - The denomination code.
 * @returns The full description of the denomination, or undefined if not found.
 */
export const getFullDescription = (code: string): string | undefined => {
  const denom = denominations.find((d) => d.code === code);
  return denom?.fulldescription;
};

/**
 * Checks if a given code is a valid denomination.
 * @param code - The denomination code to check.
 * @returns True if the code is a valid denomination, false otherwise.
 */
export const isValidDenomination = (code: string): boolean => {
  return denominations.some((d) => d.code === code);
};


File: src/constants/credspan.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../config/neo4j";
import moment from "moment-timezone";

export const credspan = 35;

export async function checkDueDate(dueDate: any): Promise<boolean> {
  const dueDateMoment = moment.utc(dueDate, "YYYY-MM-DD", true);
  if (!dueDateMoment.isValid()) {
    console.error("Due date not in valid format");
    return false;
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const currentDateQuery = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      RETURN daynode.Date AS today
    `);
  const today = currentDateQuery.records[0].get("today");
  if (!today) {
    console.log("could not get date from daynode");
    return false;
  }
  const lastPermittedDayMoment = moment(today)
    .subtract(1, "months") // because of diff date formats
    .add(credspan, "days");
  const firstPermittedDayMoment = moment(today)
    .subtract(1, "months") // because of diff date formats
    .add(7, "days");
  if (
    dueDateMoment >= lastPermittedDayMoment ||
    dueDateMoment < firstPermittedDayMoment
  ) {
    console.error("Due date is not within permitted credspan");
    return false;
  }
  return true;
}


File: src/constants/credexTypes.ts
----------------------------------------
export const credexTypes = [
  "PURCHASE",
  "GIFT",
  "DCO_GIVE",
  "DCO_RECEIVE"
];

export function checkPermittedCredexType(credexTypeToCheck: string): boolean {
  return credexTypes.includes(credexTypeToCheck);
}


File: src/tests/controllers/createTestMembersAndAccounts.ts
----------------------------------------
import express from "express";
import { CreateTestMembersAndAccountsService } from "../services/CreateTestMembersAndAccounts";

export async function CreateTestMembersAndAccountsController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewAccounts is provided in the request body
  if (!req.body.numNewAccounts) {
    return res.status(400).json({ message: "numNewAccounts is required" });
  }

  try {
    // Call the service to create test accounts
    const responseData = await CreateTestMembersAndAccountsService(
      req.body.numNewAccounts
    );

    // Send the response with the created test accounts
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test accounts:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: src/tests/controllers/offerAndAcceptCredex.ts
----------------------------------------
import express from "express";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";

export async function OfferAndAcceptCredexController(
  req: express.Request,
  res: express.Response
) {
  try {
    /*
    const responseDataOffer = await OfferCredexService(req.body);
    if (typeof responseDataOffer.credex == "boolean") {
      throw new Error("Invalid response from OfferCredexService");
    }
    if (
      responseDataOffer.credex &&
      typeof responseDataOffer.credex.credexID === "string"
    ) {
      const responseDataAccept = await AcceptCredexService(
        responseDataOffer.credex.credexID
      );
      if (responseDataAccept) {
        res.json(responseDataAccept.acceptedCredexID);
      }
    } else {
      res.status(500).json(responseDataOffer.message);
    }
      */
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: src/tests/controllers/forceDCO.ts
----------------------------------------
import express from "express";
import { DailyCredcoinOffering } from "../../core-cron/DCO/DailyCredcoinOffering";

export async function ForceDcoController(
  req: express.Request,
  res: express.Response
) {
  try {
    const responseData = await DailyCredcoinOffering();
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: src/tests/controllers/createRandomFloatingCredexes.ts
----------------------------------------
import express from "express";
import { CreateRandomFloatingCredexesService } from "../services/CreateRandomFloatingCredexes";

export async function CreateRandomFloatingCredexesController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewTransactions is provided in the request body
  if (!req.body.numNewTransactions) {
    return res.status(400).json({ message: "numNewTransactions is required" });
  }

  try {
    // Call the service to create test transactions
    const responseData = await CreateRandomFloatingCredexesService(
      req.body.numNewTransactions
    );

    // Send the response with the created test transactions
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test transactions:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: src/tests/controllers/growthTest.ts
----------------------------------------
import express from "express";
import { GrowthTestService } from "../services/GrowthTest";

export async function GrowthTestController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = [
    "numberDays",
    "accountGrowthRate",
    "USD_SECURED_fractionToPurchase",
    "USD_SECURED_amountPerPurchaseLow",
    "USD_SECURED_amountPerPurchaseHigh",
    "USD_SECURED_fractionToSell",
    "ZIG_SECURED_fractionToPurchase",
    "ZIG_SECURED_amountPerPurchaseLow",
    "ZIG_SECURED_amountPerPurchaseHigh",
    "ZIG_SECURED_fractionToSell",
    "dailyFloatingRandomTransactionsPerAccount",
  ];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }
  try {
    const responseData = await GrowthTestService(req.body);
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error in growthTest:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: src/tests/controllers/clearDevDb.ts
----------------------------------------
import express from "express";
import { ClearDevDbService } from "../services/ClearDevDb";

export async function ClearDevDbController(
  req: express.Request,
  res: express.Response,
) {
  try {
    // Call the service to clear the development database
    await ClearDevDbService();

    // Send a success response
    res
      .status(200)
      .json({ message: "Development databases cleared successfully" });
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error clearing development databases:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: src/tests/controllers/checkLedgerVsSearchBalances.ts
----------------------------------------
import express from "express";
import { CheckLedgerVsSearchBalances } from "../services/CheckLedgerVsSearchBalances";

export async function CheckLedgerVsSearchBalancesController(
  _req: express.Request,
  res: express.Response
) {
  try {
    const balanceCheck = await CheckLedgerVsSearchBalances();

    // Send a success response
    res.status(200).json({ balanceCheck });
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error checking balances:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: src/tests/controllers/forceMTQ.ts
----------------------------------------
import express from "express";
import { MinuteTransactionQueue } from "../../core-cron/MTQ/MinuteTransactionQueue";

export async function ForceMtqController(
  req: express.Request,
  res: express.Response
) {
  try {
    const responseData = await MinuteTransactionQueue();
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: src/tests/controllers/createTestLoop.ts
----------------------------------------
import express from "express";
import { CreateTestLoopService } from "../services/CreateTestLoop";

export async function CreateTestLoopController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewTransactions is provided in the request body
  if (!req.body.numNewTransactions) {
    return res.status(400).json({ message: "numNewTransactions is required" });
  }

  try {
    // Call the service to create test transactions
    const responseData = await CreateTestLoopService(
      req.body.numNewTransactions
    );

    // Send the response with the created test transactions
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test transactions:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: src/tests/testDenomFormatter.ts
----------------------------------------
import { denomFormatter } from '../utils/denomUtils';

console.log('Testing denomFormatter function:');

console.log('USD test:', denomFormatter(1234.56, 'USD') === '1,234.56' ? 'PASS' : 'FAIL');
console.log('CXX test:', denomFormatter(1234.567, 'CXX') === '1,234.567' ? 'PASS' : 'FAIL');
console.log('XAU test:', denomFormatter(1234.5678, 'XAU') === '1,234.5678' ? 'PASS' : 'FAIL');
console.log('Negative number test:', denomFormatter(-1234.56, 'USD') === '-1,234.56' ? 'PASS' : 'FAIL');
console.log('Zero test:', denomFormatter(0, 'USD') === '0.00' ? 'PASS' : 'FAIL');

console.log('\nActual outputs:');
console.log('USD:', denomFormatter(1234.56, 'USD'));
console.log('CXX:', denomFormatter(1234.567, 'CXX'));
console.log('XAU:', denomFormatter(1234.5678, 'XAU'));
console.log('Negative:', denomFormatter(-1234.56, 'USD'));
console.log('Zero:', denomFormatter(0, 'USD'));


File: src/tests/testRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { ClearDevDbController } from "./controllers/clearDevDb";
import { ForceDcoController } from "./controllers/forceDCO";
import { ForceMtqController } from "./controllers/forceMTQ";
import { OfferAndAcceptCredexController } from "./controllers/offerAndAcceptCredex";
import { CreateTestMembersAndAccountsController } from "./controllers/createTestMembersAndAccounts";
import { CreateRandomFloatingCredexesController } from "./controllers/createRandomFloatingCredexes";
import { CreateTestLoopController } from "./controllers/createTestLoop";
import { GrowthTestController } from "./controllers/growthTest";
import { CheckLedgerVsSearchBalancesController } from "./controllers/checkLedgerVsSearchBalances";

export default function TestRoutes(app: express.Application, jsonParser: any) {
    app.delete(
      `${apiVersionOneRoute}clearDevDB`,
      jsonParser,
      ClearDevDbController
    );

    app.post(`${apiVersionOneRoute}forceDCO`, jsonParser, ForceDcoController);
    app.post(`${apiVersionOneRoute}forceMTQ`, jsonParser, ForceMtqController);

    app.post(
      `${apiVersionOneRoute}offerAndAcceptCredex`,
      jsonParser,
      OfferAndAcceptCredexController
    );

    app.post(
      `${apiVersionOneRoute}createTestMembersAndAccounts`,
      jsonParser,
      CreateTestMembersAndAccountsController
    );

    app.post(
      `${apiVersionOneRoute}createRandomFloatingCredexes`,
      jsonParser,
      CreateRandomFloatingCredexesController
    );

    app.post(
      `${apiVersionOneRoute}createTestLoop`,
      jsonParser,
      CreateTestLoopController
    );

    app.post(
      `${apiVersionOneRoute}growthTest`,
      jsonParser,
      GrowthTestController
    );

    app.get(
      `${apiVersionOneRoute}checkLedgerVsSearchBalances`,
      jsonParser,
      CheckLedgerVsSearchBalancesController
    );
}



File: src/tests/services/InEcosystemSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";
import { GetSecuredAuthorizationService } from "../../api/Credex/services/GetSecuredAuthorization";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function InEcosystemSecuredCredexesService(
  denom: string,
  number: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Creating in-ecosystem ${denom} secured credexes: ${number}`);

  try {
    if (number > 0) {
      const result = await ledgerSpaceSession.run(
        `
        MATCH
          (issuer:Account)<-[transactionType:OWES]-
          (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH
          (issuer)-[transactionType:OWES]->
          (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
        WITH
          issuer,
          sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
        WHERE netIn > 0
        WITH
          issuer.accountID AS issuerAccountID
        ORDER BY rand() 
        LIMIT $number
        WITH collect(issuerAccountID) AS issuerAccountIDs
        UNWIND issuerAccountIDs AS issuerAccountID
        MATCH (randomCounterparty:Account)
        WHERE randomCounterparty.accountID <> issuerAccountID
        WITH issuerAccountID, randomCounterparty.accountID AS receiverAccountID
        ORDER BY rand()
        RETURN issuerAccountID, receiverAccountID
        LIMIT $number
        `,
        {
          number: neo4j.int(number),
          denom,
        }
      );

      if (result.records.length === 0) {
        console.log("No records found for circulation.");
        return;
      }

      const batchSize = 3;
      const records = result.records;

      for (let i = 0; i < records.length; i += batchSize) {
        const batch = records.slice(i, i + batchSize);

        const offerPromises = batch.map(async (record) => {
          const issuerAccountID: string = record.get("issuerAccountID");
          const receiverAccountID: string = record.get("receiverAccountID");

          try {
            const securableData = await GetSecuredAuthorizationService(
              issuerAccountID,
              denom
            );

            const maxSecurable = securableData.securableAmountInDenom;
            let InitialAmount;
            if (maxSecurable >= 1) {
              InitialAmount = random(maxSecurable);
            } else {
              InitialAmount = random(0.1, maxSecurable);
            }
            console.log("random initialAmount: " + InitialAmount);

            const credexSpecs = {
              issuerAccountID: issuerAccountID,
              receiverAccountID: receiverAccountID,
              Denomination: denom,
              InitialAmount: InitialAmount,
              credexType: "PURCHASE",
              securedCredex: true,
            };

            const newcredex = await OfferCredexService(credexSpecs);

            if (
              typeof newcredex.credex === "boolean" ||
              !newcredex.credex?.credexID
            ) {
              throw new Error("Invalid response from OfferCredexService");
            }

            await AcceptCredexService(newcredex.credex.credexID);
          } catch (error) {
            console.error("Error processing credex offer:", error);
            // Handle error as needed
          }
        });

        await Promise.all(offerPromises);
      }
    }
  } catch (error) {
    console.error("Error in InEcosystemSecuredCredexesService:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
*/
}



File: src/tests/services/SellSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";
import { GetSecuredAuthorizationService } from "../../api/Credex/services/GetSecuredAuthorization";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function SellSecuredCredexesService(
  denom: string,
  number: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Selling ${denom} secured credexes for cash: ${number}`);

  try {
    if (number > 0) {
      const result = await ledgerSpaceSession.run(
        `
        MATCH
          (issuer:Account)<-[transactionType:OWES]-
          (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH
          (issuer)-[transactionType:OWES]->
          (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
        WITH
          issuer, securer,
          sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
        WHERE netIn > 0
        RETURN
          issuer.accountID AS issuerAccountID,
          securer.accountID AS receiverAccountID
          ORDER BY rand() LIMIT $number;
        `,
        {
          number: neo4j.int(number),
          denom,
        }
      );

      if (result.records.length === 0) {
        console.log("No records found for selling secured credexes.");
        return;
      }

      const batchSize = 3;
      const records = result.records;

      for (let i = 0; i < records.length; i += batchSize) {
        const batch = records.slice(i, i + batchSize);

        const offerPromises = batch.map(async (record) => {
          const issuerAccountID: string = record.get("issuerAccountID");
          const receiverAccountID: string = record.get("receiverAccountID");

          try {
            const securableData = await GetSecuredAuthorizationService(
              issuerAccountID,
              denom
            );

            const InitialAmount = random(
              1,
              securableData.securableAmountInDenom || 1
            );

            const credexSpecs = {
              issuerAccountID: issuerAccountID,
              receiverAccountID: receiverAccountID,
              Denomination: denom,
              InitialAmount: InitialAmount,
              credexType: "PURCHASE",
              securedCredex: true,
            };

            const newcredex = await OfferCredexService(credexSpecs);

            if (
              typeof newcredex.credex === "boolean" ||
              !newcredex.credex?.credexID
            ) {
              throw new Error("Invalid response from OfferCredexService");
            }

            await AcceptCredexService(newcredex.credex.credexID);
          } catch (error) {
            console.error("Error processing credex offer:", error);
            // Handle error as needed
          }
        });

        await Promise.all(offerPromises);
      }
    }
  } catch (error) {
    console.error("Error in SellSecuredCredexesService:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
  */
}



File: src/tests/services/CheckLedgerVsSearchBalances.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";

export async function CheckLedgerVsSearchBalances() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    // Query ledgerSpace for credex data
    const ledgerSpaceCredexesQuery = await ledgerSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDledger,
        credex.OutstandingAmount AS OutstandingAmountLedger
    `);

    // Query searchSpace for credex data
    const searchSpaceCredexesQuery = await searchSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDsearch,
        credex.outstandingAmount AS OutstandingAmountSearch
    `);

    // Process ledgerSpace results
    const ledgerSpaceCredexes = ledgerSpaceCredexesQuery.records.map(
      (record) => ({
        credexID: record.get("credexIDledger"),
        OutstandingAmount: record.get("OutstandingAmountLedger"),
      })
    );

    // Process searchSpace results
    const searchSpaceCredexes = searchSpaceCredexesQuery.records.map(
      (record) => ({
        credexID: record.get("credexIDsearch"),
        OutstandingAmount: record.get("OutstandingAmountSearch"),
      })
    );

    // Create a map for quick lookup from searchSpace
    const searchSpaceCredexMap = new Map(
      searchSpaceCredexes.map((credex) => [
        credex.credexID,
        credex.OutstandingAmount,
      ])
    );

    // Compare and analyze the data
    let matchingCount = 0;
    const mismatchedCredexes = [];

    for (const ledgerCredex of ledgerSpaceCredexes) {
      const searchOutstandingAmount = searchSpaceCredexMap.get(
        ledgerCredex.credexID
      );

      // If the credex does not exist in searchSpace and the amount in ledgerSpace is 0, count as a match
      if (
        searchOutstandingAmount === undefined &&
        ledgerCredex.OutstandingAmount === 0
      ) {
        matchingCount++;
      } else if (ledgerCredex.OutstandingAmount === searchOutstandingAmount) {
        matchingCount++;
      } else {
        mismatchedCredexes.push({
          credexID: ledgerCredex.credexID,
          OutstandingAmountLedger: ledgerCredex.OutstandingAmount,
          OutstandingAmountSearch: searchOutstandingAmount || 0,
        });
      }
    }

    // Return the results
    return {
      matchingCount,
      mismatchedCredexes,
    };
  } catch (error) {
    console.error("An error occurred during the execution:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}



File: src/tests/services/GrowthTest.ts
----------------------------------------
import { CreateTestMembersAndAccountsService } from "./CreateTestMembersAndAccounts";
import { CreateRandomFloatingCredexesService } from "./CreateRandomFloatingCredexes";
import { DailyCredcoinOffering } from "../../core-cron/DCO/DailyCredcoinOffering";
import { MinuteTransactionQueue } from "../../core-cron/MTQ/MinuteTransactionQueue";
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { PurchaseSecuredCredexesService } from "./PurchaseSecuredCredexes";
import { SellSecuredCredexesService } from "./SellSecuredCredexes";
import { InEcosystemSecuredCredexesService } from "./InEcosystemSecuredCredexes";

export async function GrowthTestService(variables: any) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    // Get current number of accounts
    const numberAccountsQuery = await ledgerSpaceSession.run(`
      MATCH (account:Account)
      RETURN count(account) AS numberAccounts
    `);
    let numberAccounts = parseFloat(
      numberAccountsQuery.records[0].get("numberAccounts")
    );

    for (let index = 0; index < variables.numberDays; index++) {
      let numberNewAccounts = Math.round(
        numberAccounts * variables.accountGrowthRate
      );
      if (numberNewAccounts < 1) {
        numberNewAccounts = 1;
      }

      console.log(`Day ${index + 1}`);
      console.log(`Current number of accounts: ${numberAccounts}`);
      console.log(`Creating new accounts: ${numberNewAccounts}`);
      numberAccounts += numberNewAccounts;

      await CreateTestMembersAndAccountsService(numberNewAccounts);

      const numberUSDpurchases = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToPurchase
      );
      await PurchaseSecuredCredexesService(
        "USD",
        numberUSDpurchases,
        variables.USD_SECURED_amountPerPurchaseLow,
        variables.USD_SECURED_amountPerPurchaseHigh
      );

      const numberUSDsecuredCirculate = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToCirculate
      );
      await InEcosystemSecuredCredexesService("USD", numberUSDsecuredCirculate);

      const numberUSDsales = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToSell
      );
      await SellSecuredCredexesService("USD", numberUSDsales);

      const numberZIGpurchases = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToPurchase
      );
      await PurchaseSecuredCredexesService(
        "ZIG",
        numberZIGpurchases,
        variables.ZIG_SECURED_amountPerPurchaseLow,
        variables.ZIG_SECURED_amountPerPurchaseHigh
      );

      const numberZIGsecuredCirculate = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToCirculate
      );
      await InEcosystemSecuredCredexesService("ZIG", numberZIGsecuredCirculate);

      const numberZIGsales = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToSell
      );
      await SellSecuredCredexesService("ZIG", numberZIGsales);

      const numberRandomFloatingTransactions = Math.round(
        numberAccounts * variables.dailyFloatingRandomTransactionsPerAccount
      );
      console.log(
        `Creating random floating credexes: ${numberRandomFloatingTransactions}`
      );
      if (numberRandomFloatingTransactions > 0) {
        await CreateRandomFloatingCredexesService(
          numberRandomFloatingTransactions
        );
      }

      await DailyCredcoinOffering();
      await MinuteTransactionQueue();
    }

    console.log("This run of GrowthTestService is complete");
  } catch (error) {
    console.error(
      "An error occurred during the GrowthTestService execution:",
      error
    );
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/tests/services/PurchaseSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function PurchaseSecuredCredexesService(
  denom: string,
  number: number,
  lowValue: number,
  highValue: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Purchasing ${denom} secured credexes: ${number}`);

  if (number > 0) {
    const getSecuredUSDCounterparties = await ledgerSpaceSession.run(
      `
        // Step 1: Select a random audited account
        MATCH (auditedAccount:Account)<-[:CREDEX_FOUNDATION_AUDITED]-(foundation:Account)
        WITH auditedAccount, rand() AS rand
        ORDER BY rand LIMIT 1

        // Step 2: Collect account IDs for purchasers
        MATCH (accounts:Account)
        WHERE accounts.accountID <> auditedAccount.accountID
        WITH auditedAccount, collect(accounts.accountID) AS allaccounts
        RETURN auditedAccount.accountID AS auditedID, allaccounts[0..$number] AS accountsToPurchaseUSDsecured
      `,
      {
        number: neo4j.int(number),
      }
    );

    const issuerAccountID =
      getSecuredUSDCounterparties.records[0].get("auditedID");
    const accountsToPurchaseUSDsecured =
      getSecuredUSDCounterparties.records[0].get(
        "accountsToPurchaseUSDsecured"
      );

    const batchSize = 3;

    for (let i = 0; i < accountsToPurchaseUSDsecured.length; i += batchSize) {
      const batch = accountsToPurchaseUSDsecured.slice(i, i + batchSize);

      const offerPromises = batch.map((receiverAccountID: string) => {
        const InitialAmount = random(lowValue, highValue);

        const credexSpecs = {
          issuerAccountID: issuerAccountID,
          receiverAccountID: receiverAccountID,
          Denomination: denom,
          InitialAmount: InitialAmount,
          credexType: "PURCHASE",
          securedCredex: true,
        };

        return OfferCredexService(credexSpecs);
      });

      const offerCredexArray = await Promise.all(offerPromises);

      const acceptPromises = offerCredexArray.map((newcredex) => {
        if (typeof newcredex.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
          return AcceptCredexService(newcredex.credex.credexID);
        } else {
          return Promise.reject(newcredex.message);
        }
      });

      await Promise.all(acceptPromises);
    }
  }

  await ledgerSpaceSession.close();
  */
}



File: src/tests/services/CreateTestMembersAndAccounts.ts
----------------------------------------
import axios from "axios";
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OnboardMemberService } from "../../api/Member/services/OnboardMember";
import { CreateAccountService } from "../../api/Account/services/CreateAccount";
import { random } from "lodash";

export async function CreateTestMembersAndAccountsService(numNewAccounts: number) {
  const batchSize = 3; // Size of each batch

  const numNewMembers = Math.round(numNewAccounts * 0.75)
  const numNewAccountsForExisting = numNewAccounts - numNewMembers;

  const memberPromises = [];
  for (let i = 0; i < numNewMembers; i++) {
    memberPromises.push(
      (async () => {
        // Fetch a new name for each iteration
        
        // comment out when daily limit reached        
        const nameObject = await axios.get(
          "https://api.parser.name/?api_key=f30409d63186d13cfa335a40e14dcd17&endpoint=generate"
        );
        const firstname = nameObject.data.data[0].name.firstname.name_ascii;
        const lastname = nameObject.data.data[0].name.lastname.name_ascii;
        /*
        // comment out when name coming from query above
        const randomNum1 = random(100, 999);
        const randomNum2 = random(100, 999);
        const firstname = "first" + randomNum1;
        const lastname = "last" + randomNum2;
        */
        const phone = "263" + Math.floor(100000000 + Math.random() * 900000000);
        // need to check if phone unique here and generate new if not

        const onboardedMember = await OnboardMemberService(
          firstname,
          lastname,
          phone
        );
        if (!onboardedMember.onboardedMemberID) {
          throw new Error("member could not be onboarded");
        }

        const consumptionAccount = await CreateAccountService(
          onboardedMember.onboardedMemberID,
          "PERSONAL_CONSUMPTION",
          `${firstname} ${lastname} Personal`,
          `${firstname}_${lastname}`,
          "USD"
        );

        if (!consumptionAccount.accountID) {
          console.log(consumptionAccount.message);
          throw new Error("new consumption account could not be created");
        }

        return {
          onboardedMemberID: onboardedMember.onboardedMemberID,
          consumptionAccountID: consumptionAccount.accountID,
        };
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewMembers - 1) {
      await Promise.all(memberPromises);
      memberPromises.length = 0; // Clear the array for the next batch
    }
  }

  const accountPromises = [];
  for (let i = 0; i < numNewAccountsForExisting; i++) {
    accountPromises.push(
      (async () => {
        var ledgerSpaceSession = ledgerSpaceDriver.session();
        const getRandomMemberQuery = await ledgerSpaceSession.run(`
          MATCH (members:Member)
          WITH members.memberID AS memberID, rand() AS rand
          ORDER BY rand LIMIT 1
          RETURN memberID
        `);
        await ledgerSpaceSession.close();

        const ownerID = getRandomMemberQuery.records[0].get("memberID");
        const businessName = "biz" + random(100000, 999999);

        const newAccount = await CreateAccountService(
          ownerID,
          "BUSINESS",
          businessName,
          businessName,
          "USD"
        );

        if (!newAccount.accountID) {
          console.log(newAccount.message);
          throw new Error("new account could not be created");
        }
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewAccountsForExisting - 1) {
      await Promise.all(accountPromises);
      accountPromises.length = 0; // Clear the array for the next batch
    }
  }
  return true;
}



File: src/tests/services/CreateRandomFloatingCredexes.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";
import { random } from "lodash";
import moment from "moment-timezone";

async function getDateAndRandCounterparties() {
  var ledgerSpaceSession = ledgerSpaceDriver.session();
  const getDateAndRandomCounterpartiesQuery = await ledgerSpaceSession.run(`
    MATCH (accounts1:Account)
    WITH accounts1, rand() AS rand1
    ORDER BY rand1
    WITH accounts1.accountID AS accountID_1 LIMIT 1
    MATCH (accounts2:Account)
    WHERE accounts2.accountID <> accountID_1
    WITH accountID_1, accounts2, rand() AS rand2
    ORDER BY rand2
    WITH accountID_1, accounts2.accountID AS accountID_2 LIMIT 1
    MATCH (daynode:Daynode{Active:true})
    RETURN daynode.Date AS date, accountID_1, accountID_2
  `);

  await ledgerSpaceSession.close();

  return {
    accountID_1:
      getDateAndRandomCounterpartiesQuery.records[0].get("accountID_1"),
    accountID_2:
      getDateAndRandomCounterpartiesQuery.records[0].get("accountID_2"),
    date: getDateAndRandomCounterpartiesQuery.records[0].get("date"),
  };
}

export async function CreateRandomFloatingCredexesService(
  numNewTransactions: number
) {
  /*
  const credexesCreated = [];
  const batchSize = 3;
  const transactionPromises = [];

  for (let i = 0; i < numNewTransactions; i++) {
    transactionPromises.push(
      (async () => {
        const dateAndCounterparties = await getDateAndRandCounterparties();
        const date = dateAndCounterparties.date;
        const issuerAccountID = dateAndCounterparties.accountID_1;
        const receiverAccountID = dateAndCounterparties.accountID_2;
        const InitialAmount = random(1, 100);
        const Denomination = InitialAmount < 80 ? "USD" : "ZIG";

        // floating credex due in 8-34 days
        const credspanDays = random(8, 34);
        const dueDate = moment(date)
          .subtract(1, "months")
          .add(credspanDays, "days")
          .format("YYYY-MM-DD");

        const credexSpecs = {
          issuerAccountID: issuerAccountID,
          receiverAccountID: receiverAccountID,
          Denomination: Denomination,
          InitialAmount: InitialAmount,
          credexType: "PURCHASE",
          dueDate: dueDate,
          securedCredex: false,
        };

        const newcredex = await OfferCredexService(credexSpecs);
        if (typeof newcredex.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
          const credexCreatedData = await AcceptCredexService(
            newcredex.credex.credexID
          );
          return credexCreatedData;
        } else {
          return newcredex.message;
        }
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewTransactions - 1) {
      const batchResults = await Promise.all(transactionPromises);
      credexesCreated.push(
        ...batchResults.filter((result) => result !== undefined)
      );
      transactionPromises.length = 0; // Clear the array for the next batch
    }
  }

  console.log(`${numNewTransactions} new floating transactions created`);
  return credexesCreated;
  */
}



File: src/tests/services/CreateTestLoop.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";
import { random } from "lodash";
import moment from "moment-timezone";
import * as neo4j from "neo4j-driver";

export async function CreateTestLoopService(numNewTransactions: number) {
  /*
  var ledgerSpaceSession = ledgerSpaceDriver.session();
  const getRandomCounterpartiesQuery = await ledgerSpaceSession.run(
    `
      MATCH (account:Account)
      WITH account, rand() AS rand1
      ORDER BY rand1
      RETURN account.accountID AS accountID LIMIT $numNewTransactions
    `,
    {
      numNewTransactions: neo4j.int(numNewTransactions),
    }
  );

  const getDaynodeDate = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.Date AS today
  `);
  const today = getDaynodeDate.records[0].get("today");

  let credexesCreated = [];
  // Iterate numNewTransactions times
  for (let i = 0; i < numNewTransactions; i++) {
    const issuerAccountID =
      getRandomCounterpartiesQuery.records[i].get("accountID");

    let receiverAccountID;
    if (getRandomCounterpartiesQuery.records[i + 1]) {
      receiverAccountID =
        getRandomCounterpartiesQuery.records[i + 1].get("accountID");
    } else {
      receiverAccountID =
        getRandomCounterpartiesQuery.records[0].get("accountID");
    }

    const credexSpecs = {
      issuerAccountID: issuerAccountID,
      receiverAccountID: receiverAccountID,
      Denomination: "USD",
      InitialAmount: random(1, 100),
      credexType: "PURCHASE",
      //securedCredex: true,
      dueDate: moment(today)
        .utc()
        .add(8, "days")
        .subtract(1, "month")
        .format("YYYY-MM-DD"),
    };

    console.log(
      "Amount: " + credexSpecs.InitialAmount + " " + credexSpecs.Denomination
    );
    const newcredex = await OfferCredexService(credexSpecs);
    if (typeof newcredex.credex == "boolean") {
      throw new Error("Invalid response from OfferCredexService");
    }
    if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
      const credexCreatedData = await AcceptCredexService(
        newcredex.credex.credexID
      );
      credexesCreated.push(credexCreatedData);
    } else {
      return newcredex.message;
    }
  }
  console.log(numNewTransactions + " new transactions created");
  return credexesCreated;
  */
}



File: src/tests/services/ClearDevDb.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";

export async function ClearDevDbService() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();
  await ledgerSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
  await searchSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
  await ledgerSpaceSession.close();
  await searchSpaceSession.close();

  //check success first
  console.log("LedgerSpace and SearchSpace DBs cleared");
  return true;
}



File: src/tests/integration/account.test.ts
----------------------------------------
import request from 'supertest';
import { app } from '../../index'; // Adjust this import based on your app structure
import { ledgerSpaceDriver } from '../../../config/neo4j';

describe('Account API Integration Tests', () => {
  beforeAll(async () => {
    // Set up any necessary test data
  });

  afterAll(async () => {
    // Clean up test data and close connections
    await ledgerSpaceDriver.close();
  });

  describe('POST /api/v1/createAccount', () => {
    it('should create a new account with valid input', async () => {
      const response = await request(app)
        .post('/api/v1/createAccount')
        .send({
          ownerID: '123e4567-e89b-12d3-a456-426614174000',
          accountType: 'PERSONAL_CONSUMPTION',
          accountName: 'Test Account',
          accountHandle: 'test_account',
          defaultDenom: 'USD'
        });

      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('accountID');
    });

    it('should return 400 with invalid input', async () => {
      const response = await request(app)
        .post('/api/v1/createAccount')
        .send({
          ownerID: 'invalid-uuid',
          accountType: 'INVALID_TYPE',
          accountName: 'T', // Too short
          accountHandle: 'invalid handle',
          defaultDenom: 'INVALID_DENOM'
        });

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('message');
    });
  });

  describe('PATCH /api/v1/updateAccount', () => {
    it('should update an account with valid input', async () => {
      const response = await request(app)
        .patch('/api/v1/updateAccount')
        .send({
          ownerID: '123e4567-e89b-12d3-a456-426614174000',
          accountID: '123e4567-e89b-12d3-a456-426614174001',
          accountName: 'Updated Account Name',
          accountHandle: 'updated_handle'
        });

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('message', 'Account updated successfully');
    });

    it('should return 400 with invalid input', async () => {
      const response = await request(app)
        .patch('/api/v1/updateAccount')
        .send({
          ownerID: 'invalid-uuid',
          accountID: 'invalid-uuid',
          accountName: 'A', // Too short
          accountHandle: 'invalid handle'
        });

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('message');
    });
  });

  // Add more test cases for other account-related endpoints
});


File: src/tests/denomUtils.test.ts
----------------------------------------
import { denomFormatter } from '../utils/denomUtils';

describe('denomFormatter', () => {
  test('formats USD correctly', () => {
    expect(denomFormatter(1234.56, 'USD')).toBe('1,234.56');
  });

  test('formats CXX correctly', () => {
    expect(denomFormatter(1234.567, 'CXX')).toBe('1,234.567');
  });

  test('formats XAU correctly', () => {
    expect(denomFormatter(1234.5678, 'XAU')).toBe('1,234.5678');
  });

  test('handles negative numbers', () => {
    expect(denomFormatter(-1234.56, 'USD')).toBe('-1,234.56');
  });

  test('handles zero', () => {
    expect(denomFormatter(0, 'USD')).toBe('0.00');
  });
});


File: src/api/Account/controllers/authorizeForAccount.ts
----------------------------------------
import express from "express";
import { AuthorizeForAccountService } from "../services/AuthorizeForAccount";
import logger from "../../../../config/logger";
import { validateUUID, validateMemberHandle } from "../../../utils/validators";

export async function AuthorizeForAccountController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { memberHandleToBeAuthorized, accountID, ownerID } = req.body;

  try {
    // Validate input
    if (!validateMemberHandle(memberHandleToBeAuthorized)) {
      return res.status(400).json({ message: "Invalid memberHandleToBeAuthorized" });
    }
    if (!validateUUID(accountID)) {
      return res.status(400).json({ message: "Invalid accountID" });
    }
    if (!validateUUID(ownerID)) {
      return res.status(400).json({ message: "Invalid ownerID" });
    }

    logger.info("Authorizing member for account", { memberHandleToBeAuthorized, accountID, ownerID });

    const responseData = await AuthorizeForAccountService(
      memberHandleToBeAuthorized,
      accountID,
      ownerID
    );

    if (!responseData) {
      logger.warn("Failed to authorize member for account", { memberHandleToBeAuthorized, accountID, ownerID });
      res.status(400).json({ message: "Failed to authorize member for account" });
      return;
    }

    if (responseData.message === "accounts not found") {
      logger.warn("Accounts not found during authorization", { memberHandleToBeAuthorized, accountID, ownerID });
      res.status(404).json({ message: "Accounts not found" });
      return;
    }

    if (responseData.message === "Limit of 5 authorized accounts reached. Remove an authorized account if you want to add another.") {
      logger.warn("Authorization limit reached", { memberHandleToBeAuthorized, accountID, ownerID });
      res.status(400).json({ message: responseData.message });
      return;
    }

    if (responseData.message === "You can only authorize someone to transact on behalf of your account when you are on the Entrepreneur tier or above.") {
      logger.warn("Insufficient tier for authorization", { memberHandleToBeAuthorized, accountID, ownerID });
      res.status(403).json({ message: responseData.message });
      return;
    }

    logger.info("Member authorized for account successfully", { memberHandleToBeAuthorized, accountID, ownerID });
    res.status(200).json(responseData);
  } catch (error) {
    logger.error("Error in AuthorizeForAccountController", { error, memberHandleToBeAuthorized: req.body.memberHandleToBeAuthorized, accountID: req.body.accountID, ownerID: req.body.ownerID });
    next(error);
  }
}



File: src/api/Account/controllers/updateSendOffersTo.ts
----------------------------------------
import express from "express";
import { UpdateSendOffersToService } from "../services/UpdateSendOffersTo";
import logger from "../../../../config/logger";
import { validateUUID } from "../../../utils/validators";

export async function UpdateSendOffersToController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { memberIDtoSendOffers, accountID, ownerID } = req.body;

  try {
    // Validate input
    if (!validateUUID(memberIDtoSendOffers)) {
      return res.status(400).json({ message: "Invalid memberIDtoSendOffers" });
    }
    if (!validateUUID(accountID)) {
      return res.status(400).json({ message: "Invalid accountID" });
    }
    if (!validateUUID(ownerID)) {
      return res.status(400).json({ message: "Invalid ownerID" });
    }

    logger.info("Updating offer recipient for account", { memberIDtoSendOffers, accountID, ownerID });

    const responseData = await UpdateSendOffersToService(
      memberIDtoSendOffers,
      accountID,
      ownerID
    );

    if (!responseData) {
      logger.warn("Failed to update offer recipient for account", { memberIDtoSendOffers, accountID, ownerID });
      res.status(400).json({ message: "Failed to update offer recipient for account" });
      return;
    }

    logger.info("Offer recipient updated successfully for account", { memberIDtoSendOffers, accountID, ownerID });
    res.status(200).json(responseData);
  } catch (error) {
    logger.error("Error in UpdateSendOffersToController", { error, memberIDtoSendOffers: req.body.memberIDtoSendOffers, accountID: req.body.accountID, ownerID: req.body.ownerID });
    next(error);
  }
}



File: src/api/Account/controllers/getAccountDashboard.ts
----------------------------------------
import express from "express";
import { GetAccountDashboardService } from "../services/GetAccountDashboard";

export async function GetAccountDashboardController(
  req: express.Request,
  res: express.Response
) {
  const { memberID, accountID } = req.body;

  if (!memberID || !accountID) {
    return res.status(400).json({ message: "memberID and accountID are required" });
  }

  try {
    const accountDashboard = await GetAccountDashboardService(memberID, accountID);

    if (!accountDashboard) {
      return res.status(404).json({ message: "Account dashboard not found" });
    }

    return res.status(200).json(accountDashboard);
  } catch (error) {
    console.error("Error getting account dashboard:", error);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}


File: src/api/Account/controllers/updateAccount.ts
----------------------------------------
import express from "express";
import { UpdateAccountService } from "../services/UpdateAccount";
import logger from "../../../../config/logger";
import { getDenominations } from "../../../constants/denominations";
import { validateUUID, validateAccountName, validateAccountHandle } from "../../../utils/validators";

export async function UpdateAccountController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { ownerID, accountID, accountName, accountHandle, defaultDenom } = req.body;

  try {
    // Validate input
    if (!validateUUID(ownerID)) {
      return res.status(400).json({ message: "Invalid ownerID" });
    }
    if (!validateUUID(accountID)) {
      return res.status(400).json({ message: "Invalid accountID" });
    }
    if (accountName && !validateAccountName(accountName)) {
      return res.status(400).json({ message: "Invalid accountName" });
    }
    if (accountHandle && !validateAccountHandle(accountHandle)) {
      return res.status(400).json({ message: "Invalid accountHandle" });
    }
    if (defaultDenom && !getDenominations({ code: defaultDenom }).length) {
      return res.status(400).json({ message: "Invalid defaultDenom" });
    }

    logger.info("Updating account", { ownerID, accountID, accountName, accountHandle, defaultDenom });

    const updatedAccountID = await UpdateAccountService(
      ownerID,
      accountID,
      accountName,
      accountHandle,
      defaultDenom
    );

    if (updatedAccountID) {
      logger.info("Account updated successfully", { updatedAccountID });
      res.status(200).json({ message: `Account updated successfully`, accountID: updatedAccountID });
    } else {
      logger.warn("Account not found or no update performed", { ownerID, accountID });
      res.status(404).json({ message: "Account not found or no update performed" });
    }
  } catch (error) {
    logger.error("Error in UpdateAccountController", { error, ownerID: req.body.ownerID, accountID: req.body.accountID });
    next(error);
  }
}



File: src/api/Account/controllers/createAccount.ts
----------------------------------------
import express from "express";
import { CreateAccountService } from "../services/CreateAccount";
import { getDenominations } from "../../../constants/denominations";
import { checkPermittedAccountType } from "../../../constants/accountTypes";
import logger from "../../../../config/logger";
import { validateUUID, validateAccountName, validateAccountHandle } from "../../../utils/validators";

export async function CreateAccountController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): Promise<void> {
  const { ownerID, accountType, accountName, accountHandle, defaultDenom, DCOgiveInCXX, DCOdenom } = req.body;

  try {
    // Validate input
    if (!validateUUID(ownerID)) {
      res.status(400).json({ message: "Invalid ownerID" });
      return;
    }
    if (!checkPermittedAccountType(accountType)) {
      res.status(400).json({ message: "Invalid accountType" });
      return;
    }
    if (!validateAccountName(accountName)) {
      res.status(400).json({ message: "Invalid accountName" });
      return;
    }
    if (!validateAccountHandle(accountHandle)) {
      res.status(400).json({ message: "Invalid accountHandle" });
      return;
    }
    if (!getDenominations({ code: defaultDenom }).length) {
      res.status(400).json({ message: "Invalid defaultDenom" });
      return;
    }
    if (DCOdenom && !getDenominations({ code: DCOdenom }).length) {
      res.status(400).json({ message: "Invalid DCOdenom" });
      return;
    }
    if (DCOgiveInCXX && (isNaN(DCOgiveInCXX) || DCOgiveInCXX < 0)) {
      res.status(400).json({ message: "Invalid DCOgiveInCXX" });
      return;
    }

    logger.info("Creating new account", {
      ownerID,
      accountType,
      accountName,
      accountHandle,
      defaultDenom,
      DCOdenom,
    });

    const newAccount = await CreateAccountService(
      ownerID,
      accountType,
      accountName,
      accountHandle,
      defaultDenom,
      DCOgiveInCXX,
      DCOdenom
    );

    if (newAccount.accountID) {
      logger.info("Account created successfully", { accountID: newAccount.accountID });
      res.status(201).json({ accountID: newAccount.accountID, message: "Account created successfully" });
    } else {
      res.status(400).json({ message: newAccount.message || "Failed to create account" });
    }
  } catch (error) {
    logger.error("Error in CreateAccountController", { error });
    next(error);
  }
}



File: src/api/Account/controllers/unauthorizeForAccount.ts
----------------------------------------
import express from "express";
import { UnauthorizeForCompanyService } from "../services/UnauthorizeForAccount";
import logger from "../../../../config/logger";

/**
 * Controller for unauthorizing a member for an account
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function UnauthorizeForAccountController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const requiredFields = ["memberIDtoBeUnauthorized", "accountID", "ownerID"];

  try {
    for (const field of requiredFields) {
      if (!req.body[field]) {
        res.status(400).json({ message: `${field} is required` });
        return;
      }
    }

    const { memberIDtoBeUnauthorized, accountID, ownerID } = req.body;

    // Validate memberIDtoBeUnauthorized
    if (typeof memberIDtoBeUnauthorized !== 'string' || !/^[a-f0-9-]{36}$/.test(memberIDtoBeUnauthorized)) {
      res.status(400).json({ message: "Invalid memberIDtoBeUnauthorized. Must be a valid UUID." });
      return;
    }

    // Validate accountID
    if (typeof accountID !== 'string' || !/^[a-f0-9-]{36}$/.test(accountID)) {
      res.status(400).json({ message: "Invalid accountID. Must be a valid UUID." });
      return;
    }

    // Validate ownerID
    if (typeof ownerID !== 'string' || !/^[a-f0-9-]{36}$/.test(ownerID)) {
      res.status(400).json({ message: "Invalid ownerID. Must be a valid UUID." });
      return;
    }

    logger.info("Unauthorizing member for account", { memberIDtoBeUnauthorized, accountID, ownerID });

    const responseData = await UnauthorizeForCompanyService(
      memberIDtoBeUnauthorized,
      accountID,
      ownerID
    );

    if (!responseData) {
      logger.warn("Failed to unauthorize member for account", { memberIDtoBeUnauthorized, accountID, ownerID });
      res.status(400).json({ message: "Failed to unauthorize member for the account" });
      return;
    }

    logger.info("Member unauthorized for account successfully", { memberIDtoBeUnauthorized, accountID, ownerID });
    res.status(200).json(responseData);
  } catch (error) {
    logger.error("Error in UnauthorizeForAccountController", { error, memberIDtoBeUnauthorized: req.body.memberIDtoBeUnauthorized, accountID: req.body.accountID, ownerID: req.body.ownerID });
    next(error);
  }
}



File: src/api/Account/controllers/getAccountByHandle.ts
----------------------------------------
import express from "express";
import { GetAccountByHandleService } from "../services/GetAccountByHandle";
import logger from "../../../../config/logger";

/**
 * Controller for retrieving an account by its handle
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function GetAccountByHandleController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { accountHandle } = req.body;

  try {
    if (!accountHandle || typeof accountHandle !== 'string') {
      res.status(400).json({ message: "accountHandle is required and must be a string" });
      return;
    }

    // Validate accountHandle format
    if (!/^[a-z0-9._]{3,30}$/.test(accountHandle)) {
      res.status(400).json({
        message: "Invalid account handle. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters.",
      });
      return;
    }

    logger.info("Retrieving account by handle", { accountHandle });

    const accountData = await GetAccountByHandleService(accountHandle);

    if (accountData) {
      logger.info("Account retrieved successfully", { accountHandle });
      res.status(200).json({ accountData });
    } else {
      logger.info("Account not found", { accountHandle });
      res.status(404).json({ message: "Account not found" });
    }
  } catch (error) {
    logger.error("Error in GetAccountByHandleController", { error, accountHandle });
    next(error);
  }
}



File: src/api/Account/accountRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "../../index";
import { CreateAccountController } from "./controllers/createAccount";
import { GetAccountByHandleController } from "./controllers/getAccountByHandle";
import { UpdateAccountController } from "./controllers/updateAccount";
import { AuthorizeForAccountController } from "./controllers/authorizeForAccount";
import { UnauthorizeForAccountController } from "./controllers/unauthorizeForAccount";
import { UpdateSendOffersToController } from "./controllers/updateSendOffersTo";

export default function AccountRoutes(
  app: express.Application,
  jsonParser: any
) {
  /**
   * @swagger
   * /api/v1/createAccount:
   *   post:
   *     summary: Create a new account
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - ownerID
   *               - accountType
   *               - accountName
   *               - accountHandle
   *               - defaultDenom
   *             properties:
   *               ownerID:
   *                 type: string
   *               accountType:
   *                 type: string
   *               accountName:
   *                 type: string
   *               accountHandle:
   *                 type: string
   *               defaultDenom:
   *                 type: string
   *     responses:
   *       200:
   *         description: Account created successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}createAccount`,
    jsonParser,
    CreateAccountController
  );

  /**
   * @swagger
   * /api/v1/getAccountByHandle:
   *   get:
   *     summary: Get account by handle
   *     tags: [Accounts]
   *     parameters:
   *       - in: query
   *         name: accountHandle
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Account retrieved successfully
   *       400:
   *         description: Bad request
   *       404:
   *         description: Account not found
   */
  app.get(
    `${apiVersionOneRoute}getAccountByHandle`,
    jsonParser,
    GetAccountByHandleController
  );

  /**
   * @swagger
   * /api/v1/updateAccount:
   *   patch:
   *     summary: Update account information
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - ownerID
   *               - accountID
   *             properties:
   *               ownerID:
   *                 type: string
   *               accountID:
   *                 type: string
   *               accountName:
   *                 type: string
   *               accountHandle:
   *                 type: string
   *               defaultDenom:
   *                 type: string
   *     responses:
   *       200:
   *         description: Account updated successfully
   *       400:
   *         description: Bad request
   *       404:
   *         description: Account not found
   */
  app.patch(
    `${apiVersionOneRoute}updateAccount`,
    jsonParser,
    UpdateAccountController
  );

  /**
   * @swagger
   * /api/v1/authorizeForAccount:
   *   post:
   *     summary: Authorize a member for an account
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - memberHandleToBeAuthorized
   *               - accountID
   *               - ownerID
   *             properties:
   *               memberHandleToBeAuthorized:
   *                 type: string
   *               accountID:
   *                 type: string
   *               ownerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Member authorized successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}authorizeForAccount`,
    jsonParser,
    AuthorizeForAccountController
  );

  /**
   * @swagger
   * /api/v1/unauthorizeForAccount:
   *   post:
   *     summary: Unauthorize a member for an account
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - memberIDtoBeUnauthorized
   *               - accountID
   *               - ownerID
   *             properties:
   *               memberIDtoBeUnauthorized:
   *                 type: string
   *               accountID:
   *                 type: string
   *               ownerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Member unauthorized successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}unauthorizeForAccount`,
    jsonParser,
    UnauthorizeForAccountController
  );

  /**
   * @swagger
   * /api/v1/updateSendOffersTo:
   *   post:
   *     summary: Update the member to receive offers for an account
   *     tags: [Accounts]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - memberIDtoSendOffers
   *               - accountID
   *               - ownerID
   *             properties:
   *               memberIDtoSendOffers:
   *                 type: string
   *               accountID:
   *                 type: string
   *               ownerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Send offers recipient updated successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}updateSendOffersTo`,
    jsonParser,
    UpdateSendOffersToController
  );
}



File: src/api/Account/services/UnauthorizeForAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function UnauthorizeForCompanyService(
  memberIDtoBeUnauthorized: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH
                (memberToUnauthorize:Member { memberID: $memberIDtoBeUnauthorized })
                -[authRel:AUTHORIZED_FOR]->(account:Account { accountID: $accountID })
                <-[:OWNS]-(owner:Member { memberID: $ownerID })
            DELETE authRel
            RETURN
                account.accountID AS accountID,
                memberToUnauthorize.accountID AS memberToUnauthorize
        `,
      {
        memberIDtoBeUnauthorized,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      console.log("could not unauthorize account");
      return false;
    }
    const record = result.records[0];

    console.log(
      `account ${record.get(
        "memberToUnauthorize"
      )} unauthorized to transact for ${record.get("accountID")}`
    );
    return true;
  } catch (error) {
    console.error("Error unauthorizing account:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Account/services/GetAccountByHandle.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function GetAccountByHandleService(
  accountHandle: string
): Promise<any | null> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  if (!accountHandle) {
    console.log("accountHandle is required");
    return null;
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH (account:Account { accountHandle: $accountHandle })
            RETURN
              account.accountID AS accountID,
              account.accountName AS accountName
        `,
      { accountHandle }
    );

    if (!result.records.length) {
      console.log("account not found");
      return null;
    }

    const accountID = result.records[0].get("accountID");
    const accountName = result.records[0].get("accountName");

    return {
      accountID: accountID,
      accountName: accountName,
    };
  } catch (error) {
    console.error("Error fetching account data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Account/services/UpdateAccount.ts
----------------------------------------
/*
updates data for a account

requires object of account data to be updated
field required: accountID

fields that can be updated:
    firstname
    lastname
    companyname
    phone
    accountHandle
    DailyCredcoinOfferingGive
    DailyCredcoinOfferingDenom

if extraneous data or data not matching criteria is included it will be ignored, data
that fits criteria (if any) will still be updated, and success message will be returned

returns accountID of updated account

returns null on error
*/

import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { getDenominations } from "../../../constants/denominations";

export async function UpdateAccountService(
  ownerID: string,
  accountID: string,
  accountName: string,
  accountHandle: string,
  defaultDenom: string
) {
  // Validation: Check defaultDenom in denominations
  if (!getDenominations({ code: defaultDenom }).length) {
    const message = "defaultDenom not in denoms";
    console.log(message);
    return false;
  }

  const dataToUpdate = {
    accountName: accountName,
    accountHandle: accountHandle,
    defaultDenom: defaultDenom,
  };

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH
          (owner:Member { memberID: $ownerID })
          -[:OWNS]->
          (account:Account { accountID: $accountID })
        SET account += $dataToUpdate
        RETURN account.accountID AS accountID
            `,
      { ownerID, accountID, dataToUpdate }
    );

    if (!result.records[0].get("accountID")) {
      return false;
    }

    return result.records[0].get("accountID");
  } catch (error) {
    console.error("Error updating account data:", error);
    return null;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Account/services/UpdateSendOffersTo.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function UpdateSendOffersToService(
  memberIDtoSendOffers: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH
                (newMemberForOffers: Member { memberID: $memberIDtoSendOffers})
                -[:AUTHORIZED_FOR]->(account:Account { accountID: $accountID})
                <-[:OWNS]-(owner:Member { memberID: $ownerID}),
                (account)-[currentAccountForOffersRel:SEND_OFFERS_TO]->(:Member)
            DELETE currentAccountForOffersRel
            CREATE (account)-[:SEND_OFFERS_TO]->(newMemberForOffers)
            RETURN true
            `,
      {
        memberIDtoSendOffers,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      return false;
    }

    return true;
  } catch (error) {
    console.error(
      "Error updating account to receive offer notifications:",
      error
    );
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Account/services/GetAccountDashboard.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { GetBalancesService } from "./GetBalances";
import { GetPendingOffersInService } from "../../Credex/services/GetPendingOffersIn";
import { GetPendingOffersOutService } from "../../Credex/services/GetPendingOffersOut";

export async function GetAccountDashboardService(
  memberID: string,
  accountID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    interface AuthMember {
      memberID: string;
      firstname: string;
      lastname: string;
    }

    interface AccountData {
      accountID: string;
      accountName: string;
      accountHandle: string;
      defaultDenom: string;
      isOwnedAccount: boolean;
      sendOffersToFirstname: string;
      sendOffersToLastname: string;
      sendOffersToMemberID: string;
      authFor: AuthMember[];
      balanceData: any;
      pendingInData: any;
      pendingOutData: any;
    }

    const result = await ledgerSpaceSession.run(
      `
    MATCH
      (account:Account { accountID: $accountID })
      <-[:AUTHORIZED_FOR]-
      (member:Member { memberID: $memberID})
    MATCH
      (account)<-[:AUTHORIZED_FOR]-(allAuthMembers)
    OPTIONAL MATCH
      (account)<-[owns:OWNS]-(member)
    OPTIONAL MATCH
      (account)-[:SEND_OFFERS_TO]->(sendOffersTo:Member)
    RETURN
      account.accountID AS accountID,
      account.accountType AS accountType,
      account.accountName AS accountName,
      account.accountHandle AS accountHandle,
      account.defaultDenom AS defaultDenom,
      sendOffersTo.firstname AS sendOffersToFirstname,
      sendOffersTo.lastname AS sendOffersToLastname,
      sendOffersTo.memberID AS sendOffersToMemberID,
      owns IS NOT NULL AS isOwnedAccount,
      allAuthMembers.firstname AS authMemberFirstname,
      allAuthMembers.lastname AS authMemberLastname,
      allAuthMembers.memberID AS authMemberID
  `,
      { memberID, accountID }
    );

    if (!result.records.length) {
      console.log("account not found");
      return null;
    }

    const accountData: AccountData = {
      accountID: result.records[0].get("accountID"),
      accountName: result.records[0].get("accountName"),
      accountHandle: result.records[0].get("accountHandle"),
      defaultDenom: result.records[0].get("defaultDenom"),
      isOwnedAccount: result.records[0].get("isOwnedAccount"),
      sendOffersToFirstname: "",
      sendOffersToLastname: "",
      sendOffersToMemberID: "",
      authFor: [],
      balanceData: [],
      pendingInData: [],
      pendingOutData: [],
    };

    if (accountData.isOwnedAccount) {
      (accountData.sendOffersToFirstname = result.records[0].get(
        "sendOffersToFirstname"
      )),
        (accountData.sendOffersToLastname = result.records[0].get(
          "sendOffersToLastname"
        )),
        (accountData.sendOffersToMemberID = result.records[0].get(
          "sendOffersToMemberID"
        )),
        result.records.forEach((record) => {
          accountData.authFor.push({
            memberID: record.get("authMemberID"),
            firstname: record.get("authMemberFirstname"),
            lastname: record.get("authMemberLastname"),
          });
        });
    } else {
      accountData.authFor = [];
    }
    accountData.balanceData = await GetBalancesService(accountData.accountID);
    accountData.pendingInData = await GetPendingOffersInService(
      accountData.accountID
    );
    accountData.pendingOutData = await GetPendingOffersOutService(
      accountData.accountID
    );

    return accountData;
  } catch (error) {
    console.error("Error fetching account data:", error);
    return null;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Account/services/GetBalances.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { denomFormatter } from "../../../utils/denomUtils";

export async function GetBalancesService(accountID: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    const getSecuredBalancesQuery = await ledgerSpaceSession.run(
      `
      MATCH (account:Account {accountID: $accountID})

      // Get all unique denominations from Credex nodes related to the account
      OPTIONAL MATCH (account)-[:OWES|OFFERED]-(securedCredex:Credex)<-[:SECURES]-()
      WITH DISTINCT securedCredex.Denomination AS denom, account

      // Aggregate incoming secured amounts for each denomination ensuring uniqueness
      OPTIONAL MATCH (account)<-[:OWES]-(inSecuredCredex:Credex {Denomination: denom})<-[:SECURES]-()
      WITH denom, account, 
          collect(DISTINCT inSecuredCredex) AS inSecuredCredexes

      // Aggregate outgoing secured amounts for each denomination ensuring uniqueness
      OPTIONAL MATCH (account)-[:OWES|OFFERED]->(outSecuredCredex:Credex {Denomination: denom})<-[:SECURES]-()
      WITH denom, 
          reduce(s = 0, n IN inSecuredCredexes | s + n.OutstandingAmount) AS sumSecuredIn, 
          collect(DISTINCT outSecuredCredex) AS outSecuredCredexes

      // Calculate the total outgoing amount
      WITH denom, sumSecuredIn, 
          reduce(s = 0, n IN outSecuredCredexes | s + n.OutstandingAmount) AS sumSecuredOut

      // Get the current day node which should have active status
      MATCH (daynode:Daynode {Active: true})

      // Calculate the net secured balance for each denomination and return the result
      RETURN denom, (sumSecuredIn - sumSecuredOut) / daynode[denom] AS netSecured
      `,
      { accountID }
    );

    const securedNetBalancesByDenom: string[] = getSecuredBalancesQuery.records
      .filter((record) => {
        const amount = record.get("netSecured");
        return typeof amount === "number" && isFinite(amount) && amount !== 0;
      })
      .map((record) => {
        const denom = record.get("denom");
        const amount = record.get("netSecured");
        return `${denomFormatter(amount, denom)} ${denom}`;
      });

    const getUnsecuredBalancesAndTotalAssetsQuery =
      await ledgerSpaceSession.run(
        `
        MATCH (account:Account{accountID:$accountID})

        OPTIONAL MATCH (account)<-[:OWES]-(owesInCredexUnsecured:Credex)
        WHERE NOT (owesInCredexUnsecured)<-[:SECURES]-()
        WITH account, COLLECT(DISTINCT owesInCredexUnsecured) AS unsecuredCredexesIn

        OPTIONAL MATCH (account)-[:OWES]->(owesOutCredexUnsecured:Credex)
        WHERE NOT (owesOutCredexUnsecured)<-[:SECURES]-()
        WITH account, unsecuredCredexesIn, COLLECT(DISTINCT owesOutCredexUnsecured) AS unsecuredCredexesOut

        OPTIONAL MATCH (account)<-[:OWES]-(owesInCredexAll:Credex)
        WITH account, unsecuredCredexesIn, unsecuredCredexesOut, COLLECT(DISTINCT owesInCredexAll) AS owesInCredexesAll

        OPTIONAL MATCH (account)-[:OWES]->(owesOutCredexAll:Credex)
        WITH account, unsecuredCredexesIn, unsecuredCredexesOut, owesInCredexesAll, COLLECT(DISTINCT owesOutCredexAll) AS owesOutCredexesAll

        WITH
          account.defaultDenom AS defaultDenom,
          REDUCE(total = 0, credex IN unsecuredCredexesIn | total + credex.OutstandingAmount) AS receivablesTotalCXX,
          REDUCE(total = 0, credex IN unsecuredCredexesOut | total + credex.OutstandingAmount) AS payablesTotalCXX,
          REDUCE(total = 0, credex IN unsecuredCredexesIn | total + credex.OutstandingAmount)
            - REDUCE(total = 0, credex IN unsecuredCredexesOut | total + credex.OutstandingAmount) AS unsecuredNetCXX,
          REDUCE(total = 0, credex IN owesInCredexesAll | total + credex.OutstandingAmount)
            - REDUCE(total = 0, credex IN owesOutCredexesAll | total + credex.OutstandingAmount) AS netCredexAssetsCXX
        MATCH (daynode:Daynode{Active:true})
        RETURN
          defaultDenom,
          receivablesTotalCXX / daynode[defaultDenom] AS receivablesTotalInDefaultDenom,
          payablesTotalCXX / daynode[defaultDenom] AS payablesTotalInDefaultDenom,
          unsecuredNetCXX / daynode[defaultDenom] AS unsecuredNetInDefaultDenom,
          netCredexAssetsCXX / daynode[defaultDenom] AS netCredexAssetsInDefaultDenom
      `,
        { accountID }
      );

    const unsecuredBalancesAndTotalAssets =
      getUnsecuredBalancesAndTotalAssetsQuery.records[0];
    const defaultDenom = unsecuredBalancesAndTotalAssets.get("defaultDenom");
    const unsecuredBalancesInDefaultDenom = {
      totalPayables: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("payablesTotalInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
      totalReceivables: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("receivablesTotalInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
      netPayRec: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("unsecuredNetInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
    };

    return {
      securedNetBalancesByDenom,
      unsecuredBalancesInDefaultDenom,
      netCredexAssetsInDefaultDenom: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("netCredexAssetsInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
    };
  } catch (error) {
    console.error("Error fetching balances:", error);
    throw new Error("Failed to fetch balances. Please try again later.");
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Account/services/AuthorizeForAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function AuthorizeForAccountService(
  memberHandleToBeAuthorized: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Check that account authorization is permitted on membership tier
    const getMemberTier = await ledgerSpaceSession.run(
      `
        MATCH (member:Member{ memberID: $ownerID })
        RETURN member.memberTier as memberTier
      `,
      { ownerID }
    );

    const memberTier = getMemberTier.records[0].get("memberTier");
    if (memberTier <= 3) {
      return {
        message:
          "You can only authorize someone to transact on behalf of your account when you are on the Entrepreneur tier or above.",
      };
    }

    const result = await ledgerSpaceSession.run(
      `
        MATCH (account:Account { accountID: $accountID })
            <-[:OWNS]-(owner:Member { memberID: $ownerID })
        MATCH (memberToAuthorize:Member { memberHandle: $memberHandleToBeAuthorized })
        MATCH (:Member)-[currentAuthForRel:AUTHORIZED_FOR]->(account)
        WITH count (currentAuthForRel) AS numAuthorized, memberToAuthorize, account
        CALL apoc.do.when(
          numAuthorized >= 5,
          'RETURN "limitReached" AS message',
          'MERGE (memberToAuthorize)-[:AUTHORIZED_FOR]->(account)
            RETURN
              "accountAuthorized" AS message,
              account.accountID AS accountID,
              memberToAuthorize.memberID AS memberIDtoAuthorize',
          {
            numAuthorized: numAuthorized,
            memberToAuthorize: memberToAuthorize,
            account: account
          }
        )
        YIELD value
        RETURN
          value.message AS message,
          value.accountID AS accountID,
          value.memberIDtoAuthorize AS memberIDtoAuthorize
      `,
      {
        memberHandleToBeAuthorized,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      return {
        message: "accounts not found",
      };
    }

    const record = result.records[0];

    if (record.get("message") == "limitReached") {
      return {
        message:
          "Limit of 5 authorized accounts reached. Remove an authorized account if you want to add another.",
      };
    }

    if (record.get("message") == "accountAuthorized") {
      console.log(
        `account ${record.get(
          "memberIDtoAuthorize"
        )} authorized to transact for ${record.get("accountID")}`
      );
      return {
        message: "account authorized",
        accountID: record.get("accountID"),
        memberIdAuthorized: record.get("memberIDtoAuthorized"),
      };
    } else {
      console.log("could not authorize account");
      return false;
    }
  } catch (error) {
    console.error("Error authorizing account:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Account/services/CreateAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function CreateAccountService(
  ownerID: string,
  accountType: string,
  accountName: string,
  accountHandle: string,
  defaultDenom: string,
  DCOgiveInCXX: number | null = null,
  DCOdenom: string | null = null
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  //check that account creation is permitted on membership tier
  const getMemberTier = await ledgerSpaceSession.run(
    `
        MATCH (member:Member{ memberID: $ownerID })
        OPTIONAL MATCH (member)-[:OWNS]->(account:Account)
        RETURN
          member.memberTier AS memberTier,
          COUNT(account) AS numAccounts
      `,
    { ownerID }
  );

  const memberTier = getMemberTier.records[0].get("memberTier");
  const numAccounts = getMemberTier.records[0].get("numAccounts");
  if (memberTier <= 2 && numAccounts >= 1) {
    return {
      account: false,
      message:
        "You cannot create an account on the Open or Verified membership tiers.",
    };
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode { Active: true })
        MATCH (owner:Member { memberID: $ownerID })
        CREATE (owner)-[:OWNS]->(account:Account {
          accountType: $accountType,
          accountName: $accountName,
          accountHandle: $accountHandle,
          defaultDenom: $defaultDenom,
          DCOgiveInCXX: $DCOgiveInCXX,
          DCOdenom: $DCOdenom,
          accountID: randomUUID(),
          queueStatus: "PENDING_ACCOUNT",
          createdAt: datetime(),
          updatedAt: datetime()
        })-[:CREATED_ON]->(daynode)
        CREATE
          (owner)-[:AUTHORIZED_FOR]->
          (account)
          -[:SEND_OFFERS_TO]->(owner)
        RETURN account.accountID AS accountID
      `,
      {
        ownerID,
        accountType,
        accountName,
        accountHandle,
        defaultDenom,
        DCOgiveInCXX,
        DCOdenom,
      }
    );

    if (!result.records.length) {
      const message = "could not create account";
      console.log(message);
      return { account: false, message };
    }

    const createdAccountID = result.records[0].get("accountID");
    console.log(accountType + " account created: " + createdAccountID);
    return {
      accountID: createdAccountID,
      message: "account created",
    };
  } catch (error) {
    console.error("Error creating account:", error);

    if (
      isNeo4jError(error) &&
      error.code === "Neo.ClientError.Schema.ConstraintValidationFailed"
    ) {
      if (error.message.includes("phone")) {
        return { account: false, message: "Phone number already in use" };
      }
      if (error.message.includes("handle")) {
        return {
          account: false,
          message: "Sorry, that handle is already in use",
        };
      }
      return { account: false, message: "Required unique field not unique" };
    }

    return {
      account: false,
      message:
        "Error: " + (error instanceof Error ? error.message : "Unknown error"),
    };
  } finally {
    await ledgerSpaceSession.close();
  }
}

// Type guard to check if an error is a Neo4j error
function isNeo4jError(
  error: unknown
): error is { code: string; message: string } {
  return (
    typeof error === "object" &&
    error !== null &&
    "code" in error &&
    "message" in error
  );
}



File: src/api/Avatar/controllers/acceptRecurring.ts
----------------------------------------
import express from "express";
import { AcceptRecurringService } from "../services/AcceptRecurring";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

/**
 * AcceptRecurringController
 *
 * This controller handles the acceptance of recurring transactions.
 * It validates the required fields, calls the AcceptRecurringService,
 * and returns the result along with updated dashboard data.
 *
 * @param req - Express request object
 * @param res - Express response object
 */
export async function AcceptRecurringController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    const fieldsRequired = ["avatarID", "signerID"];
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `${field} is required` });
      }
    }

    // Call AcceptRecurringService to process the acceptance
    const acceptRecurringData = await AcceptRecurringService({
      avatarID: req.body.avatarID,
      signerID: req.body.signerID
    });

    // Check if the service call was successful
    if (typeof acceptRecurringData.recurring === "boolean") {
      return res.status(400).json({ error: acceptRecurringData.message });
    }

    // Fetch dashboard data
    const dashboardData = await GetAccountDashboardService(
      req.body.signerID,
      acceptRecurringData.recurring.acceptorAccountID
    );

    if (!dashboardData) {
      return res.status(404).json({ error: "Failed to fetch dashboard data" });
    }

    // Return the acceptance data and dashboard data
    return res.status(200).json({
      acceptRecurringData: acceptRecurringData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in AcceptRecurringController:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}



File: src/api/Avatar/controllers/cancelRecurring.ts
----------------------------------------
import express from "express";
import { CancelRecurringService } from "../services/CancelRecurring";
import { GetAccountDashboardController } from "../../Account/controllers/getAccountDashboard";

export async function DeclineRecurringController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["signerID", "cancelerAccountID", "avatarID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    const cancelRecurringData = await CancelRecurringService(
      req.body.signerID,
      req.body.cancelerAccountID,
      req.body.avatarID
    );

    if (!cancelRecurringData) {
      return res.status(400).json(cancelRecurringData);
    }

    const dashboardReq = {
      body: {
        memberID: req.body.signerID,
        accountID: req.body.cancelerAccountID
      }
    } as express.Request;
    const dashboardRes = {
      status: (code: number) => ({
        json: (data: any) => data
      })
    } as express.Response;

    const dashboardData = await GetAccountDashboardController(dashboardReq, dashboardRes);

    res.json({
      cancelRecurringData: cancelRecurringData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in DeclineRecurringController:", err);
    res.status(500).json({ error: (err as Error).message });
  }
}



File: src/api/Avatar/controllers/requestRecurring.ts
----------------------------------------
import express from "express";
import { RequestRecurringService } from "../services/RequestRecurring";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";
import { getDenominations } from "../../../constants/denominations";

/**
 * RequestRecurringController
 * 
 * This controller handles the creation of recurring payment requests.
 * It validates the input, calls the RequestRecurringService,
 * and returns the result along with updated dashboard data.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function RequestRecurringController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    const fieldsRequired = [
      "signerMemberID",
      "requestorAccountID",
      "counterpartyAccountID",
      "InitialAmount",
      "Denomination",
      "nextPayDate",
      "daysBetweenPays",
    ];
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `${field} is required` });
      }
    }

    // Check denomination validity
    if (!getDenominations({ code: req.body.Denomination }).length) {
      return res.status(400).json({ error: "Denomination not permitted" });
    }

    // Validate optional parameters
    if (req.body.securedCredex !== undefined && typeof req.body.securedCredex !== 'boolean') {
      return res.status(400).json({ error: "securedCredex must be a boolean" });
    }

    if (req.body.credspan !== undefined) {
      const credspan = Number(req.body.credspan);
      if (isNaN(credspan) || credspan < 7 || credspan > 35) {
        return res.status(400).json({ error: "credspan must be a number between 7 and 35" });
      }
    }

    if (req.body.remainingPays !== undefined) {
      const remainingPays = Number(req.body.remainingPays);
      if (isNaN(remainingPays) || remainingPays < 0) {
        return res.status(400).json({ error: "remainingPays must be a positive number" });
      }
    }

    // Check securedCredex and credspan relationship
    if (req.body.securedCredex === true && req.body.credspan !== undefined) {
      return res.status(400).json({ error: "credspan must be null when securedCredex is true" });
    }

    if (req.body.securedCredex !== true && req.body.credspan === undefined) {
      return res.status(400).json({ error: "credspan must be provided when securedCredex is not true" });
    }

    const createRecurringData = await RequestRecurringService(req.body);

    if (!createRecurringData) {
      return res.status(400).json({ error: "Failed to create recurring payment" });
    }

    const dashboardData = await GetAccountDashboardService(
      req.body.signerMemberID,
      req.body.requestorAccountID
    );

    if (!dashboardData) {
      return res.status(404).json({ error: "Failed to fetch dashboard data" });
    }

    return res.status(200).json({
      avatarMemberID: createRecurringData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in RequestRecurringController:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}



File: src/api/Avatar/recurringRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "../../index";
import { RequestRecurringController } from "./controllers/requestRecurring";
import { AcceptRecurringController } from "./controllers/acceptRecurring";
import { DeclineRecurringController } from "./controllers/cancelRecurring";

export default function RecurringRoutes(
  app: express.Application,
  jsonParser: any
) {
  /**
   * @swagger
   * /api/v1/requestRecurring:
   *   post:
   *     summary: Request a recurring payment
   *     tags: [Recurring]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - signerMemberID
   *               - requestorAccountID
   *               - counterpartyAccountID
   *               - InitialAmount
   *               - Denomination
   *               - nextPayDate
   *               - daysBetweenPays
   *             properties:
   *               signerMemberID:
   *                 type: string
   *               requestorAccountID:
   *                 type: string
   *               counterpartyAccountID:
   *                 type: string
   *               InitialAmount:
   *                 type: number
   *               Denomination:
   *                 type: string
   *               nextPayDate:
   *                 type: string
   *                 format: date
   *               daysBetweenPays:
   *                 type: integer
   *               securedCredex:
   *                 type: boolean
   *               credspan:
   *                 type: integer
   *               remainingPays:
   *                 type: integer
   *     responses:
   *       200:
   *         description: Recurring payment requested successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}requestRecurring`,
    jsonParser,
    RequestRecurringController
  );

  /**
   * @swagger
   * /api/v1/acceptRecurring:
   *   put:
   *     summary: Accept a recurring payment request
   *     tags: [Recurring]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - avatarID
   *               - signerID
   *             properties:
   *               avatarID:
   *                 type: string
   *               signerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Recurring payment accepted successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}acceptRecurring`,
    jsonParser,
    AcceptRecurringController
  );

  /**
   * @swagger
   * /api/v1/cancelRecurring:
   *   put:
   *     summary: Cancel a recurring payment
   *     tags: [Recurring]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - signerID
   *               - cancelerAccountID
   *               - avatarID
   *             properties:
   *               signerID:
   *                 type: string
   *               cancelerAccountID:
   *                 type: string
   *               avatarID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Recurring payment cancelled successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}cancelRecurring`,
    jsonParser,
    DeclineRecurringController
  );
}



File: src/api/Avatar/services/RequestRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import * as neo4j from "neo4j-driver";

interface RecurringParams {
  signerMemberID: string;
  requestorAccountID: string;
  counterpartyAccountID: string;
  InitialAmount: number;
  Denomination: string;
  nextPayDate: string;
  daysBetweenPays: number;
  securedCredex?: boolean;
  credspan?: number;
  remainingPays?: number;
}

export async function RequestRecurringService(params: RecurringParams): Promise<string | null> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    let cypher = `
      MATCH
        (requestor:Account {accountID: $requestorAccountID})<-[:AUTHORIZED_FOR]-
        (signer:Member|Avatar { memberID: $signerMemberID })
      MATCH (counterparty:Account {accountID: $counterpartyAccountID})
      MATCH (daynode:Daynode { Active: true })
      CREATE (recurring:Avatar)
      SET
        recurring.avatarType = "RECURRING",
        recurring.memberID = randomUUID(),
        recurring.Denomination = $Denomination,
        recurring.InitialAmount = $InitialAmount,
        recurring.nextPayDate = date($nextPayDate),
        recurring.daysBetweenPays = $daysBetweenPays,
        recurring.createdAt = datetime(),
        recurring.memberTier = 3
    `;

    if (params.securedCredex !== undefined) {
      cypher += `SET recurring.securedCredex = $securedCredex `;
    }

    if (params.credspan !== undefined) {
      cypher += `SET recurring.credspan = $credspan `;
    }

    if (params.remainingPays !== undefined) {
      cypher += `SET recurring.remainingPays = $remainingPays `;
    }

    cypher += `
      CREATE (requestor)<-[:REQUESTS]-(recurring)<-[:REQUESTS]-(counterparty)
      CREATE (requestor)<-[:REQUESTED]-(recurring)<-[:REQUESTED]-(counterparty)
      CREATE (requestor)<-[:AUTHORIZED_FOR]-(recurring)
      CREATE (signer)-[:SIGNED]--(recurring)
      CREATE (recurring)-[:CREATED_ON]--(daynode)
      RETURN
        recurring.memberID AS avatarID
    `;

    const neo4jParams = {
      ...params,
      daysBetweenPays: neo4j.int(params.daysBetweenPays),
      credspan: params.credspan ? neo4j.int(params.credspan) : undefined,
      remainingPays: params.remainingPays ? neo4j.int(params.remainingPays) : undefined
    };

    const createRecurringQuery = await ledgerSpaceSession.run(cypher, neo4jParams);

    return createRecurringQuery.records[0]?.get("avatarID") || null;
  } catch (error) {
    console.error("Error creating recurring avatar:", error);
    return null;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Avatar/services/AcceptRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

interface AcceptRecurringParams {
  avatarID: string;
  signerID: string;
}

interface AcceptRecurringResult {
  recurring: {
    acceptedRecurringID: string;
    acceptorAccountID: string;
    acceptorSignerID: string;
  } | boolean;
  message: string;
}

/**
 * AcceptRecurringService
 * 
 * This service handles the acceptance of a recurring transaction.
 * It updates the database to reflect the acceptance of the recurring avatar.
 * 
 * @param params - An object containing avatarID and signerID
 * @returns An object containing the result of the acceptance operation
 */
export async function AcceptRecurringService(params: AcceptRecurringParams): Promise<AcceptRecurringResult> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const { avatarID, signerID } = params;

    // Execute Cypher query to validate and update the Recurring avatar
    const acceptRecurringQuery = await ledgerSpaceSession.run(
      `
      MATCH
        (signer:Member { memberID: $signerID })-[:AUTHORIZED_FOR]->
        (acceptor:Account)-[rel1:REQUESTS]->
        (recurring:Avatar { memberID: $avatarID })-[rel2:REQUESTS]->
        (requestor:Account)
      CREATE (signer)-[:SIGNED]->(recurring)
      CREATE (acceptor)<-[:AUTHORIZED_FOR]-(recurring)
      CREATE (acceptor)-[:ACTIVE]->(recurring)-[:ACTIVE]->(requestor)
      DELETE rel1, rel2
      RETURN
        recurring.memberID AS avatarID,
        acceptor.accountID AS acceptorAccountID,
        signer.memberID AS signerID
      `,
      { avatarID, signerID }
    );

    // Check if the query returned any records
    if (acceptRecurringQuery.records.length === 0) {
      console.log(
        `No records found or recurring transaction no longer pending for avatarID: ${avatarID}`
      );
      return {
        recurring: false,
        message: `No records found or recurring transaction no longer pending for avatarID: ${avatarID}`,
      };
    }

    // TODO: Implement notification for recurring acceptance

    // Extract relevant data from the query result
    const record = acceptRecurringQuery.records[0];
    const acceptedRecurringID = record.get("avatarID");
    const acceptorAccountID = record.get("acceptorAccountID");
    const acceptorSignerID = record.get("signerID");

    console.log(`Recurring request accepted for avatarID: ${acceptedRecurringID}`);
    
    // Return the result of the acceptance operation
    return {
      recurring: {
        acceptedRecurringID,
        acceptorAccountID,
        acceptorSignerID,
      },
      message: "Recurring template created",
    };

  } catch (error) {
    // Handle any errors that occur during the process
    console.error("Error accepting recurring template:", error);
    return {
      recurring: false,
      message: `Error accepting recurring template: ${error}`,
    };
  } finally {
    // Ensure the database session is closed
    await ledgerSpaceSession.close();
  }
}



File: src/api/Avatar/services/CancelRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function CancelRecurringService(
  signerID: string,
  cancelerAccountID: string,
  avatarID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Validate and update the Recurring node
    const cancelRecurringQuery = await ledgerSpaceSession.run(
      `
      MATCH
        (signer:Member { memberID: $signerID })-[:AUTHORIZED_FOR]->
        (cancelingAccount:Account { accountID: $cancelerAccountID })-[rel1:ACTIVE|REQUESTS]-
        (recurring:Avatar { memberID: $avatarID})-[rel2:ACTIVE|REQUESTS]-
        (counterparty:Account)
      MATCH
        (cancelingAccount)<-[authRel1:AUTHORIZED_FOR]-
        (recurring)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH cancelingAccount, recurring, counterparty, rel1, rel2, authRel1, authRel2
      CALL apoc.create.relationship(cancelingAccount, 'CANCELED', {}, recurring) YIELD rel as canceledRel1
      CALL apoc.create.relationship(recurring, 'CANCELED', {}, counterparty) YIELD rel as canceledRel2
      DELETE rel1, rel2, authRel1, authRel2
      RETURN recurring.memberID AS deactivatedAvatarID
      `,
      {
        signerID,
        cancelerAccountID,
        avatarID,
      }
    );

    if (cancelRecurringQuery.records.length === 0) {
      return "Recurring template not found or not authorized to cancel";
    }

    const deactivatedAvatarID = cancelRecurringQuery.records[0].get(
      "deactivatedAvatarID"
    );

    return deactivatedAvatarID;
  } catch (error) {
    return error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Credex/controllers/acceptCredex.ts
----------------------------------------
import express from "express";
import { AcceptCredexService } from "../services/AcceptCredex";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

/**
 * AcceptCredexController
 * 
 * This controller handles the acceptance of Credex offers.
 * It validates the required fields, calls the AcceptCredexService,
 * and returns the result along with updated dashboard data.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function AcceptCredexController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    const fieldsRequired = ["credexID", "signerID"];
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `${field} is required` });
      }
    }

    const acceptCredexData = await AcceptCredexService(
      req.body.credexID,
      req.body.signerID
    );
    
    if (!acceptCredexData) {
      return res.status(400).json({ error: "Failed to accept Credex" });
    }

    const dashboardData = await GetAccountDashboardService(
      req.body.signerID,
      acceptCredexData.acceptorAccountID
    );

    if (!dashboardData) {
      return res.status(404).json({ error: "Failed to fetch dashboard data" });
    }

    return res.status(200).json({
      acceptCredexData: acceptCredexData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in AcceptCredexController:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}



File: src/api/Credex/controllers/cancelCredex.ts
----------------------------------------
import express from "express";
import { CancelCredexService } from "../services/CancelCredex";

/**
 * CancelCredexController
 * 
 * This controller handles the cancellation of Credex offers.
 * It validates the required fields, calls the CancelCredexService,
 * and returns the result.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function CancelCredexController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    if (!req.body.credexID) {
      return res.status(400).json({ error: "credexID is required" });
    }

    const responseData = await CancelCredexService(req.body.credexID);
    
    if (!responseData) {
      return res.status(404).json({ error: "Credex not found or already processed" });
    }

    return res.status(200).json({ message: "Credex cancelled successfully", credexID: responseData });
  } catch (err) {
    console.error("Error in CancelCredexController:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}



File: src/api/Credex/controllers/offerCredex.ts
----------------------------------------
import express from "express";
import { OfferCredexService } from "../services/OfferCredex";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";
import { getDenominations } from "../../../constants/denominations";
import { checkDueDate, credspan } from "../../../constants/credspan";
import { checkPermittedCredexType } from "../../../constants/credexTypes";
import { SecuredCredexAuthForTierController } from "../../Member/controllers/securedCredexAuthForTier";
import { ledgerSpaceDriver } from "../../../../config/neo4j";

/**
 * OfferCredexController
 * 
 * This controller handles the creation of new Credex offers.
 * It validates the required fields, performs additional validations,
 * calls the OfferCredexService, and returns the result along with updated dashboard data.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function OfferCredexController(
  req: express.Request,
  res: express.Response
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Validate required fields
    const fieldsRequired = [
      "memberID",
      "issuerAccountID",
      "receiverAccountID",
      "Denomination",
      "InitialAmount",
      "credexType",
      "OFFERSorREQUESTS",
    ];
    for (const field of fieldsRequired) {
      if (!req.body[field]) {
        return res.status(400).json({ error: `${field} is required` });
      }
    }

    const {
      memberID,
      issuerAccountID,
      receiverAccountID,
      Denomination,
      InitialAmount,
      credexType,
      OFFERSorREQUESTS,
      securedCredex = false,
      dueDate = "",
    } = req.body;

    // Check if issuerAccountID and receiverAccountID are the same
    if (issuerAccountID === receiverAccountID) {
      return res.status(400).json({ error: "Issuer and receiver cannot be the same account" });
    }

    // Validate InitialAmount is a number
    if (typeof InitialAmount !== "number") {
      return res.status(400).json({ error: "InitialAmount must be a number" });
    }

    // Check denomination validity
    if (!getDenominations({ code: Denomination }).length) {
      return res.status(400).json({ error: "Invalid denomination" });
    }

    // Check credex type validity
    if (!checkPermittedCredexType(credexType)) {
      return res.status(400).json({ error: "Invalid credex type" });
    }

    // Validate OFFERSorREQUESTS
    if (OFFERSorREQUESTS !== "OFFERS" && OFFERSorREQUESTS !== "REQUESTS") {
      return res.status(400).json({ error: "Invalid OFFER/REQUEST value" });
    }

    // Check due date for unsecured credex
    if (!securedCredex) {
      if (!dueDate) {
        return res.status(400).json({ error: "Unsecured credex must have a due date" });
      }
      const dueDateOK = await checkDueDate(dueDate);
      if (!dueDateOK) {
        return res.status(400).json({ 
          error: `Due date must be permitted date, in format YYYY-MM-DD. First permitted due date is 1 week from today. Last permitted due date is ${credspan / 7} weeks from today.` 
        });
      }
    } else if (dueDate) {
      return res.status(400).json({ error: "Secured credex cannot have a due date" });
    }

    // Check secured credex limits based on membership tier
    if (securedCredex) {
      const getMemberTier = await ledgerSpaceSession.run(
        `
          MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
          RETURN member.memberTier as memberTier
        `,
        { issuerAccountID }
      );

      const memberTier = getMemberTier.records[0].get("memberTier");
      const tierAuth = await SecuredCredexAuthForTierController(
        issuerAccountID,
        memberTier,
        InitialAmount,
        Denomination
      );
      if (!tierAuth.isAuthorized) {
        return res.status(400).json({ error: tierAuth.message });
      }
    }

    // Check if unsecured credex is permitted on membership tier
    if (!securedCredex) {
      const getMemberTier = await ledgerSpaceSession.run(
        `
          MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
          RETURN member.memberTier as memberTier
        `,
        { issuerAccountID }
      );

      const memberTier = getMemberTier.records[0].get("memberTier");
      if (memberTier == 1) {
        return res.status(400).json({ error: "Members on the Open Tier cannot issue unsecured credexes" });
      }
    }

    // Call OfferCredexService to create the Credex offer
    const offerCredexData = await OfferCredexService(req.body);
    
    if (!offerCredexData || typeof offerCredexData.credex === 'boolean') {
      return res.status(400).json({ error: offerCredexData.message || "Failed to create Credex offer" });
    }
    
    // Fetch updated dashboard data
    const dashboardData = await GetAccountDashboardService(memberID, issuerAccountID);
    
    if (!dashboardData) {
      return res.status(404).json({ error: "Failed to fetch dashboard data" });
    }
    
    // Return the offer data and updated dashboard data
    return res.status(200).json({
      offerCredexData: offerCredexData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in OfferCredexController:", err);
    return res.status(500).json({ error: "Internal server error" });
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Credex/controllers/acceptCredexBulk.ts
----------------------------------------
import express from "express";
import { AcceptCredexService } from "../services/AcceptCredex";
import { GetAccountDashboardController } from "../../Account/controllers/getAccountDashboard";

export async function AcceptCredexBulkController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["credexIDs", "signerID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  if (
    !Array.isArray(req.body.credexIDs) ||
    !req.body.credexIDs.every((id: any) => typeof id === "string")
  ) {
    return res
      .status(400)
      .json({ message: "Array of credexIDs to accept is required" });
  }

  try {
    const acceptCredexData = await Promise.all(
      req.body.credexIDs.map(async (credexID: string) => {
        const data = await AcceptCredexService(credexID, req.body.signerID);
        if (data) {
          return data;
        }
        return null;
      })
    );

    // Filter out any null values
    const validCredexData = acceptCredexData.filter(
      (
        item
      ): item is {
        acceptedCredexID: any;
        acceptorAccountID: any;
        memberID: any;
      } => item !== null
    );

    if (validCredexData.length > 0) {
      // Assuming that memberID and acceptorAccountID are the same for all returned objects
      const { memberID, acceptorAccountID } = validCredexData[0];

      const dashboardReq = {
        body: {
          memberID,
          accountID: acceptorAccountID
        }
      } as express.Request;
      const dashboardRes = {
        status: (code: number) => ({
          json: (data: any) => data
        })
      } as express.Response;

      const dashboardData = await GetAccountDashboardController(dashboardReq, dashboardRes);
      res.json({
        acceptCredexData: validCredexData,
        dashboardData: dashboardData,
      });
    } else {
      // Handle the case when there are no valid data returned from AcceptCredexService
      res
        .status(400)
        .json({ error: "No valid data returned from AcceptCredexService" });
    }
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: src/api/Credex/controllers/getLedger.ts
----------------------------------------
import express from "express";
import { GetLedgerService } from "../services/GetLedger";

export async function GetLedgerController(
  req: express.Request,
  res: express.Response
) {
  try {
    // Validate required fields
    if (!req.body.accountID) {
      return res.status(400).json({ error: "accountID is required" });
    }

    // Validate and set default values for optional fields
    const numRows = req.body.numRows ? parseInt(req.body.numRows) : 10;
    const startRow = req.body.startRow ? parseInt(req.body.startRow) : 0;

    if (isNaN(numRows) || isNaN(startRow) || numRows < 1 || startRow < 0) {
      return res.status(400).json({ error: "Invalid numRows or startRow" });
    }

    const responseData = await GetLedgerService(
      req.body.accountID,
      numRows,
      startRow
    );
    res.json(responseData);
  } catch (err) {
    console.error("Error in GetLedgerController:", err);
    res.status(500).json({ error: "Internal server error" });
  }
}



File: src/api/Credex/controllers/declineCredex.ts
----------------------------------------
import express from "express";
import { DeclineCredexService } from "../services/DeclineCredex";

export async function DeclineCredexController(
  req: express.Request,
  res: express.Response,
) {
  const fieldsRequired = ["credexID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }
  try {
    const responseData = await DeclineCredexService(req.body.credexID);
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: src/api/Credex/controllers/getCredex.ts
----------------------------------------
import express from "express";
import { GetCredexService } from "../services/GetCredex";

export async function GetCredexController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["credexID", "accountID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    const responseData = await GetCredexService(
      req.body.credexID,
      req.body.accountID
    );
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: src/api/Credex/services/CancelCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

/**
 * CancelCredexService
 * 
 * This service handles the cancellation of a Credex offer or request.
 * It changes the relationships from OFFERS or REQUESTS to CANCELLED.
 * 
 * @param credexID - The ID of the Credex to be cancelled
 * @returns The ID of the cancelled Credex or null if the operation fails
 * @throws Error if there's an issue with the database operation
 */
export async function CancelCredexService(credexID: string): Promise<string | null> {
  if (!credexID) {
    console.error("CancelCredexService: credexID is required");
    return null;
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.executeWrite(async (tx) => {
      const query = `
        MATCH (issuer:Account)-[rel1:OFFERS|REQUESTS]->(credex:Credex {credexID: $credexID})-[rel2:OFFERS|REQUESTS]->(acceptor:Account)
        WHERE credex.queueStatus <> "PROCESSED"
        DELETE rel1, rel2
        CREATE (issuer)-[:CANCELLED]->(credex)-[:CANCELLED]->(acceptor)
        SET
          credex.cancelledAt = datetime(),
          credex.OutstandingAmount = 0,
          credex.queueStatus = "PROCESSED"
        RETURN credex.credexID AS credexID
      `;

      const queryResult = await tx.run(query, { credexID });

      if (queryResult.records.length === 0) {
        console.warn(`No records found or credex no longer pending for credexID: ${credexID}`);
        return null;
      }

      return queryResult.records[0].get("credexID") as string;
    });

    if (result) {
      console.log(`Credex cancelled successfully: ${result}`);
    }

    return result;
  } catch (error) {
    console.error(`Error cancelling credex for credexID ${credexID}:`, error);
    throw new Error(`Failed to cancel Credex: ${(error as Error).message}`);
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Credex/services/GetLedger.ts
----------------------------------------
/*

returns details to display a ledger list of transactions

requires:
  accountID

requires (with defaults if not included)
  numRows (number of transactions to return, default is 10)
  startRow (number of row to start at, for pagination, default is first row)

returns for each credex:
  credexID
  formattedInitialAmount (string eg 8,546.32 USD)
  counterpartyDisplayname

returns empty array if no credexes

returns error message if numRows or startRows can't be coerced into numbers
returns empty array if accountID not valid

*/

import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { denomFormatter } from "../../../utils/denomUtils";

export async function GetLedgerService(
  accountID: string,
  numRows: number = 10,
  startRow: number = 0
) {
  numRows = Math.round(Number(numRows));
  startRow = Math.round(Number(startRow));

  if (Number.isNaN(numRows) || Number.isNaN(startRow)) {
    return "numRows and startRows must be numbers";
  }

  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
            (account:Account{accountID:$accountID})-[transactionType:OWES|CLEARED]-(credex:Credex)-[:OWES|CLEARED]-(counterparty:Account)
        OPTIONAL MATCH (credex)<-[:SECURES]-(securer:Account)
        RETURN
            credex.credexID AS credexID,
            credex.InitialAmount/credex.CXXmultiplier AS InitialAmount,
            credex.Denomination AS Denomination,
            (startNode(transactionType) = account) as debit,
            counterparty.accountName AS counterpartyAccountName
            ORDER BY credex.acceptedAt
            SKIP $startRow
            LIMIT $numRows
    `,
      {
        accountID: accountID,
        numRows: neo4j.int(numRows),
        startRow: neo4j.int(startRow),
      }
    );

    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const credexes = result.records.map((record) => {
      const credexID = record.get("credexID");
      const InitialAmount = record.get("debit")
        ? -parseFloat(record.get("InitialAmount"))
        : record.get("InitialAmount");
      const Denomination = record.get("Denomination");
      const counterpartyAccountName = record.get("counterpartyAccountName");

      const formattedInitialAmount =
        denomFormatter(InitialAmount, Denomination) + " " + Denomination;

      return {
        credexID,
        formattedInitialAmount,
        counterpartyAccountName,
      };
    });

    return credexes;
  } catch (error) {
    console.error("Error in GetLedgerService:", error);
    throw error;
  }
}



File: src/api/Credex/services/GetSecuredAuthorization.ts
----------------------------------------
/*
returns information on a account's secured balance

required inputs:
  issuerAccountID,
  Denomination,

returns:
  securerID (null if no secured balances available or error)
  securableAmountInDenom (0 if no secured balances or error, infinity if CREDEX_FOUNDATION_AUDITED)
    
*/

import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function GetSecuredAuthorizationService(
  issuerAccountID: string,
  Denomination: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  // Check if issuer is CREDEX_FOUNDATION_AUDITED
  const isFoundationAuditedQuery = await ledgerSpaceSession.run(
    `
      OPTIONAL MATCH
        (issuer:Account { accountID: $issuerAccountID })
        <-[:CREDEX_FOUNDATION_AUDITED]-
        (credexFoundation:Account { accountType: "CREDEX_FOUNDATION" })
      RETURN issuer IS NOT NULL AS isAudited
    `,
    { issuerAccountID }
  );

  const record = isFoundationAuditedQuery.records[0];
  const isAudited = record ? record.get("isAudited") : false;

  // If the issuer is CREDEX_FOUNDATION_AUDITED, authorize for unlimited secured credex issuance
  if (isAudited) {
    await ledgerSpaceSession.close();
    return {
      securerID: issuerAccountID,
      securableAmountInDenom: Infinity,
    };
  }

  // If issuer is not CREDEX_FOUNDATION_AUDITED, verify the available secured balance in denom
  const getSecurableDataQuery = await ledgerSpaceSession.run(
    `
      MATCH (account:Account {accountID: $accountID})
      OPTIONAL MATCH (account)-[transactionType:OWES|OFFERS]-(credex:Credex)<-[:SECURES]-(securer:Account)
      WHERE credex.Denomination = $Denomination
      WITH
        securer.accountID AS securingAccountID,
        SUM(CASE WHEN endNode(transactionType) = account THEN credex.OutstandingAmount ELSE 0 END) -
        SUM(CASE WHEN startNode(transactionType) = account THEN credex.OutstandingAmount ELSE 0 END)
        AS netSecurablePerSecurerCXX
      MATCH (daynode:Daynode {Active: true})
      RETURN
        securingAccountID,
        netSecurablePerSecurerCXX / daynode[$Denomination] AS netSecurableInDenom
        ORDER BY netSecurableInDenom DESC
        LIMIT 1
    `,
    {
      accountID: issuerAccountID,
      Denomination: Denomination,
    }
  );

  await ledgerSpaceSession.close();

  const securableRecord = getSecurableDataQuery.records[0];
  if (!securableRecord || securableRecord.length === 0) {
    return {
      securerID: null,
      securableAmountInDenom: 0,
    };
  }
    console.log({
      securerID: securableRecord.get("securingAccountID"),
      securableAmountInDenom: securableRecord.get("netSecurableInDenom"),
    });

  return {
    securerID: securableRecord.get("securingAccountID"),
    securableAmountInDenom: securableRecord.get("netSecurableInDenom"),
  };
}



File: src/api/Credex/services/GetPendingOffersIn.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { denomFormatter } from "../../../utils/denomUtils";
import moment from "moment-timezone";

interface OfferedCredex {
  credexID: string;
  formattedInitialAmount: string;
  counterpartyAccountName: string;
  dueDate?: string; // optional field
  secured?: boolean; // optional field
}

export async function GetPendingOffersInService(accountID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
          (account:Account{accountID:$accountID})<-[:OFFERS]-(offersInCredex:Credex)<-[:OFFERS]-(counterparty:Account)
        OPTIONAL MATCH
          (offersInCredex)<-[:SECURES]-(securer:Account)
        RETURN
          offersInCredex.InitialAmount / offersInCredex.CXXmultiplier AS InitialAmount,
          offersInCredex.credexID AS credexID,
          offersInCredex.Denomination AS Denomination,
          offersInCredex.dueDate AS dueDate,
          counterparty.accountName AS counterpartyAccountName,
          securer IS NOT NULL as secured
      `,
      { accountID }
    );
    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const offeredCredexData = [];
    for (const record of result.records) {
      const formattedInitialAmount =
        denomFormatter(
          record.get("InitialAmount"),
          record.get("Denomination")
        ) +
        " " +
        record.get("Denomination");

      const thisOfferedCredex: OfferedCredex = {
        credexID: record.get("credexID"),
        formattedInitialAmount: formattedInitialAmount,
        counterpartyAccountName: record.get("counterpartyAccountName"),
      };
      if (record.get("dueDate")) {
        thisOfferedCredex.dueDate = moment(record.get("dueDate"))
          .subtract(1, "months") //because moment uses Jan = 0 and neo4j uses Jan = 1
          .format("YYYY-MM-DD");
      }
      if (record.get("secured")) {
        thisOfferedCredex.secured = record.get("secured");
      }
      offeredCredexData.push(thisOfferedCredex);
    }

    return offeredCredexData;
  } catch (error) {
    console.error("Error in GetPendingOffersInService:", error);
    throw error;
  }
}



File: src/api/Credex/services/CreateCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { denomFormatter } from "../../../utils/denomUtils";
import { GetSecuredAuthorizationService } from "./GetSecuredAuthorization";

export async function CreateCredexService(credexData: any) {
  const {
    issuerAccountID,
    receiverAccountID,
    InitialAmount,
    Denomination,
    credexType,
    OFFERSorREQUESTS,
    securedCredex = false,
    dueDate = "",
  } = credexData;

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  let OFFEREDorREQUESTED = OFFERSorREQUESTS === "OFFERS" ? "OFFERED" : "REQUESTED";

  try {
    // Get securable data for secured credex
    let secureableData = { securerID: "", securableAmountInDenom: 0 };
    if (securedCredex) {
      secureableData = await GetSecuredAuthorizationService(
        issuerAccountID,
        Denomination
      );
      if (secureableData.securableAmountInDenom < InitialAmount) {
        return {
          credex: false,
          message: `Error: Your secured credex for ${denomFormatter(
            InitialAmount,
            Denomination
          )} ${Denomination} cannot be issued because your maximum securable ${Denomination} balance is ${denomFormatter(
            secureableData.securableAmountInDenom,
            Denomination
          )} ${Denomination}`,
        };
      }
    }

    // Create the credex
    const createCredexQuery = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode {Active: true})
        MATCH (issuer:Account {accountID: $issuerAccountID})
        MATCH (receiver:Account {accountID: $receiverAccountID})
        CREATE (newCredex:Credex)
        SET
          newCredex.credexID = randomUUID(),
          newCredex.Denomination = $Denomination,
          newCredex.CXXmultiplier = daynode[$Denomination],
          newCredex.InitialAmount = $InitialAmount * daynode[$Denomination],
          newCredex.OutstandingAmount = $InitialAmount * daynode[$Denomination],
          newCredex.RedeemedAmount = 0,
          newCredex.DefaultedAmount = 0,
          newCredex.WrittenOffAmount = 0,
          newCredex.credexType = $credexType,
          newCredex.createdAt = datetime(),
          newCredex.queueStatus = "PENDING_CREDEX"
        MERGE (newCredex)-[:CREATED_ON]->(daynode)
        MERGE (issuer)-[:${OFFERSorREQUESTS}]->(newCredex)-[:${OFFERSorREQUESTS}]->(receiver)
        MERGE (issuer)-[:${OFFEREDorREQUESTED}]->(newCredex)-[:${OFFEREDorREQUESTED}]->(receiver)
        RETURN
          newCredex.credexID AS credexID,
          receiver.accountName AS receiverAccountName
      `,
      {
        issuerAccountID,
        receiverAccountID,
        InitialAmount,
        Denomination,
        credexType,
      }
    );

    const credexID = createCredexQuery.records[0].get("credexID");

    // Add dueDate for unsecured credex
    if (!securedCredex) {
      const addDueDateQuery = await ledgerSpaceSession.run(
        `
          MATCH (newCredex:Credex {credexID: $credexID})
          SET newCredex.dueDate = date($dueDate)
          RETURN newCredex.dueDate AS dueDate
        `,
        {
          credexID,
          dueDate,
        }
      );
      if (addDueDateQuery.records.length === 0) {
        return { credex: false, message: "error creating credex" };
      }
    }

    // Add secured relationships for secured credex
    if (securedCredex && secureableData.securerID) {
      await ledgerSpaceSession.run(
        `
          MATCH (newCredex:Credex {credexID: $credexID})
          MATCH (securingAccount: Account {accountID: $securingAccountID})
          MERGE (securingAccount)-[:SECURES]->(newCredex)
        `,
        {
          credexID,
          securingAccountID: secureableData.securerID,
        }
      );
    }

    const newCredex = {
      credexID: createCredexQuery.records[0].get("credexID"),
      formattedInitialAmount: denomFormatter(InitialAmount, Denomination),
      counterpartyAccountName: createCredexQuery.records[0].get(
        "receiverAccountName"
      ),
      secured: securedCredex,
      dueDate: dueDate,
    };

    return {
      credex: newCredex,
      message: "Credex created: " + newCredex.credexID,
    };
  } catch (error) {
    return { credex: false, message: "Error creating credex: " + error };
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Credex/services/DeclineCredex.ts
----------------------------------------
/*
marks a credex as declined by changing the relationships
from OFFERS or REQUESTS to DECLINED

required inputs:
  credexID

on success returns credexID

will return false if:
  credexID not found
  credex does not have OFFERS or REQUESTS relationships (credex already accepted/declined/cancelled)
    
*/

import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function DeclineCredexService(credexID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        MATCH (issuer:Account)-[rel1:OFFERS|REQUESTS]->(credex:Credex{credexID:$credexID})-[rel2:OFFERS|REQUESTS]->(acceptor:Account)
        DELETE rel1, rel2
        CREATE (issuer)-[:DECLINED]->(credex)-[:DECLINED]->(acceptor)
        WITH credex
        SET
            credex.declinedAt = Datetime(),
            credex.OutstandingAmount = 0,
            credex.queueStatus = "PROCESSED"
        RETURN credex.credexID AS credexID
    `,
      { credexID }
    );
    await ledgerSpaceSession.close();

    if (result.records.length === 0) {
      console.log(
        `No records found or credex no longer pending for credexID: ${credexID}`
      );
      return false;
    }

    const declinedCredexID = result.records[0].get("credexID");
    console.log(`Offer declined for credexID: ${declinedCredexID}`);
    return declinedCredexID;
  } catch (error) {
    console.log(error);
  }
}



File: src/api/Credex/services/GetCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { denomFormatter } from "../../../utils/denomUtils";
import moment from "moment-timezone";

export async function GetCredexService(credexID: string, accountID: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH
        (account:Account {accountID: $accountID})-[transactionType:OWES|CLEARED|REQUESTS|OFFERS|DECLINED|CANCELLED]-(credex:Credex {credexID: $credexID})-[:OWES|CLEARED|REQUESTS|OFFERS|DECLINED|CANCELLED]-(counterparty:Account)
        OPTIONAL MATCH (credex)<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH (credex)-[credloopRel:CREDLOOP]-(clearedAgainstCredex:Credex)-[:OWES|CLEARED]-(account), (clearedAgainstCredex)-[:OWES|CLEARED]-(clearedAgainstCounterparty:Account)
        RETURN
        credex.credexID AS credexID,
        type(transactionType) AS transactionType,
        (startNode(transactionType) = account) AS debit,
        counterparty.accountName AS counterpartyAccountName,
        securer.accountID AS securerID,
        securer.accountName AS securerName,
        credex.Denomination AS Denomination,
        credex.InitialAmount / credex.CXXmultiplier AS InitialAmount,
        credex.OutstandingAmount / credex.CXXmultiplier AS OutstandingAmount,
        credex.RedeemedAmount / credex.CXXmultiplier AS RedeemedAmount,
        credex.DefaultedAmount / credex.CXXmultiplier AS DefaultedAmount,
        credex.WrittenOffAmount / credex.CXXmultiplier AS WrittenOffAmount,
        credex.acceptedAt AS acceptedAt,
        credex.declinedAt AS declinedAt,
        credex.cancelledAt AS cancelledAt,
        credex.dueDate AS dueDate,
        clearedAgainstCredex.credexID AS clearedAgainstCredexID,
        credloopRel.AmountRedeemed / credloopRel.CXXmultiplier AS clearedAmount,
        clearedAgainstCredex.InitialAmount / clearedAgainstCredex.CXXmultiplier AS clearedAgainstCredexInitialAmount,
        clearedAgainstCredex.Denomination AS clearedAgainstCredexDenomination,
        clearedAgainstCounterparty.accountName AS clearedAgainstCounterpartyAccountName
      `,
      { credexID, accountID }
    );

    if (result.records.length === 0) {
      throw new Error("No records found");
    }

    const record = result.records[0];
    const debit = record.get("debit");

    type Amounts = {
      InitialAmount: number;
      OutstandingAmount: number;
      RedeemedAmount: number;
      DefaultedAmount: number;
      WrittenOffAmount: number;
    };

    const amounts: Amounts = [
      "InitialAmount",
      "OutstandingAmount",
      "RedeemedAmount",
      "DefaultedAmount",
      "WrittenOffAmount",
    ].reduce(
      (acc: Amounts, amount: string) => {
        const value = parseFloat(record.get(amount));
        acc[amount as keyof Amounts] = debit ? -value : value;
        return acc;
      },
      {
        InitialAmount: 0,
        OutstandingAmount: 0,
        RedeemedAmount: 0,
        DefaultedAmount: 0,
        WrittenOffAmount: 0,
      }
    );

    const Denomination = record.get("Denomination");
    const formattedAmounts = (
      Object.entries(amounts) as [keyof Amounts, number][]
    ).reduce((acc, [key, value]) => {
      acc[`formatted${key}`] = `${denomFormatter(
        value,
        Denomination
      )} ${Denomination}`;
      return acc;
    }, {} as Record<string, string>);

    const acceptedAt = moment(record.get("acceptedAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const declinedAt = moment(record.get("declinedAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const cancelledAt = moment(record.get("cancelledAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const dueDate = moment(record.get("dueDate"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const counterpartyAccountName = record.get("counterpartyAccountName")

    const credexData = {
      credexID: record.get("credexID"),
      transactionType: record.get("transactionType"),
      debit,
      counterpartyAccountName,
      securerID: record.get("securerID"),
      securerName: record.get("securerName"),
      Denomination,
      acceptedAt: acceptedAt,
      declinedAt: declinedAt,
      cancelledAt: cancelledAt,
      dueDate: dueDate,
      ...formattedAmounts,
    };

    const clearedAgainstData = result.records
      .filter((record) => record.get("clearedAgainstCredexID"))
      .map((record) => {
        const clearedAmount = record.get("clearedAmount");
        const clearedAgainstCredexInitialAmount = parseFloat(
          record.get("clearedAgainstCredexInitialAmount")
        );
        const signumClearedAgainstCredexInitialAmount = debit
          ? clearedAgainstCredexInitialAmount
          : -clearedAgainstCredexInitialAmount;
        const clearedAgainstCredexDenomination = record.get(
          "clearedAgainstCredexDenomination"
        );

        const clearedAgainstCounterpartyAccountName = record.get("clearedAgainstCounterpartyAccountName")

        return {
          clearedAgainstCredexID: record.get("clearedAgainstCredexID"),
          formattedClearedAmount: `${denomFormatter(
            clearedAmount,
            clearedAgainstCredexDenomination
          )} ${clearedAgainstCredexDenomination}`,
          formattedClearedAgainstCredexInitialAmount: `${denomFormatter(
            signumClearedAgainstCredexInitialAmount,
            clearedAgainstCredexDenomination
          )} ${clearedAgainstCredexDenomination}`,
          clearedAgainstCounterpartyAccountName,
        };
      });

    return { credexData, clearedAgainstData };
  } catch (error) {
    console.error("Error in GetCredexService:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Credex/services/AcceptCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

interface AcceptCredexResult {
  acceptedCredexID: string;
  acceptorAccountID: string;
  acceptorSignerID: string;
}

/**
 * AcceptCredexService
 * 
 * This service handles the acceptance of a Credex offer.
 * It updates the Credex status from OFFERS to OWES and signs the acceptance.
 * 
 * @param credexID - The ID of the Credex to be accepted
 * @param signerID - The ID of the Member or Avatar signing the acceptance
 * @returns An object with the accepted Credex details or null if the operation fails
 * @throws Error if there's an issue with the database operation
 */
export async function AcceptCredexService(credexID: string, signerID: string): Promise<AcceptCredexResult | null> {
  if (!credexID || !signerID) {
    console.error("AcceptCredexService: credexID and signerID are required");
    return null;
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.executeWrite(async (tx) => {
      const query = `
        MATCH
          (issuer:Account)-[rel1:OFFERS]->
          (acceptedCredex:Credex {credexID: $credexID})-[rel2:OFFERS]->
          (acceptor:Account)<-[:AUTHORIZED_FOR]-
          (signer:Member|Avatar { memberID: $signerID })
        DELETE rel1, rel2
        CREATE (issuer)-[:OWES]->(acceptedCredex)-[:OWES]->(acceptor)
        CREATE (acceptedCredex)<-[:SIGNED]-(signer)
        SET acceptedCredex.acceptedAt = datetime()
        RETURN
          acceptedCredex.credexID AS credexID,
          acceptor.accountID AS acceptorAccountID,
          signer.memberID AS signerID
      `;

      const queryResult = await tx.run(query, { credexID, signerID });

      if (queryResult.records.length === 0) {
        console.warn(`No records found or credex no longer pending for credexID: ${credexID}`);
        return null;
      }

      const record = queryResult.records[0];
      return {
        acceptedCredexID: record.get('credexID'),
        acceptorAccountID: record.get('acceptorAccountID'),
        acceptorSignerID: record.get('signerID')
      };
    });

    if (result) {
      console.log(`Offer accepted for credexID: ${result.acceptedCredexID}`);
      // TODO: Implement credex accepted notification here
    }

    return result;
  } catch (error) {
    console.error(`Error accepting credex for credexID ${credexID}:`, error);
    throw new Error(`Failed to accept Credex: ${(error as Error).message}`);
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Credex/services/GetPendingOffersOut.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { denomFormatter } from "../../../utils/denomUtils";
import moment from "moment-timezone";

interface OfferedCredex {
  credexID: string;
  formattedInitialAmount: string;
  counterpartyAccountName: string;
  dueDate?: string; // optional field
  secured?: boolean; // optional field
}

export async function GetPendingOffersOutService(accountID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
          (account:Account{accountID:$accountID})-[:OFFERS]->(offersOutCredex:Credex)-[:OFFERS]->(counterparty:Account)
        OPTIONAL MATCH
          (offersOutCredex)<-[:SECURES]-(securer:Account)
        RETURN
          offersOutCredex.InitialAmount / offersOutCredex.CXXmultiplier AS InitialAmount,
          offersOutCredex.credexID AS credexID,
          offersOutCredex.Denomination AS Denomination,
          offersOutCredex.dueDate AS dueDate,
          counterparty.accountName AS counterpartyAccountName,
          securer IS NOT NULL as secured
      `,
      { accountID }
    );
    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const offeredCredexData = [];
    for (const record of result.records) {
      const formattedInitialAmount =
        denomFormatter(
          parseFloat("-" + record.get("InitialAmount")),
          record.get("Denomination")
        ) +
        " " +
        record.get("Denomination");

      const thisOfferedCredex: OfferedCredex = {
        credexID: record.get("credexID"),
        formattedInitialAmount: formattedInitialAmount,
        counterpartyAccountName: record.get("counterpartyAccountName"),
      };
      if (record.get("dueDate")) {
        thisOfferedCredex.dueDate = moment(record.get("dueDate"))
          .subtract(1, "months") //because moment uses Jan = 0 and neo4j uses Jan = 1
          .format("YYYY-MM-DD");
      }
      if (record.get("secured")) {
        thisOfferedCredex.secured = record.get("secured");
      }
      offeredCredexData.push(thisOfferedCredex);
    }

    return offeredCredexData;
  } catch (error) {
    console.error("Error in GetPendingOffersOutService:", error);
    throw error;
  }
}



File: src/api/Credex/services/OfferCredex.ts
----------------------------------------
import { CreateCredexService } from "./CreateCredex";
import { ledgerSpaceDriver } from "../../../../config/neo4j";

interface CredexData {
  memberID: string;
  receiverAccountID: string;
  credexType?: string;
  OFFERSorREQUESTS?: string;
  [key: string]: any;
}

/**
 * OfferCredexService
 * 
 * This service handles the creation of a new Credex offer.
 * It uses the CreateCredexService to create the Credex and then
 * signs the offer and prepares it for notification.
 * 
 * @param credexData - An object containing the data for the new Credex
 * @returns The result of the Credex offer creation
 */
export async function OfferCredexService(credexData: CredexData) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    // Set default values for the Credex
    credexData.OFFERSorREQUESTS = "OFFERS";
    credexData.credexType = credexData.credexType || "PURCHASE";
    
    // Create the new Credex
    const newCredex = await CreateCredexService(credexData);

    if (typeof newCredex.credex === "boolean" || !newCredex.credex?.credexID) {
      throw new Error("Failed to create Credex");
    }

    // Sign the Credex and prepare for notification
    const signResult = await signCredex(ledgerSpaceSession, newCredex.credex.credexID, credexData.memberID);
    
    if (!signResult) {
      console.warn("Failed to sign Credex, but Credex was created successfully");
    }

    // TODO: Implement offer notification here

    console.log(newCredex.message);
    return newCredex;
  } catch (error) {
    console.error("Error offering credex:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}

async function signCredex(session: any, credexID: string, signingMemberID: string): Promise<boolean> {
  try {
    const signQuery = await session.run(
      `
      MATCH
        (credex:Credex { credexID: $credexID })<-[:OFFERS]-
        (Account)<-[:AUTHORIZED_FOR]-
        (signer:Member|Avatar { memberID: $signingMemberID })
      CREATE (credex)<-[:SIGNED]-(signer)
      RETURN signer.memberID AS signerID
      `,
      { credexID, signingMemberID }
    );

    return signQuery.records.length > 0;
  } catch (error) {
    console.error("Error signing Credex:", error);
    return false;
  }
}



File: src/api/Credex/credexRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "../../index";
import { OfferCredexController } from "./controllers/offerCredex";
import { AcceptCredexController } from "./controllers/acceptCredex";
import { AcceptCredexBulkController } from "./controllers/acceptCredexBulk";
import { DeclineCredexController } from "./controllers/declineCredex";
import { CancelCredexController } from "./controllers/cancelCredex";
import { GetCredexController } from "./controllers/getCredex";
import { GetLedgerController } from "./controllers/getLedger";

export default function CredexRoutes(
  app: express.Application,
  jsonParser: any
) {
  /**
   * @swagger
   * /api/v1/offerCredex:
   *   post:
   *     summary: Offer a new Credex
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - memberID
   *               - issuerAccountID
   *               - receiverAccountID
   *               - Denomination
   *               - InitialAmount
   *             properties:
   *               memberID:
   *                 type: string
   *               issuerAccountID:
   *                 type: string
   *               receiverAccountID:
   *                 type: string
   *               Denomination:
   *                 type: string
   *               InitialAmount:
   *                 type: number
   *               credexType:
   *                 type: string
   *               securedCredex:
   *                 type: boolean
   *               dueDate:
   *                 type: string
   *                 format: date
   *     responses:
   *       200:
   *         description: Credex offered successfully
   *       400:
   *         description: Bad request
   */
  app.post(
    `${apiVersionOneRoute}offerCredex`,
    jsonParser,
    OfferCredexController
  );

  /**
   * @swagger
   * /api/v1/acceptCredex:
   *   put:
   *     summary: Accept a Credex offer
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - credexID
   *               - signerID
   *             properties:
   *               credexID:
   *                 type: string
   *               signerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Credex accepted successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}acceptCredex`,
    jsonParser,
    AcceptCredexController
  );

  /**
   * @swagger
   * /api/v1/acceptCredexBulk:
   *   put:
   *     summary: Accept multiple Credex offers in bulk
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - credexIDs
   *               - signerID
   *             properties:
   *               credexIDs:
   *                 type: array
   *                 items:
   *                   type: string
   *               signerID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Credexes accepted successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}acceptCredexBulk`,
    jsonParser,
    AcceptCredexBulkController
  );

  /**
   * @swagger
   * /api/v1/declineCredex:
   *   put:
   *     summary: Decline a Credex offer
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - credexID
   *             properties:
   *               credexID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Credex declined successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}declineCredex`,
    jsonParser,
    DeclineCredexController
  );

  /**
   * @swagger
   * /api/v1/cancelCredex:
   *   put:
   *     summary: Cancel a Credex offer
   *     tags: [Credex]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - credexID
   *             properties:
   *               credexID:
   *                 type: string
   *     responses:
   *       200:
   *         description: Credex cancelled successfully
   *       400:
   *         description: Bad request
   */
  app.put(
    `${apiVersionOneRoute}cancelCredex`,
    jsonParser,
    CancelCredexController
  );

  /**
   * @swagger
   * /api/v1/getCredex:
   *   get:
   *     summary: Get Credex details
   *     tags: [Credex]
   *     parameters:
   *       - in: query
   *         name: credexID
   *         required: true
   *         schema:
   *           type: string
   *       - in: query
   *         name: accountID
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Credex details retrieved successfully
   *       400:
   *         description: Bad request
   *       404:
   *         description: Credex not found
   */
  app.get(`${apiVersionOneRoute}getCredex`, jsonParser, GetCredexController);

  /**
   * @swagger
   * /api/v1/getLedger:
   *   get:
   *     summary: Get account ledger
   *     tags: [Credex]
   *     parameters:
   *       - in: query
   *         name: accountID
   *         required: true
   *         schema:
   *           type: string
   *       - in: query
   *         name: numRows
   *         schema:
   *           type: integer
   *       - in: query
   *         name: startRow
   *         schema:
   *           type: integer
   *     responses:
   *       200:
   *         description: Ledger retrieved successfully
   *       400:
   *         description: Bad request
   */
  app.get(`${apiVersionOneRoute}getLedger`, jsonParser, GetLedgerController);
}



File: src/api/Member/controllers/updateMemberTier.ts
----------------------------------------
import express from "express";
import { UpdateMemberTierService } from "../services/UpdateMemberTier";
import logger from "../../../../config/logger";

/**
 * Controller for updating a member's tier
 * @param memberID - ID of the member
 * @param tier - New tier for the member
 * @returns Object containing success status and message
 */
export async function UpdateMemberTierController(
  memberID: string,
  tier: number
): Promise<{ success: boolean; message: string }> {
  try {
    // Input validation
    if (!memberID || typeof memberID !== 'string') {
      return { success: false, message: "Invalid memberID" };
    }

    if (!Number.isInteger(tier) || tier < 1) {
      return { success: false, message: "Invalid tier. Must be a positive integer." };
    }

    logger.info("Updating member tier", { memberID, tier });

    const result = await UpdateMemberTierService(memberID, tier);
    if (result) {
      logger.info("Member tier updated successfully", { memberID, tier });
      return { success: true, message: "Member tier updated successfully" };
    } else {
      logger.warn("Failed to update member tier", { memberID, tier });
      return { success: false, message: "Failed to update member tier" };
    }
  } catch (error) {
    logger.error("Error in UpdateMemberTierController", { error, memberID, tier });
    return { success: false, message: "Internal Server Error" };
  }
}

/**
 * Express middleware wrapper for updating a member's tier
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function updateMemberTierExpressHandler(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): Promise<void> {
  const { memberID, tier } = req.body;

  try {
    if (!memberID || typeof memberID !== 'string') {
      res.status(400).json({ message: "Invalid memberID. Must be a string." });
      return;
    }

    if (!Number.isInteger(tier) || tier < 1) {
      res.status(400).json({ message: "Invalid tier. Must be a positive integer." });
      return;
    }

    const result = await UpdateMemberTierController(memberID, tier);

    if (result.success) {
      res.status(200).json({ message: result.message });
    } else {
      res.status(400).json({ message: result.message });
    }
  } catch (error) {
    logger.error("Error in updateMemberTierExpressHandler", { error, memberID, tier });
    next(error);
  }
}



File: src/api/Member/controllers/getMemberDashboardByPhone.ts
----------------------------------------
import express from "express";
import { GetMemberDashboardByPhoneService } from "../services/GetMemberDashboardByPhone";
import { GetAccountDashboardController } from "../../Account/controllers/getAccountDashboard";
import logger from "../../../../config/logger";

/**
 * Controller for retrieving a member's dashboard by phone number
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function GetMemberDashboardByPhoneController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { phone } = req.body;

  try {
    if (!phone || typeof phone !== 'string') {
      res.status(400).json({ message: "phone is required and must be a string" });
      return;
    }

    // Validate phone number format (simple regex for demonstration, adjust as needed)
    if (!/^\+?[1-9]\d{1,14}$/.test(phone)) {
      res.status(400).json({
        message: "Invalid phone number format. Please provide a valid international phone number.",
      });
      return;
    }

    logger.info("Retrieving member dashboard by phone", { phone });

    const memberDashboard = await GetMemberDashboardByPhoneService(phone);
    if (!memberDashboard) {
      logger.warn("Could not retrieve member dashboard", { phone });
      res.status(404).json({ message: "Could not retrieve member dashboard" });
      return;
    }

    const accountDashboards = await Promise.all(
      memberDashboard.accountIDS.map(async (accountId: string) => {
        const accountReq = {
          body: {
            memberID: memberDashboard.memberID,
            accountID: accountId
          }
        } as express.Request;
        const accountRes = {
          status: (code: number) => ({
            json: (data: any) => data
          })
        } as express.Response;

        return GetAccountDashboardController(accountReq, accountRes);
      })
    );

    logger.info("Member dashboard retrieved successfully", { phone, memberID: memberDashboard.memberID });
    res.status(200).json({ memberDashboard, accountDashboards });
  } catch (error) {
    logger.error("Error in GetMemberDashboardByPhoneController", { error, phone });
    next(error);
  }
}



File: src/api/Member/controllers/onboardMember.ts
----------------------------------------
import express from "express";
import { OnboardMemberService } from "../services/OnboardMember";
import { GetMemberDashboardByPhoneService } from "../services/GetMemberDashboardByPhone";
import logger from "../../../../config/logger";
import { validateAccountName } from "../../../utils/validators";

function validateInput(
  firstname: string,
  lastname: string,
  phone: string
): string | null {
  if (!firstname || !lastname || !phone) {
    return "firstname, lastname, and phone are required";
  }
  if (
    typeof firstname !== "string" ||
    typeof lastname !== "string" ||
    typeof phone !== "string"
  ) {
    return "firstname, lastname, and phone must be strings";
  }
  if (!validateAccountName(firstname) || !validateAccountName(lastname)) {
    return "First name and last name must be between 3 and 50 characters";
  }

  // Phone number validation (with optional '+' prefix)
  const phoneRegex = /^\+?[1-9]\d{1,14}$/;
  if (!phoneRegex.test(phone)) {
    return "Invalid phone number format. It should be a valid international phone number.";
  }

  return null;
}

export async function OnboardMemberController(
  firstname: string,
  lastname: string,
  phone: string
): Promise<{ memberDashboard: any } | { error: string }> {
  const validationError = validateInput(firstname, lastname, phone);
  if (validationError) {
    logger.warn("Invalid input for onboarding member", { firstname, lastname, phone, error: validationError });
    return { error: validationError };
  }

  try {
    logger.info("Onboarding new member", { firstname, lastname, phone });

    const onboardedMember = await OnboardMemberService(
      firstname,
      lastname,
      phone
    );

    if (!onboardedMember.onboardedMemberID) {
      logger.warn("Failed to onboard member", { firstname, lastname, phone, error: onboardedMember.message });
      return { error: onboardedMember.message || "Failed to onboard member" };
    }

    logger.info("Member onboarded successfully", { memberID: onboardedMember.onboardedMemberID });

    const memberDashboard = await GetMemberDashboardByPhoneService(phone);
    if (!memberDashboard) {
      logger.warn("Could not retrieve member dashboard after onboarding", { phone });
      return { error: "Could not retrieve member dashboard" };
    }

    logger.info("Member dashboard retrieved successfully", { memberID: onboardedMember.onboardedMemberID });
    return { memberDashboard };
  } catch (error) {
    logger.error("Error in OnboardMemberController", { error, firstname, lastname, phone });
    return { error: "Internal Server Error" };
  }
}

export async function onboardMemberExpressHandler(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): Promise<void> {
  const { firstname, lastname, phone } = req.body;

  try {
    const result = await OnboardMemberController(firstname, lastname, phone);

    if ("error" in result) {
      res.status(400).json({ message: result.error });
    } else {
      res.status(201).json(result);
    }
  } catch (error) {
    logger.error("Error in onboardMemberExpressHandler", { error, firstname, lastname, phone });
    next(error);
  }
}



File: src/api/Member/controllers/getMemberByHandle.ts
----------------------------------------
import express from "express";
import { GetMemberByHandleService } from "../services/GetMemberByHandle";
import logger from "../../../../config/logger";
import { validateMemberHandle } from "../../../utils/validators";

export async function GetMemberByHandleController(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const { memberHandle } = req.body;

  try {
    if (!memberHandle || typeof memberHandle !== 'string') {
      res.status(400).json({ message: "memberHandle is required and must be a string" });
      return;
    }

    if (!validateMemberHandle(memberHandle)) {
      res.status(400).json({
        message: "Invalid member handle. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters.",
      });
      return;
    }

    logger.info("Retrieving member by handle", { memberHandle });

    const memberData = await GetMemberByHandleService(memberHandle);

    if (memberData) {
      logger.info("Member retrieved successfully", { memberHandle });
      res.status(200).json({ memberData });
    } else {
      logger.info("Member not found", { memberHandle });
      res.status(404).json({ message: "Member not found" });
    }
  } catch (error) {
    logger.error("Error in GetMemberByHandleController", { error, memberHandle });
    next(error);
  }
}



File: src/api/Member/controllers/securedCredexAuthForTier.ts
----------------------------------------
import express from "express";
import { SecuredCredexAuthForTier } from "../services/SecuredCredexAuthForTier";
import logger from "../../../../config/logger";
import { getDenominations } from "../../../constants/denominations";

/**
 * Controller for authorizing secured credex for a member's tier
 * @param memberID - ID of the member
 * @param tier - Member's tier
 * @param Amount - Amount for authorization
 * @param Denomination - Denomination for authorization
 * @returns Object containing authorization status and message
 */
export async function SecuredCredexAuthForTierController(
  memberID: string,
  tier: number,
  Amount: number,
  Denomination: string
): Promise<{ isAuthorized: boolean; message: string }> {
  try {
    // Input validation
    if (!memberID || typeof memberID !== 'string') {
      return { isAuthorized: false, message: "Invalid memberID" };
    }

    if (!Number.isInteger(tier) || tier < 1) {
      return { isAuthorized: false, message: "Invalid tier" };
    }

    if (typeof Amount !== 'number' || Amount <= 0) {
      return { isAuthorized: false, message: "Invalid Amount" };
    }

    if (!Denomination || typeof Denomination !== 'string' || !getDenominations({ code: Denomination }).length) {
      return { isAuthorized: false, message: "Invalid Denomination" };
    }

    logger.info("Authorizing secured credex for tier", { memberID, tier, Amount, Denomination });

    const result = await SecuredCredexAuthForTier(memberID, Amount, Denomination);
    
    if (typeof result === 'string') {
      logger.warn("Secured credex authorization failed", { memberID, tier, Amount, Denomination, message: result });
      return { isAuthorized: false, message: result };
    } else {
      logger.info("Secured credex authorization successful", { memberID, tier, Amount, Denomination });
      return { isAuthorized: true, message: "Authorization successful" };
    }
  } catch (error) {
    logger.error("Error in SecuredCredexAuthForTierController", { error, memberID, tier, Amount, Denomination });
    return { isAuthorized: false, message: "Internal Server Error" };
  }
}

/**
 * Express middleware wrapper for secured credex authorization
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
export async function securedCredexAuthForTierExpressHandler(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): Promise<void> {
  const { memberID, tier, Amount, Denomination } = req.body;

  try {
    const result = await SecuredCredexAuthForTierController(memberID, tier, Amount, Denomination);

    if (result.isAuthorized) {
      res.status(200).json(result);
    } else {
      res.status(400).json(result);
    }
  } catch (error) {
    logger.error("Error in securedCredexAuthForTierExpressHandler", { error, memberID, tier, Amount, Denomination });
    next(error);
  }
}



File: src/api/Member/services/SecuredCredexAuthForTier.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { denomFormatter } from "../../../utils/denomUtils";

export async function SecuredCredexAuthForTier(
  issuerAccountID: string,
  amount: number,
  denom: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const queryResult = await ledgerSpaceSession.run(
      `
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        WITH member, member.memberTier AS memberTier

        // If memberTier > 2, return true immediately as "result"
        WHERE memberTier > 2
        RETURN true AS result

        UNION

        // If memberTier <= 2, proceed with the larger search query and return calculated values in an object as "result"
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        WITH member, member.memberTier AS memberTier, account
        WHERE memberTier <= 2
        MATCH (daynode:Daynode { Active: true })
        OPTIONAL MATCH (member)-[:OWNS]->(allAccounts:Account)
        OPTIONAL MATCH
          (allAccounts)-[:OWES|OFFERS]->(credex:Credex)<-[:SECURES]-(Account),
          (credex)-[:CREATED_ON]->(daynode)
        WITH
          daynode.USD AS daynodeUSD,
          SUM(credex.InitialAmount) AS dayTotalCXX,
          $amount * daynode[$denom] AS credexAmountCXX,
          memberTier
        RETURN
          {
            dayTotalUSD: dayTotalCXX / daynodeUSD,
            credexAmountUSD: credexAmountCXX / daynodeUSD,
            memberTier: memberTier
          } AS result
    `,
      { issuerAccountID, amount, denom }
    );

    if (queryResult.records.length === 0) {
      return "query error";
    }
    if (queryResult.records[0].get("result") == true) {
      return true;
    }

    const memberTier = queryResult.records[0].get("result").memberTier;
    const dayTotalUSD = queryResult.records[0].get("result").dayTotalUSD;
    const credexAmountUSD =
      queryResult.records[0].get("result").credexAmountUSD;

    var amountAvailableUSD = 0;
    if (memberTier == 1) {
      amountAvailableUSD = 10 - dayTotalUSD;
    }
    if (memberTier == 2) {
      amountAvailableUSD = 100 - dayTotalUSD;
    }
    if (amountAvailableUSD >= credexAmountUSD) {
      return true;
    } else {
      return (
        "You are only able to issue " +
        denomFormatter(amountAvailableUSD, "USD") +
        " USD until tomorrow. Limits renew at midnight UTC."
      );
    }
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Member/services/GetMemberByHandle.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";

export async function GetMemberByHandleService(
  memberHandle: string
): Promise<any | null> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  if (!memberHandle) {
    console.log("memberHandle is required");
    return null;
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH (member:Member { memberHandle: $memberHandle })
            RETURN
              member.memberID AS memberID,
              member.firstname AS firstname,
              member.lastname AS lastname
        `,
      { memberHandle }
    );

    if (!result.records.length) {
      console.log("member not found");
      return null;
    }

    const memberID = result.records[0].get("memberID");
    const firstname = result.records[0].get("firstname");
    const lastname = result.records[0].get("lastname");

    return {
      memberID: memberID,
      memberName: firstname + " " + lastname,
    };
  } catch (error) {
    console.error("Error fetching member data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Member/services/UpdateMemberTier.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import * as neo4j from "neo4j-driver";

export async function UpdateMemberTierService(
  memberIDtoUpdate: string,
  newTier: number
) {
  if (newTier < 1 || newTier > 5) {
    return {
      message: "New member tier is not a valid value",
    };
  }
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH (member:Member { memberID: $memberIDtoUpdate })
        SET member.memberTier = $newTier
        RETURN
          member.memberID AS memberIDupdated
      `,
      {
        memberIDtoUpdate,
        newTier: neo4j.int(newTier),
      }
    );

    if (!result.records.length) {
      return false;
    }

    const record = result.records[0];

    if (record.get("memberIDupdated")) {
      console.log("Member tier for " + memberIDtoUpdate + " set to " + newTier);
      return true;
    } else {
      console.log("could not authorize account");
      return false;
    }
  } catch (error) {
    console.error("Error updating member tier: ", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Member/services/GetMemberDashboardByPhone.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { denomFormatter } from "../../../utils/denomUtils";

export async function GetMemberDashboardByPhoneService(phone: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
      MATCH (daynode:Daynode { Active: true })
      MATCH (member:Member { phone: $phone })
      OPTIONAL MATCH (member)-[:OWNS]->(account:Account)
      OPTIONAL MATCH (account)-[:OWES|OFFERS]->(credex:Credex)-[:CREATED_ON]->(daynode)
      WITH
        member, daynode,
        COLLECT(account.accountID) AS accountIDs,
        SUM(credex.InitialAmount) AS totalIssuedTodayCXX
      RETURN
        member.memberID AS memberID,
        member.firstname AS firstname,
        member.lastname AS lastname,
        member.memberHandle AS memberHandle,
        member.defaultDenom AS defaultDenom,
        member.memberTier AS memberTier,
        totalIssuedTodayCXX/daynode["USD"] AS totalIssuedTodayUSD,
        accountIDs AS accountIDS
      `,
      { phone }
    );

    if (!result.records.length) {
      console.log("member not found by phone");
      return false;
    }

    const memberTier = result.records[0].get("memberTier").low;
    const totalIssuedTodayUSD = result.records[0].get("totalIssuedTodayUSD");
    console.log(totalIssuedTodayUSD);
    let remainingAvailableUSD: number = Infinity;
    if (memberTier == 1) {
      remainingAvailableUSD = parseFloat(
        denomFormatter(10 - totalIssuedTodayUSD, "USD")
      );
    }
    if (memberTier == 2) {
      remainingAvailableUSD = parseFloat(
        denomFormatter(100 - totalIssuedTodayUSD, "USD")
      );
    }

    return {
      memberID: result.records[0].get("memberID"),
      firstname: result.records[0].get("firstname"),
      lastname: result.records[0].get("lastname"),
      memberHandle: result.records[0].get("memberHandle"),
      defaultDenom: result.records[0].get("defaultDenom"),
      memberTier: memberTier,
      remainingAvailableUSD: remainingAvailableUSD,
      accountIDS: result.records[0].get("accountIDS"),
    };
  } catch (error) {
    console.error("Error fetching account data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/api/Member/services/OnboardMember.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j";
import { getDenominations } from "../../../constants/denominations";

export async function OnboardMemberService(
  firstname: string,
  lastname: string,
  phone: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const defaultDenom = "USD";

  try {
    // Validation: Check defaultDenom in denominations
    if (!getDenominations({ code: defaultDenom }).length) {
      const message = "defaultDenom not in denoms";
      console.log(message);
      return { onboardedMemberID: false, message: message };
    }

    const result = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode { Active: true })
        CREATE (member:Member{
          firstname: $firstname,
          lastname: $lastname,
          memberHandle: $phone,
          defaultDenom: $defaultDenom,
          phone: $phone,
          memberID: randomUUID(),
          memberTier: 1,
          createdAt: datetime(),
          updatedAt: datetime()
        })-[:CREATED_ON]->(daynode)
        RETURN
          member.memberID AS memberID
      `,
      {
        firstname,
        lastname,
        defaultDenom,
        phone,
      }
    );

    if (!result.records.length) {
      const message = "could not onboard member";
      console.log(message);
      return { onboardedMemberID: false, message: message };
    }

    const memberID = result.records[0].get("memberID");

    console.log("member onboarded: " + memberID);
    return {
      onboardedMemberID: memberID,
      message: "member onboarded",
    };
  } catch (error) {
    console.error("Error onboarding member:", error);

    // Type guard to narrow the type of error
    if (
      isNeo4jError(error) &&
      error.code === "Neo.ClientError.Schema.ConstraintValidationFailed"
    ) {
      if (error.message.includes("phone")) {
        return {
          onboardedMemberID: false,
          message: "Phone number already in use",
        };
      }
      if (error.message.includes("memberHandle")) {
        return {
          onboardedMemberID: false,
          message: "Member handle already in use",
        };
      }
      return {
        onboardedMemberID: false,
        message: "Required unique field not unique",
      };
    }

    return {
      onboardedMemberID: false,
      message:
        "Error: " + (error instanceof Error ? error.message : "Unknown error"),
    };
  } finally {
    await ledgerSpaceSession.close();
  }
}

// Type guard to check if an error is a Neo4j error
function isNeo4jError(
  error: unknown
): error is { code: string; message: string } {
  return (
    typeof error === "object" &&
    error !== null &&
    "code" in error &&
    "message" in error
  );
}



File: src/api/Member/memberRoutes.ts
----------------------------------------
import express from "express";
import { GetMemberByHandleController } from "./controllers/getMemberByHandle";
import { GetMemberDashboardByPhoneController } from "./controllers/getMemberDashboardByPhone";
import { updateMemberTierExpressHandler } from "./controllers/updateMemberTier";
import { onboardMemberExpressHandler } from "./controllers/onboardMember";

const router = express.Router();

/**
 * @openapi
 * /member/getMemberByHandle:
 *   post:
 *     tags:
 *       - Member
 *     summary: Get member by handle
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - memberHandle
 *             properties:
 *               memberHandle:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/getMemberByHandle", GetMemberByHandleController);

/**
 * @openapi
 * /member/getMemberDashboardByPhone:
 *   post:
 *     tags:
 *       - Member
 *     summary: Get member dashboard by phone
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - phone
 *             properties:
 *               phone:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/getMemberDashboardByPhone", GetMemberDashboardByPhoneController);

/**
 * @openapi
 * /member/onboardMember:
 *   post:
 *     tags:
 *       - Member
 *     summary: Onboard a new member
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - firstname
 *               - lastname
 *               - phone
 *             properties:
 *               firstname:
 *                 type: string
 *               lastname:
 *                 type: string
 *               phone:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/onboardMember", onboardMemberExpressHandler);

/**
 * @openapi
 * /member/updateMemberTier:
 *   post:
 *     tags:
 *       - Member
 *     summary: Update member tier
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - memberID
 *               - tier
 *             properties:
 *               memberID:
 *                 type: string
 *               tier:
 *                 type: number
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/updateMemberTier", updateMemberTierExpressHandler);

export default router;



File: src/api/AdminDashboard/controllers/ControllerList.md
----------------------------------------
1. AccountController:
   - getReceivedCredexOffers: Handles fetching received credex offers for an account.
   
2. MemberController:
   - getMemberDetails: Retrieves details of a member using memberHandle.
   - updateMemberTier: Updates a member's tier using the memberHandle or memberID.
   - updateMemberStatus: Changes a member's suspended/active status using memberID/memberHandle.
   - logMemberInteraction: Logs interactions with members, such as support calls, emails, or chat sessions.

3. CredexController:
   - getCredexDetails: Retrieves details of a credex using the credexID.

4. AccountActivityController:
   - getAccountActivityLog: Retrieves a log of all activities related to a specific account.
   - exportAccountData: Exports all account-related data for a member.





File: src/api/AdminDashboard/controllers/MemberController.ts
----------------------------------------
import { Request, Response } from 'express';
import GetMemberService from '../services/GetMemberService';
import UpdateMemberTierService from '../services/UpdateMemberTierService';


export async function getMemberDetails(req: Request, res: Response) {
  const { memberHandle } = req.query;

  if (!memberHandle) {
    return res.status(400).json({
      message: 'The memberHandle is required'
    });
  }

  try {
    const result = await GetMemberService(memberHandle as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getMemberDetails controller:', error);
    return res.status(500).json({
      message: 'Error fetching member details',
      error: (error as Error).message 
    });
  }
}

export async function updateMemberTier(req: Request, res: Response) {
  const { memberHandle, newTier } = req.body;

  if (!memberHandle || !newTier) {
    return res.status(400).json({
      message: 'The memberHandle and newTier are required'
    });
  }

  try {
    const result = await UpdateMemberTierService(memberHandle, newTier);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in updateMemberTier controller:', error);  
    return res.status(500).json({
      message: 'Error updating member tier',
      error: (error as Error).message 
    });
  }
}

/*
export async function updateMemberStatus(req: Request, res: Response) {
  const { memberHandle, newStatus } = req.body;

  if (!memberHandle || !newStatus) {
    return res.status(400).json({
      message: 'The memberHandle and newStatus are required'
    });
  }

  try {
    const result = await UpdateMemberStatusService(memberHandle, newStatus);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in updateMemberStatus controller:', error);
    return res.status(500).json({
      message: 'Error updating member status',
      error: (error as Error).message 
    });
  }
}


export async function logMemberInteraction(req: Request, res: Response) {
  const { memberHandle, interactionType, interactionDetails } = req.body;

  if (!memberHandle || !interactionType || !interactionDetails) {
    return res.status(400).json({
      message: 'The memberHandle, interactionType, and interactionDetails are required'
    });
  }

  try {
    const result = await LogMemberInteractionService(memberHandle, interactionType, interactionDetails);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in logMemberInteraction controller:', error);
    return res.status(500).json({
      message: 'Error logging member interaction',
      error: (error as Error).message 
    });
  }
}
  */



File: src/api/AdminDashboard/controllers/CredexController.ts
----------------------------------------
import { Request, Response } from 'express';
import GetCredexService from '../services/GetCredexService';
 

export async function getCredexDetails(req: Request, res: Response) {
  console.log("getCredexDetails controller hit");
  const { credexID } = req.query;

  if (!credexID) {
    return res.status(400).json({
      message: 'The credexID is required'
    });
  }

  try {
    const result = await GetCredexService(credexID as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getCredexDetails controller:', error);
    return res.status(500).json({
      message: 'Error fetching credex details',
      error: (error as Error).message 
    });
  }
}


File: src/api/AdminDashboard/controllers/AccountController.ts
----------------------------------------
import { Request, Response } from 'express';
import GetAccountService from '../services/GetAccountService';
import GetAccountReceivedCredexOffers from '../services/GetAccountReceivedCredexOffers';
import GetAccountSentCredexOffers from '../services/GetAccountSentCredexOffers';

export async function getAccountDetails(req: Request, res: Response) {
  const { accountID, accountHandle } = req.query;

  if (!accountHandle && !accountID) {
    return res.status(400).json({
      message: 'The AccountID or accountHandle is required'
    });
  }

  try {
    const result = await GetAccountService(accountHandle as string, accountID as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getAccountDetails controller:', error);
    return res.status(500).json({
      message: 'Error fetching account details',
      error: (error as Error).message 
    });
  }
}

export async function getReceivedCredexOffers(req: Request, res: Response) {
  const {accountHandle, accountID } = req.query;

  if (!accountHandle && !accountID) {
    return res.status(400).json({
      message: 'The AccountID or accountHandle is required'
    });
  }

  try {
    const result = await GetAccountReceivedCredexOffers(accountHandle as string, accountID as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getReceivedCredexOffers controller:', error);
    return res.status(500).json({
      message: 'Error fetching received credex offers',
      error: (error as Error).message 
    });
  }
}

export async function getSentCredexOffers(req: Request, res: Response) {
  const { accountID, accountHandle } = req.query;

  if ( !accountHandle) {
    return res.status(400).json({
      message: 'The AccountID or accountHandle is required'
    });
  }

  try {
    const result = await GetAccountSentCredexOffers(accountHandle as string, accountID as string);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in getSentCredexOffers controller:', error);
    return res.status(500).json({
      message: 'Error fetching sent credex offers',
      error: (error as Error).message 
    });
  }
}


File: src/api/AdminDashboard/middleware/requestLogger.ts
----------------------------------------



File: src/api/AdminDashboard/middleware/authMiddleware.ts
----------------------------------------
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

const secretKey = process.env.JWT_SECRET_KEY || 'your-secret-key';

export function authMiddleware(req: Request, res: Response, next: NextFunction) {
  const token = req.headers['authorization'];
  if (!token) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const decoded = jwt.verify(token, secretKey);
    (req as any).user = decoded;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}


File: src/api/AdminDashboard/middleware/errorHandler.ts
----------------------------------------



File: src/api/AdminDashboard/middleware/validateRequest.ts
----------------------------------------



File: src/api/AdminDashboard/services/GetCredexService.ts
----------------------------------------
/* 
GetCredexService:
- Retrieve details of a credex using the credexID
*/

import { ledgerSpaceDriver } from "../../../../config/neo4j"

export default async function GetCredexService(credexID: string): Promise<any> {
  if(!credexID){
    return {
      message: 'CredexID is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()

  try {
    const credexResult = await ledgerSpaceSession.run(
      `MATCH (credex:Credex {credexID:$credexID})<-[:OFFERED]-(sendingAccount:Account)
        WITH credex, sendingAccount
        MATCH (credex)-[:OFFERED]-> (receivingAccount:Account)
        RETURN 
          credex.credexID AS credexID,
          credex.credexType AS credexType,
          credex.Denomination AS credexDenomination,
          credex.InitialAmount AS credexInitialAmount,
          credex.OutstandingAmount AS credexOutstandingAmount,
          credex.CXXmultiplier AS credexCXXmultiplier,
          credex.WrittenOffAmount AS credexWrittenOffAmount,
          credex.DefaultedAmount AS credexDefaultedAmount,
          credex.RedeemedAmount AS credexRedeemedAmount,
          credex.queueStatus AS credexQueueStatus,
          credex.acceptedAt AS credexAcceptedAt,
          credex.createdAt AS credexCreatedAt,
          sendingAccount.accountID AS sendingAccountID,
          sendingAccount.accountName AS sendingAccountName,
          sendingAccount.accountHandle AS sendingAccountHandle,
          sendingAccount.accountType AS sendingAccountType,
          receivingAccount.accountID AS receivingAccountID,
          receivingAccount.accountName AS receivingAccountName,
          receivingAccount.accountHandle AS receivingAccountHandle,
          receivingAccount.accountType AS receivingAccountType`,
          { credexID }
    )

    const credex = credexResult.records.map((record) => {
      return {
        credexID: record.get("credexID"),
        credexType: record.get("credexType"),
        credexDenomination: record.get("credexDenomination"),
        credexInitialAmount: record.get("credexInitialAmount"),
        credexOutstandingAmount: record.get("credexOutstandingAmount"),
        credexCXXmultiplier: record.get("credexCXXmultiplier"),
        credexWrittenOffAmount: record.get("credexWrittenOffAmount"),
        credexDefaultedAmount: record.get("credexDefaultedAmount"),
        credexRedeemedAmount: record.get("credexRedeemedAmount"),
        credexQueueStatus: record.get("credexQueueStatus"),
        credexAcceptedAt: record.get("credexAcceptedAt"),
        credexCreatedAt: record.get("credexCreatedAt"),
        sendingAccountID: record.get("sendingAccountID"), 
        sendingAccountName: record.get("sendingAccountName"),
        sendingAccountHandle: record.get("sendingAccountHandle"),
        sendingAccountType: record.get("sendingAccountType"),
        receivingAccountID: record.get("receivingAccountID"),
        receivingAccountName: record.get("receivingAccountName"),
        receivingAccountHandle: record.get("receivingAccountHandle"),
        receivingAccountType: record.get("receivingAccountType")
      }
    }); 

    if(!credex.length) {
      return {
        message: 'Credex not found'
      }
    }

    return {
      message: 'Credex retrieved successfully',
      data: {
        credex
      }
    }
  }
  catch (error) {
    console.error(error)
    return {
      message: 'Error retrieving credex',
      error: error
    }
  }
}


File: src/api/AdminDashboard/services/GetAccountService.ts
----------------------------------------
/*
  ToDo:
    - Add the accountID to the query
    
*/

/* 
 Query an account using the accountID or accountHandle to get all information associated with the account
*/

import { ledgerSpaceDriver } from "../../../../config/neo4j"

export default async function GetAccount(accountHandle: string, accountID: string): Promise<any> {
  if(!accountHandle && !accountID){
    return {
      message: 'The AccountID or accountHandle is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()

  const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
  const parameters = accountHandle ? { accountHandle } : { accountID };

 try {
  const query =
  `MATCH (account:Account {${accountMatchCondition}})<-[:OWNS]-(member:Member)
    WITH account, member
    OPTIONAL MATCH (account)-[:OWES]->(owedCredex)-[:OWES]->(owedAccount)
    WITH member, account, COLLECT(owedCredex.credexID) AS owedCredexes, COLLECT(owedAccount.accountID) AS owedAccounts
    RETURN
      member.memberID AS accountOwnerID,
      member.memberHandle AS accountOwnerHandle,
      member.memberTier AS accountOwnerTier,
      account.accountID AS accountID,
      account.accountName AS accountName,
      account.accountHandle AS accountHandle,
      account.accountType AS accountType,
      account.createdAt AS accountCreatedAt,
      account.updatedAt AS accountUpdatedAt,
      COUNT(owedCredexes) AS numberOfCredexOwed,
      owedCredexes,
      owedAccounts

    `;

    const  accountResult = await ledgerSpaceSession.run(query, parameters)  

  const account = accountResult.records.map((record) => {
    return {
      accountOwnerID: record.get("accountOwnerID"),
      accountOwnerHandle: record.get("accountOwnerHandle"),
      accountOwnerTier: record.get("accountOwnerTier"),
      accountID: record.get("accountID"),
      accountName: record.get("accountName"),
      accountHandle: record.get("accountHandle"), 
      accountType: record.get("accountType"),
      accountCreatedAt: record.get("accountCreatedAt"),
      accountUpdatedAt: record.get("accountUpdatedAt"),
      numberOfCredexOwed: record.get("numberOfCredexOwed"),
      owedCredexes: record.get("owedCredexes"),
      owedAccounts: record.get("owedAccounts")
    }
  })

  if(!account.length) {
    return {
      message: 'Account not found'
    }
  }

  return {
    message: 'Account fetched successfully',
    data: account 
  }
 } catch (error) {
  return {
    message: 'Error fetching account',
    error: error
  }
 }
}


File: src/api/AdminDashboard/services/GetMemberService.ts
----------------------------------------
/*
 Query a member using memberHandle  

*/

import { ledgerSpaceDriver } from "../../../../config/neo4j"


export default async function GetMemberService(memberHandle: string):Promise<any> {
  if(!memberHandle){
    return {
      message: 'The memberHandle is required'
    }
  }
  
  const ledgerSpaceSession = ledgerSpaceDriver.session()
  try {
    const result = await ledgerSpaceSession.run(
      `Match (member:Member)
          WHERE member.memberHandle = $memberHandle
          WITH member
          MATCH (member)-[:OWNS]->(account:Account)
            Return
              member.memberID AS memberID,
              member.memberHandle AS memmberHandle,
              member.firstname AS firstname,
              member.lastname AS lastname,
              member.phone AS phone, 
              member.memberTier AS memberTier,
              count(account) AS numberOfAccounts,
              member.defaultDenom AS defaultDenom,
              member.updatedAt AS updatedAt,        
              member.createdAt AS createdAt
      `,
      { memberHandle }
    );

    const records = result.records.map((record) => {
      return {
       memberID: record.get("memberID"),
       memberHandle: record.get("memmberHandle"),
       firstname: record.get("firstname"),
       lastname: record.get("lastname"),
       phone: record.get("phone"),
       memberTier: record.get("memberTier"),
       defaultDenom: record.get("defaultDenom"),
       updatedAt: record.get("updatedAt"),
       createdAt: record.get("createdAt"),
      }
    });

    if(!records.length){
      return {
        message: 'User not found',
      }
    }

    return {
      message: 'User fetched successfully',
      data: records
    }
  
  } catch (error) {
    console.error('Error fetching user:', error);
    return {
      message: 'Error fetching user',
      error: error,
    };
    
  }
  finally {
    await ledgerSpaceSession.close()
  }
}


File: src/api/AdminDashboard/services/UpdateMemberTierService.ts
----------------------------------------
/* 
Update a members tier using the memberHandle or memberID
*/
import { ledgerSpaceDriver } from "../../../../config/neo4j"

export default async function UpdateMemberTierService(memberHandle: string, newTier: string): Promise<any> {
  if(!memberHandle || !newTier){
    return {
      message: 'The memberHandle and memberTier are required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()

  try {
    const result = await ledgerSpaceSession.run(
      `MATCH (member:Member {memberHandle: $memberHandle})
       SET member.memberTier = $newTier 
       RETURN member.memberID AS memberID, member.memberHandle AS memberHandle, member.memberTier AS memberTier`,
       {memberHandle, newTier}
    )

    const member = result.records.map((record) => {
      return {
        memberID: record.get("memberID"),
        memberHandle: record.get("memberHandle"),
        memberTier: record.get("memberTier")
      }
    })    

    return {
      message: 'Member tier updated successfully',
      data: member
    }
  } catch (error) {
    return {
      message: `Error updating member tier ${memberHandle}, ${newTier}`,
      error: error
    }
  } finally {
    await ledgerSpaceSession.close()
  }
}


File: src/api/AdminDashboard/services/ServicesList.md
----------------------------------------
1. GetAccountService: 
  - Retrieve details of the account
  - 
2. GetMemberAccounts:
  - Retrieve accounts owned by user
  - 
3. GetMemberService:
  - retreive details of a member using memmberID
  -
4. GetSentCredexOffers:
  - using accountID retreive sent credexOffers
  - 
5. GetReceivedCredexOffers:
  - using accountID retreive received credexOffers
  - 
6. UpdateMemberTier:
  - Using MemmberHandle update MemberTier
  -
7. UpdateMemberStatus
  - using memberID/memberHandle change members suspended/active status
  -
8. UpdateAccountStatus:
  - using accountID/accountHandle change members
  -
9. GetAccountActivityLogService:
  **Purpose:** Retrieve a log of all activities related to a specific account, useful for auditing and support inquiries.
  **Parameters**: `accountID` (required), `dateRange` (optional)
  **Response:** Returns a list of activities including timestamps, actions taken, and any associated details.
10. ExportAccountData:
  **Purpose:** Export all account-related data for a member, useful for compliance with data portability regulations.
  **Parameters:** accountID, format (optional, e.g., CSV, JSON)
  **Response:** Provides a downloadable link to the exported data.
11. LogMemberInteraction:
  **Purpose:** Allow the operations team to log interactions with members, such as support calls, emails, or chat sessions.
  **Parameters:** memberID or memberHandle, interactionType, interactionDetails (required)
  **Response:** Confirms the interaction has been logged.
12. GetAccountActivityLog:
  **Purpose:** Retrieve a log of all activities related to a specific account, useful for auditing and support inquiries.
  **Parameters:** accountID (required), dateRange (optional)
  **Response:** Returns a list of activities including timestamps, actions taken, and any associated details.


File: src/api/AdminDashboard/services/GetAccountReceivedCredexOffers.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../../config/neo4j"

export default async function GetAccountReceivedCredexOffers( accountHandle?: string, accountID?: string): Promise<any> {
  if (!accountHandle && !accountID) {
    return {
      message: 'Either accountHandle or accountID is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()
  
  const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
  const parameters = accountHandle ? { accountHandle } : { accountID };

  try {
    const query = `
      MATCH (account:Account {${accountMatchCondition}})<-[:OFFERED]-(receivedCredexOffer)<-[:OFFERED]-(sendingAccount)
      RETURN
        receivedCredexOffer.credexID AS receivedCredexOfferID,
        receivedCredexOffer.credexType AS receivedCredexOfferType,
        receivedCredexOffer.Denomination AS receivedCredexOfferDenomination,
        receivedCredexOffer.InitialAmount AS receivedCredexOfferInitialAmount,
        receivedCredexOffer.OutstandingAmount AS receivedCredexOfferOutstandingAmount,
        receivedCredexOffer.DefaultedAmount AS receivedCredexOfferDefaultedAmount,
        receivedCredexOffer.RedeemedAmount AS receivedCredexOfferRedeemedAmount,
        receivedCredexOffer.queueStatus AS receivedCredexOfferQueueStatus,
        receivedCredexOffer.CXXmultiplier AS receivedCredexOfferCXXmultiplier,
        receivedCredexOffer.WrittenOffAmount AS receivedCredexOfferWrittenOffAmount,
        receivedCredexOffer.dueDate AS receivedCredexOfferDueDate,
        receivedCredexOffer.createdAt AS receivedCredexOfferCreatedAt,
        sendingAccount.accountID AS sendingAccountID,
        sendingAccount.defaultDenom AS sendingAccountDefaultDenom,
        sendingAccount.accountHandle AS sendingAccountHandle
    `;

    const accountReceivedCredexOffersResult = await ledgerSpaceSession.run(query, parameters);

    const accountReceivedCredexOffers = accountReceivedCredexOffersResult.records.map((record) => ({
      receivedCredexOfferID: record.get("receivedCredexOfferID"),
      receivedCredexOfferType: record.get("receivedCredexOfferType"),
      receivedCredexOfferDenomination: record.get("receivedCredexOfferDenomination"),
      receivedCredexOfferInitialAmount: record.get("receivedCredexOfferInitialAmount"),
      receivedCredexOfferOutstandingAmount: record.get("receivedCredexOfferOutstandingAmount"),
      receivedCredexOfferDefaultedAmount: record.get("receivedCredexOfferDefaultedAmount"),
      receivedCredexOfferRedeemedAmount: record.get("receivedCredexOfferRedeemedAmount"),
      receivedCredexOfferQueueStatus: record.get("receivedCredexOfferQueueStatus"),
      receivedCredexOfferCXXmultiplier: record.get("receivedCredexOfferCXXmultiplier"),
      receivedCredexOfferWrittenOffAmount: record.get("receivedCredexOfferWrittenOffAmount"),
      receivedCredexOfferDueDate: record.get("receivedCredexOfferDueDate"),
      receivedCredexOfferCreatedAt: record.get("receivedCredexOfferCreatedAt"),
      sendingAccountID: record.get("sendingAccountID"),
      sendingAccountDefaultDenom: record.get("sendingAccountDefaultDenom"),
      sendingAccountHandle: record.get("sendingAccountHandle")
    }));

    if(!accountReceivedCredexOffers.length) {
      return {
        message: 'Account received credex offers not found'
      }
    }

    return {
      message: 'Account received credex offers fetched successfully',
      data: {
        accountReceivedCredexOffers
      }
    }
  } catch (error) {
    console.error('Error fetching account received credex offers:', error);
    return {
      message: 'Error fetching account received credex offers',
      error: error
    }
  } finally {
    await ledgerSpaceSession.close()
  }
}



File: src/api/AdminDashboard/services/GetMemberAccountsOwnerByMemberSevice.ts
----------------------------------------
/* 
Query to a member to get acounts ownde by use using memberID
*/

import { ledgerSpaceDriver } from "../../../../config/neo4j"


export default async function GetMemberAccountsOwnerByMemberSevice(memberID:string) {
  if(!memberID){
    return{
      message:'The memberID is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()

  try {
    const accountsOwnedByMemberResult = await ledgerSpaceSession.run(
      `MATCH (member:Member {memberID:$memberID})-[:OWNS] ->(account:Account)
        RETURN
          account.accountID AS accountID,
          account.accountHandle AS accountHandle,
          account.accountName AS accountName,
          account.defaultDenom AS defaultDenom,
          account.accountType AS accountType,
          account.queueStatus AS queueStatus,
          account.createdAt AS createdAt,
          account.updatedAt AS updatedAt
      `,{memberID}
    );
  
    const accountsOwnedByMember = accountsOwnedByMemberResult.records.map((record) => {
      return {
        accountID: record.get("accountID"),
        accountHandle: record.get("accountHandle"),
        accountName: record.get("accountName"),
        defaultDenom: record.get("defaultDenom"),
        accountType: record.get("accountType"),
        queueStatus: record.get("queueStatus"),
        createdAt: record.get("createdAt"),
        updatedAt: record.get("updatedAt")
      }
    })

    if(!accountsOwnedByMember.length) {
      return {
        message: 'Accounts owned by member not found'
      }
    }
  
    return {
      message:'Accounts owned by member fetched successfully',
      data:accountsOwnedByMember,
    }
  } catch (error) {
    console.error('Error fetching accounts owned by member:', error);
    return {
      message:'Error fetching accounts owned by member',
      error:error
    }
  } finally {
    await ledgerSpaceSession.close()
  }
}


File: src/api/AdminDashboard/services/GetAccountSentCredexOffers.ts
----------------------------------------
/*
  ToDo:
    - Add the accountID to the query
    
*/

/* 
 Query an account to get all sent credex offers
*/

import { ledgerSpaceDriver } from "../../../../config/neo4j"

export default async function GetAccountService( accountHandle: string, accountID: string): Promise<any> {
  if(!accountHandle){
    return {
      message: 'The AccountID or accountHandle is required'
    }
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session()
  // Get all outgoing credex offers from the account using the accountID or accountHandle to get the account and then get the receivingNode which can be a member or an account
  
   
  const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
  const parameters = accountHandle ? { accountHandle } : { accountID };
  
  try {
    const query = 
      `MATCH (account:Account {${accountMatchCondition}})-[:OFFERED]->(offeredCredex)-[:OFFERED]->(receivingAccount) 
        RETURN
        offeredCredex.credexID AS offeredCredexID,
        offeredCredex.credexType AS offeredCredexType,
        offeredCredex.Denomination AS offeredCredexDenomination,
        offeredCredex.InitialAmount AS offeredCredexInitialAmount,
        offeredCredex.OutstandingAmount AS offeredCredexOutstandingAmount,
        offeredCredex.DefaultedAmount AS offeredCredexDefaultedAmount,
        offeredCredex.RedeemedAmount AS offeredCredexRedeemedAmount,
        offeredCredex.queueStatus AS offeredCredexQueueStatus,
        offeredCredex.CXXmultiplier AS offeredCredexCXXmultiplier,
        offeredCredex.WrittenOffAmount AS offeredCredexWrittenOffAmount,
        offeredCredex.dueDate AS offeredCredexDueDate,
        offeredCredex.createdAt AS offeredCredexCreatedAt,
        receivingAccount.accountID AS receivingAccountID,
        receivingAccount.defaultDenom AS receivingAccountDefaultDenom,
        receivingAccount.accountHandle AS receivingAccountHandle

      `;
      const accountOfferedCredexResult = await ledgerSpaceSession.run(query, parameters)
    
   const accountOfferedCredex = accountOfferedCredexResult.records.map((record) => {
    return {
     offeredCredexID: record.get("offeredCredexID"),
     offeredCredexType: record.get("offeredCredexType"),
     offeredCredexDenomination: record.get("offeredCredexDenomination"),
     offeredCredexInitialAmount: record.get("offeredCredexInitialAmount"),
     offeredCredexOutstandingAmount: record.get("offeredCredexOutstandingAmount"),
     offeredCredexDefaultedAmount: record.get("offeredCredexDefaultedAmount"),
     offeredCredexRedeemedAmount: record.get("offeredCredexRedeemedAmount"),
     offeredCredexQueueStatus: record.get("offeredCredexQueueStatus"),
     offeredCredexCXXmultiplier: record.get("offeredCredexCXXmultiplier"),
     offeredCredexWrittenOffAmount: record.get("offeredCredexWrittenOffAmount"),
     offeredCredexDueDate: record.get("offeredCredexDueDate"),
     offeredCredexCreatedAt: record.get("offeredCredexCreatedAt"),
     receivingAccountID: record.get("receivingAccountID"),
     receivingAccountDefaultDenom: record.get("receivingAccountDefaultDenom"),
     receivingAccountHandle: record.get("receivingAccountHandle"),
    }
   });

   if(!accountOfferedCredex.length) {
    return {
      message: 'Account sent credex offers not found'
    }
   }
  

    return {
      message: 'Account credex offers fetched successfully',
      data: {
        accountOfferedCredex,
      }
    }

  } catch (error) {
    console.error('Error fetching account:', error);
    return {
      message: 'Error fetching account',
      error: error,
    };
  } finally {
    await ledgerSpaceSession.close();
  }
}


File: src/api/AdminDashboard/adminDashboardRoutes.ts
----------------------------------------
import express from "express"
import { apiVersionOneRoute } from "../../index"
import { authMiddleware } from "./middleware/authMiddleware";
import { getCredexDetails } from "./controllers/CredexController";
import { getMemberDetails, updateMemberTier } from "./controllers/MemberController";
import { getAccountDetails, getReceivedCredexOffers, getSentCredexOffers } from "./controllers/AccountController";
/*
function logRoute(req: express.Request, res: express.Response, next: express.NextFunction) {
  console.log("getCredexDetails route hit");
  next();
}
*/


export default function AdminDashboardRoutes(app: express.Application, jsonParser:any){
  app.get(`${apiVersionOneRoute}getCredexDetails`,
    //logRoute,
    jsonParser,     
    getCredexDetails
  );

  app.get(`${apiVersionOneRoute}getMemberDetails`,
    jsonParser,      
    getMemberDetails
  );

  
  app.patch(`${apiVersionOneRoute}updateMemberTier`,
    jsonParser,    
    updateMemberTier
  );

  app.get(`${apiVersionOneRoute}getAccountDetails`,
    jsonParser,     
    getAccountDetails
  );

  app.get(`${apiVersionOneRoute}getReceivedCredexOffers`,
    jsonParser,      
    getReceivedCredexOffers
  );

  app.get(`${apiVersionOneRoute}getSentCredexOffers`,
    jsonParser,    
    getSentCredexOffers
  );

  /*
  app.get(`${apiVersionOneRoute}getAccountActivityLog`,
    jsonParser, 
    authMiddleware, 
    getAccountActivityLog
  );
  */

  /*
  app.put(`${apiVersionOneRoute}updateMemberStatus`,
    jsonParser, 
    authMiddleware, 
    updateMemberStatus
  );
  */
}


File: src/core-cron/DCO/DailyCredcoinOffering.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { DBinitialization } from "./DBinitialization";
import { DCOexecute } from "./DCOexecute";
import { DCOavatars } from "./DCOavatars";
import logger from "../../../config/logger";

/**
 * Executes the Daily Credcoin Offering (DCO) process.
 * This function checks for an active daynode, initializes the database if necessary,
 * and runs the DCO execution and avatar update processes.
 * 
 * @returns {Promise<boolean>} Returns true if the DCO process completes successfully, false otherwise.
 */
export async function DailyCredcoinOffering(): Promise<boolean> {
  console.log("Starting Daily Credcoin Offering process");
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Check for active daynode
    const daynodeExists = await checkActiveDaynode(ledgerSpaceSession);

    if (!daynodeExists) {
      console.log("No active daynode found. Initializing database...");
      await DBinitialization();
      console.log("Database initialization complete");
    }

    await DCOexecute();
    await DCOavatars();

    return true;
  } catch (error) {
    logger.error("Error in DailyCredcoinOffering", error);
    return false;
  } finally {
    await resetDCORunningFlag(ledgerSpaceSession);
    await ledgerSpaceSession.close();
  }
}

/**
 * Checks if an active daynode exists in the database.
 * 
 * @param {Neo4jSession} session - The Neo4j session to use for the query.
 * @returns {Promise<boolean>} Returns true if an active daynode exists, false otherwise.
 */
async function checkActiveDaynode(session: any): Promise<boolean> {
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN daynode IS NOT NULL AS activeDaynodeExists
  `);
  return result.records[0].get("activeDaynodeExists");
}

/**
 * Resets the DCOrunningNow flag on the active daynode.
 * 
 * @param {Neo4jSession} session - The Neo4j session to use for the query.
 */
async function resetDCORunningFlag(session: any): Promise<void> {
  console.log("Resetting DCOrunningNow flag");
  await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    SET daynode.DCOrunningNow = false
  `);
}



File: src/core-cron/DCO/fetchZigRate.ts
----------------------------------------
import axios from "axios";
import cheerio from "cheerio";

const https = require("https");

const url = "https://www.rbz.co.zw/index.php";

const httpsAgent = new https.Agent({
  rejectUnauthorized: false, // To Ignore SSL errors in dev
});

export async function fetchZigRate(): Promise<
  { currency: string; bid: string; ask: string; avg: string }[]
> {
  try {
    const { data } = await axios.get(url, { httpsAgent });
    const parsedHtml = cheerio.load(data);

    const rates: { currency: string; bid: string; ask: string; avg: string }[] =
      [];

    parsedHtml("#baTab1 table tbody tr").each((index: number, element: any) => {
      const currency: string = parsedHtml(element)
        .find("td")
        .eq(0)
        .text()
        .trim();
      const bid: string = parsedHtml(element).find("td").eq(1).text().trim();
      const ask: string = parsedHtml(element).find("td").eq(2).text().trim();
      const avg: string = parsedHtml(element).find("td").eq(3).text().trim();

      if (currency && bid && ask && avg) {
        rates.push({ currency, bid, ask, avg });
      }
    });
    //console.log(rates);
    return rates;
  } catch (error) {
    console.error("Error fetching exchange rates:", error);
    return [];
  }
}



File: src/core-cron/DCO/DCOavatars.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";
import moment from "moment-timezone";

/**
 * DCOavatars function
 * This function is run as a cronjob every 24 hours to process recurring avatars.
 * It identifies active recurring avatars, creates credexes, and updates there status.
 */
export async function DCOavatars() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    console.log("Checking for activated recurring avatars...");
    
    // Query to get active recurring avatars that are due for processing
    const GetActiveRecurringAvatars = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      MATCH
        (issuer:Account)-[rel1:ACTIVE]->
        (avatar:Avatar { avatarType: "RECURRING", nextPayDate: daynode.Date})-[rel2:ACTIVE]->
        (acceptor:Account)
      MATCH
        (issuer)<-[authRel1:AUTHORIZED_FOR]-
        (avatar)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2
      
      // Reduce remainingPays by 1 if it exists
      SET avatar.remainingPays = 
        CASE
          WHEN avatar.remainingPays IS NOT NULL THEN avatar.remainingPays - 1
          ELSE null
        END
      
      // Calculate the new nextPayDate
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2,
           CASE
             WHEN avatar.remainingPays IS NULL OR avatar.remainingPays > 0 
             THEN date(avatar.nextPayDate) + duration({days: avatar.daysBetweenPays})
             ELSE null
           END AS newNextPayDate
      
      // Update nextPayDate
      SET avatar.nextPayDate = newNextPayDate
      
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2, newNextPayDate
      
      // Check if the avatar should be marked as completed
      OPTIONAL MATCH (issuer)-[completed1:COMPLETED]->(avatar)-[completed2:COMPLETED]->(acceptor)
      FOREACH(ignoreMe IN CASE WHEN newNextPayDate IS NULL AND completed1 IS NULL
               THEN [1] ELSE [] END |
        DELETE rel1, rel2
        SET
          authRel1.markedToDelete = true,
          authRel2.markedToDelete = true
        CREATE (issuer)-[:COMPLETED]->(avatar)-[:COMPLETED]->(acceptor)
      )
      
      RETURN
        avatar {
          .*,
          remainingPays: avatar.remainingPays,
          nextPayDate: avatar.nextPayDate
        } AS avatar,
        issuer.accountID AS issuerAccountID,
        acceptor.accountID AS acceptorAccountID,
        daynode.Date AS Date    
    `);

    // Process each active recurring avatar
    for (const record of GetActiveRecurringAvatars.records) {
      const avatar = record.get("avatar");
      const issuerAccountID = record.get("issuerAccountID");
      const acceptorAccountID = record.get("acceptorAccountID");

      try {
        // Prepare data for creating a new credex
        const offerData: any = {
          memberID: avatar.memberID,
          issuerAccountID: issuerAccountID,
          receiverAccountID: acceptorAccountID,
          Denomination: avatar.Denomination,
          InitialAmount: avatar.InitialAmount,
          credexType: "PURCHASE",
          OFFERSorREQUESTS: "OFFERS",
        };

        // Handle secured and unsecured credexes differently
        if (avatar.securedCredex) {
          offerData.securedCredex = true;
        } else {
          // Calculate dueDate for unsecured credexes using the avatar's credspan
          avatar.dueDate = moment(record.get("Date"))
            .add(parseInt(avatar.credspan), "days")
            .subtract(parseInt("1"), "month")
            .format("YYYY-MM-DD");
          
          offerData.dueDate = avatar.dueDate;
        }

        // Create a new credex offer
        const offerResult = await OfferCredexService(offerData);

        // If offer is successful, automatically accept it
        if (
          offerResult &&
          typeof offerResult.credex === "object" &&
          offerResult.credex.credexID
        ) {
          const acceptResult = await AcceptCredexService(
            offerResult.credex.credexID,
            avatar.memberID
          );
          if (acceptResult) {
            console.log(
              `Successfully created credex for recurring avatar: ${avatar.memberID}. Remaining pays: ${avatar.remainingPays}, Next pay date: ${avatar.nextPayDate}`
            );
          } else {
            throw new Error(`Failed to accept credex for avatar: ${avatar.memberID}`);
          }
        } else {
          throw new Error(`Failed to create offer for avatar: ${avatar.memberID}`);
        }

        const deleteAvatarAuths = await ledgerSpaceSession.run(`
          MATCH ()-[rel:AUTHORIZED_FOR {markedToDelete: true}]->()
          DELETE rel
          `);

      } catch (error) {
        console.error(`Error processing avatar ${avatar.memberID}:`, error);
        // TODO: Implement member notification about the failure
        console.log(`Placeholder: Notify member ${avatar.memberID} about the failure in processing their recurring avatar.`);
      }
    }
  } catch (error) {
    console.error("Error in DCOavatars:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: src/core-cron/DCO/DCOexecute.ts
----------------------------------------
import axios from "axios";
import _ from "lodash";
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { getDenominations, Denomination } from "../../constants/denominations";
import { GetSecuredAuthorizationService } from "../../api/Credex/services/GetSecuredAuthorization";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";
import { fetchZigRate } from "./fetchZigRate";
import { createNeo4jBackup } from "./DBbackup";
import logger from "../../../config/logger";

interface Rates {
  [key: string]: number;
}

interface Participant {
  accountID: string;
  DCOmemberID: string;
  DCOgiveInCXX: number;
  DCOgiveInDenom: number;
  DCOdenom: string;
}

/**
 * Executes the Daily Credcoin Offering (DCO) process.
 * This function handles the daily operations of the Credcoin system,
 * including rate updates, participant validation, and transaction processing.
 */
export async function DCOexecute(): Promise<boolean> {
  console.log("Starting DCOexecute");
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    await waitForMTQCompletion(ledgerSpaceSession);
    const { previousDate, nextDate } = await setDCORunningFlag(
      ledgerSpaceSession
    );

    await createNeo4jBackup(previousDate, "_end");
    await handleDefaultingCredexes(ledgerSpaceSession);
    await expirePendingOffers(ledgerSpaceSession);

    const USDbaseRates = await fetchCurrencyRates(nextDate);
    const {
      newCXXrates,
      CXXprior_CXXcurrent,
      DCOinCXX,
      DCOinXAU,
      numberConfirmedParticipants,
    } = await processDCOParticipants(ledgerSpaceSession, USDbaseRates);

    await createNewDaynode(
      ledgerSpaceSession,
      newCXXrates,
      nextDate,
      CXXprior_CXXcurrent
    );
    await updateCredexBalances(
      ledgerSpaceSession,
      searchSpaceSession,
      newCXXrates,
      CXXprior_CXXcurrent
    );

    const { foundationID, foundationXOid } = await getFoundationData(
      ledgerSpaceSession
    );
    await processDCOTransactions(
      ledgerSpaceSession,
      foundationID,
      foundationXOid,
      DCOinCXX,
      numberConfirmedParticipants
    );

    await createNeo4jBackup(nextDate, "_start");
    console.log(`DCOexecute completed for ${nextDate}`);

    return true;
  } catch (error) {
    logger.error("Error during DCOexecute", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}

async function waitForMTQCompletion(session: any): Promise<void> {
  console.log("Waiting for MTQ completion");
  let MTQflag = true;
  while (MTQflag) {
    const result = await session.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.MTQrunningNow AS MTQflag
    `);
    MTQflag = result.records[0]?.get("MTQflag");
    if (MTQflag) {
      console.log("MTQ running. Waiting 5 seconds...");
      await new Promise((resolve) => setTimeout(resolve, 5000));
    }
  }
  console.log("MTQ not running. Proceeding...");
}

async function setDCORunningFlag(
  session: any
): Promise<{ previousDate: string; nextDate: string }> {
  console.log("Setting DCOrunningNow flag");
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    SET daynode.DCOrunningNow = true
    RETURN
      daynode.Date AS previousDate,
      daynode.Date + Duration({days: 1}) AS nextDate
  `);
  const previousDate = result.records[0].get("previousDate");
  const nextDate = result.records[0].get("nextDate");
  console.log(`Expiring day: ${previousDate}`);
  return { previousDate, nextDate };
}

async function handleDefaultingCredexes(session: any): Promise<void> {
  console.log("Processing defaulting unsecured credexes");
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    OPTIONAL MATCH (account1:Account)-[rel1:OWES]->(defaulting:Credex)-[rel2:OWES]->(account2:Account)
    WHERE defaulting.dueDate <= daynode.Date AND defaulting.DefaultedAmount <= 0
    SET defaulting.DefaultedAmount = defaulting.OutstandingAmount
    WITH defaulting, daynode
    UNWIND defaulting AS defaultingCredex
    CREATE (defaultingCredex)-[:DEFAULTED_ON]->(daynode)
    RETURN count(defaulting) AS numberDefaulted
  `);
  const numberDefaulted = result.records[0]?.get("numberDefaulted") || 0;
  console.log(`Defaults: ${numberDefaulted}`);
}

async function expirePendingOffers(session: any): Promise<void> {
  console.log("Expiring pending offers/requests");
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    OPTIONAL MATCH (:Account)-[rel1:OFFERS|REQUESTS]->(expiringPending:Credex)-[rel2:OFFERS|REQUESTS]->(:Account),
    (expiringPending)-[:CREATED_ON]->(createdDaynode:Daynode)
    WHERE createdDaynode.Date + Duration({days: 1}) < daynode.Date
    DELETE rel1, rel2
    RETURN count(expiringPending) AS numberExpiringPending
  `);
  const numberExpiringPending =
    result.records[0]?.get("numberExpiringPending") || 0;
  console.log(`Expired pending offers/requests: ${numberExpiringPending}`);
}

async function fetchCurrencyRates(nextDate: string): Promise<Rates> {
  console.log("Fetching currency rates");
  const symbols = getDenominations({
    sourceForRate: "OpenExchangeRates",
    formatAsList: true,
  }) as string;
  const {
    data: { rates: USDbaseRates },
  } = await axios.get(
    `https://openexchangerates.org/api/historical/${nextDate}.json`,
    { params: { app_id: process.env.OPEN_EXCHANGE_RATES_API, symbols } }
  );

  const ZIGrates = await fetchZigRate();
  USDbaseRates.ZIG = ZIGrates.length > 0 ? parseFloat(ZIGrates[1].avg) : NaN;

  validateRates(USDbaseRates);
  return USDbaseRates;
}

function validateRates(rates: Rates): void {
  const allDenoms = getDenominations({}) as Denomination[];
  const denomsToCheck = allDenoms.filter(
    (denom: Denomination) => denom.code !== "CXX"
  );

  const allValid = denomsToCheck.every(
    (denom: Denomination) =>
      rates.hasOwnProperty(denom.code) &&
      typeof rates[denom.code] === "number" &&
      !isNaN(rates[denom.code])
  );

  if (!allValid) {
    throw new Error("Invalid or missing currency rates");
  }
}

async function processDCOParticipants(
  session: any,
  USDbaseRates: Rates
): Promise<any> {
  console.log("Processing DCO participants");
  const denomsInXAU = _.mapValues(
    USDbaseRates,
    (value) => value / USDbaseRates.XAU
  );

  const result = await session.run(`
    MATCH (daynode:Daynode{Active:true})
    MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
    WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
    RETURN
      DCOparticpantsDeclared.accountID AS accountID,
      DCOmember.memberID AS DCOmemberID,
      DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
      DCOparticpantsDeclared.DCOgiveInCXX / daynode[DCOparticpantsDeclared.DCOdenom] AS DCOgiveInDenom,
      DCOparticpantsDeclared.DCOdenom AS DCOdenom
  `);

  const declaredParticipants = result.records;
  console.log(`Declared participants: ${declaredParticipants.length}`);

  let DCOinCXX = 0;
  let DCOinXAU = 0;
  const confirmedParticipants: Participant[] = [];

  for (const participant of declaredParticipants) {
    const { accountID, DCOmemberID, DCOdenom, DCOgiveInCXX, DCOgiveInDenom } =
      participant.toObject();
    const { securableAmountInDenom } = await GetSecuredAuthorizationService(
      accountID,
      DCOdenom
    );

    if (DCOgiveInDenom <= securableAmountInDenom) {
      confirmedParticipants.push({
        accountID,
        DCOmemberID,
        DCOdenom,
        DCOgiveInCXX,
        DCOgiveInDenom,
      });
      DCOinCXX += DCOgiveInCXX;
      DCOinXAU += DCOgiveInDenom / denomsInXAU[DCOdenom];
    }
  }

  const numberConfirmedParticipants = confirmedParticipants.length;
  const nextCXXinXAU = DCOinXAU / numberConfirmedParticipants;
  const CXXprior_CXXcurrent = DCOinCXX / numberConfirmedParticipants;

  console.log(`Confirmed participants: ${numberConfirmedParticipants}`);
  console.log(`DCO in CXX: ${DCOinCXX}`);
  console.log(`DCO in XAU: ${DCOinXAU}`);
  console.log(`Next CXX in XAU: ${nextCXXinXAU}`);

  const newCXXrates = _.mapValues(
    denomsInXAU,
    (value) => 1 / nextCXXinXAU / value
  );
  newCXXrates.CXX = 1;

  logger.info("DCO Rates", {
    USDinXAU: denomsInXAU.XAU,
    CXXinXAU: newCXXrates.CXX,
    CXXprior_CXXcurrent,
  });

  return {
    newCXXrates,
    CXXprior_CXXcurrent,
    DCOinCXX,
    DCOinXAU,
    numberConfirmedParticipants,
    confirmedParticipants,
  };
}

async function createNewDaynode(
  session: any,
  newCXXrates: Rates,
  nextDate: string,
  CXXprior_CXXcurrent: number
): Promise<void> {
  console.log("Creating new daynode");
  await session.run(
    `
    MATCH (expiringDaynode:Daynode {Active: TRUE})
    CREATE (expiringDaynode)-[:NEXT_DAY]->(nextDaynode:Daynode)
    SET expiringDaynode.Active = false,
        expiringDaynode.DCOrunningNow = false,
        nextDaynode = $newCXXrates,
        nextDaynode.CXXprior_CXXcurrent = $CXXprior_CXXcurrent,
        nextDaynode.Date = date($nextDate),
        nextDaynode.Active = true,
        nextDaynode.DCOrunningNow = true
  `,
    { newCXXrates, nextDate, CXXprior_CXXcurrent }
  );
}

async function updateCredexBalances(
  ledgerSession: any,
  searchSession: any,
  newCXXrates: Rates,
  CXXprior_CXXcurrent: number
): Promise<void> {
  console.log("Updating credex and asset balances");

  // Update ledger space
  await ledgerSession.run(`
    MATCH (newDaynode:Daynode {Active: TRUE})

    // Update CXX credexes
    MATCH (credcoinCredex:Credex)
    WHERE credcoinCredex.Denomination = "CXX"
    SET 
      credcoinCredex.InitialAmount = credcoinCredex.InitialAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.OutstandingAmount = credcoinCredex.OutstandingAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.RedeemedAmount = credcoinCredex.RedeemedAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.DefaultedAmount = credcoinCredex.DefaultedAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.WrittenOffAmount = credcoinCredex.WrittenOffAmount / newDaynode.CXXprior_CXXcurrent

    // Update currency credexes
    MATCH (currencyCredex:Credex)
    WHERE currencyCredex.Denomination <> "CXX"
    SET
      currencyCredex.InitialAmount = (currencyCredex.InitialAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.OutstandingAmount = (currencyCredex.OutstandingAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.RedeemedAmount = (currencyCredex.RedeemedAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.DefaultedAmount = (currencyCredex.DefaultedAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.WrittenOffAmount = (currencyCredex.WrittenOffAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.CXXmultiplier = newDaynode[currencyCredex.Denomination]

    // Update CXX :REDEEMED relationships
    MATCH ()-[CXXredeemed:REDEEMED]-()
    WHERE CXXredeemed.Denomination = "CXX"
    SET
      CXXredeemed.AmountRedeemed = CXXredeemed.AmountRedeemed / newDaynode.CXXprior_CXXcurrent,
      CXXredeemed.AmountOutstandingNow = CXXredeemed.AmountOutstandingNow / newDaynode.CXXprior_CXXcurrent

    // Update currency :REDEEMED relationships
    MATCH ()-[currencyRedeemed:REDEEMED]-()
    WHERE currencyRedeemed.Denomination <> "CXX"
    SET
      currencyRedeemed.AmountOutstandingNow = (currencyRedeemed.AmountOutstandingNow / currencyRedeemed.CXXmultiplier) * newDaynode[currencyRedeemed.Denomination],
      currencyRedeemed.AmountRedeemed = (currencyRedeemed.AmountRedeemed / currencyRedeemed.CXXmultiplier) * newDaynode[currencyRedeemed.Denomination],
      currencyRedeemed.CXXmultiplier = newDaynode[currencyRedeemed.Denomination]

    // Update CXX :CREDLOOP relationships
    MATCH ()-[CXXcredloop:CREDLOOP]-()
    WHERE CXXcredloop.Denomination = "CXX"
    SET
      CXXcredloop.AmountRedeemed = CXXcredloop.AmountRedeemed / newDaynode.CXXprior_CXXcurrent,
      CXXcredloop.AmountOutstandingNow = CXXcredloop.AmountOutstandingNow / newDaynode.CXXprior_CXXcurrent

    // Update currency :CREDLOOP relationships
    MATCH ()-[currencyCredloop:CREDLOOP]-()
    WHERE currencyCredloop.Denomination <> "CXX"
    SET
      currencyCredloop.AmountOutstandingNow = (currencyCredloop.AmountOutstandingNow / currencyCredloop.CXXmultiplier) * newDaynode[currencyCredloop.Denomination],
      currencyCredloop.AmountRedeemed = (currencyCredloop.AmountRedeemed / currencyCredloop.CXXmultiplier) * newDaynode[currencyCredloop.Denomination],
      currencyCredloop.CXXmultiplier = newDaynode[currencyCredloop.Denomination]

    // Update loop anchors (always CXX)
    MATCH (loopAnchors:LoopAnchor)
    SET
      loopAnchors.LoopedAmount = loopAnchors.LoopedAmount / newDaynode.CXXprior_CXXcurrent
  `);

  // Update search space
  await searchSession.run(
    `
    MATCH (credex:Credex)
    WHERE credex.Denomination = "CXX"
    SET credex.outstandingAmount = credex.outstandingAmount / $CXXprior_CXXcurrent
  `,
    { CXXprior_CXXcurrent }
  );

  await searchSession.run(
    `
    MATCH (credex:Credex)
    WHERE credex.Denomination <> "CXX"
    WITH credex, $newCXXrates AS rates
    SET credex.outstandingAmount = (credex.outstandingAmount / credex.CXXmultiplier) * coalesce(rates[credex.Denomination], 1),
        credex.CXXmultiplier = coalesce(rates[credex.Denomination], 1)
  `,
    { newCXXrates }
  );
}

async function getFoundationData(
  session: any
): Promise<{ foundationID: string; foundationXOid: string }> {
  const result = await session.run(`
    MATCH (credexFoundation:Account {accountType: "CREDEX_FOUNDATION"})<-[:OWNS]-(foundationXO:Member)
    RETURN credexFoundation.accountID AS foundationID, foundationXO.memberID AS foundationXOid
  `);
  return {
    foundationID: result.records[0].get("foundationID"),
    foundationXOid: result.records[0].get("foundationXOid"),
  };
}

async function processDCOTransactions(
  session: any,
  foundationID: string,
  foundationXOid: string,
  DCOinCXX: number,
  numberConfirmedParticipants: number
): Promise<void> {
  console.log("Processing DCO transactions");

  const confirmedParticipants: Participant[] = (
    await session.run(`
    MATCH (daynode:Daynode{Active:true})
    MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
    WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
    RETURN
      DCOparticpantsDeclared.accountID AS accountID,
      DCOmember.memberID AS DCOmemberID,
      DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
      DCOparticpantsDeclared.DCOgiveInCXX / daynode[DCOparticpantsDeclared.DCOdenom] AS DCOgiveInDenom,
      DCOparticpantsDeclared.DCOdenom AS DCOdenom
  `)
  ).records.map((record: any) => record.toObject() as Participant);

  // Process DCO give transactions
  await Promise.all(
    confirmedParticipants.map(async (participant: Participant) => {
      const dataForDCOgive = {
        memberID: participant.DCOmemberID,
        issuerAccountID: participant.accountID,
        receiverAccountID: foundationID,
        Denomination: participant.DCOdenom,
        InitialAmount: participant.DCOgiveInDenom,
        credexType: "DCO_GIVE",
        securedCredex: true,
      };

      const DCOgiveCredex = await OfferCredexService(dataForDCOgive);
      if (
        typeof DCOgiveCredex.credex === "boolean" ||
        !DCOgiveCredex.credex?.credexID
      ) {
        throw new Error(
          "Invalid response from OfferCredexService for DCO give"
        );
      }
      await AcceptCredexService(DCOgiveCredex.credex.credexID, foundationXOid);
    })
  );

  // Process DCO receive transactions
  await Promise.all(
    confirmedParticipants.map(async (participant: Participant) => {
      const dataForDCOreceive = {
        memberID: foundationXOid,
        issuerAccountID: foundationID,
        receiverAccountID: participant.accountID,
        Denomination: "CXX",
        InitialAmount: DCOinCXX / numberConfirmedParticipants,
        credexType: "DCO_RECEIVE",
        securedCredex: true,
      };

      const DCOreceiveCredex = await OfferCredexService(dataForDCOreceive);
      if (
        typeof DCOreceiveCredex.credex === "boolean" ||
        !DCOreceiveCredex.credex?.credexID
      ) {
        throw new Error(
          "Invalid response from OfferCredexService for DCO receive"
        );
      }
      await AcceptCredexService(
        DCOreceiveCredex.credex.credexID,
        foundationXOid
      );
    })
  );
}



File: src/core-cron/DCO/DCOsnapshots/placeholder.ts
----------------------------------------
//placeholder


File: src/core-cron/DCO/DBinitialization.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../../constants/denominations";
import { OnboardMemberController } from "../../api/Member/controllers/onboardMember";
import { UpdateMemberTierController } from "../../api/Member/controllers/updateMemberTier";
import { CreateAccountService } from "../../api/Account/services/CreateAccount";
import { OfferCredexService } from "../../api/Credex/services/OfferCredex";
import { AcceptCredexService } from "../../api/Credex/services/AcceptCredex";
import { fetchZigRate } from "./fetchZigRate";
import axios from "axios";
import _ from "lodash";
import moment from "moment-timezone";
import logger from "../../../config/logger";

/**
 * Initializes the database for the Daily Credcoin Offering (DCO) process.
 * This function sets up necessary constraints, creates initial accounts,
 * and establishes the starting state for the DCO.
 */
export async function DBinitialization(): Promise<void> {
  console.log("Starting DBinitialization");

  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    await setupDatabaseConstraints(ledgerSpaceSession, searchSpaceSession);
    const dayZero = establishDayZero();
    const dayZeroCXXrates = await fetchAndProcessRates(dayZero);
    await createDayZeroDaynode(ledgerSpaceSession, dayZero, dayZeroCXXrates);
    await createInitialAccounts(ledgerSpaceSession);
  } catch (error) {
    logger.error("Error during DBinitialization", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}

/**
 * Sets up necessary database constraints and indexes.
 */
async function setupDatabaseConstraints(
  ledgerSpaceSession: any,
  searchSpaceSession: any
): Promise<void> {
  console.log("Creating database constraints and indexes...");

  // Remove any current db constraints
  await ledgerSpaceSession.run("CALL apoc.schema.assert({}, {})");
  await searchSpaceSession.run("CALL apoc.schema.assert({}, {})");

  // Set new constraints
  const constraints = [
    "CREATE CONSTRAINT daynodeDate_unique IF NOT EXISTS FOR (daynode:Daynode) REQUIRE daynode.Date IS UNIQUE",
    "CREATE CONSTRAINT memberID_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.memberID IS UNIQUE",
    "CREATE CONSTRAINT memberHandle_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.memberHandle IS UNIQUE",
    "CREATE CONSTRAINT memberPhone_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.phone IS UNIQUE",
    "CREATE CONSTRAINT accountID_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountID IS UNIQUE",
    "CREATE CONSTRAINT accountHandle_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountHandle IS UNIQUE",
  ];

  for (const constraint of constraints) {
    await ledgerSpaceSession.run(constraint);
  }

  await searchSpaceSession.run(
    "CREATE CONSTRAINT accountID_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountID IS UNIQUE"
  );
  await searchSpaceSession.run(
    "CREATE CONSTRAINT credexID_unique IF NOT EXISTS FOR (credex:Credex) REQUIRE credex.credexID IS UNIQUE"
  );
}

/**
 * Establishes the day zero date.
 */
function establishDayZero(): string {
  console.log("Establishing day zero");
  const dayZero =
    process.env.DEPLOYMENT === "dev"
      ? "2021-01-01"
      : moment.utc().subtract(1, "days").format("YYYY-MM-DD");
  console.log("Day zero:", dayZero);
  return dayZero;
}

/**
 * Fetches and processes currency rates for day zero.
 */
async function fetchAndProcessRates(dayZero: string): Promise<any> {
  console.log("Loading currencies and current rates...");
  const symbols = getDenominations({
    sourceForRate: "OpenExchangeRates",
    formatAsList: true,
  });
  const baseUrl = `https://openexchangerates.org/api/historical/${dayZero}.json?app_id=${process.env.OPEN_EXCHANGE_RATES_API}&symbols=${symbols}`;

  const {
    data: { rates: USDbaseRates },
  } = await axios.get(baseUrl);
  USDbaseRates.ZIG = (await fetchZigRate())[1].avg;

  const OneCXXinCXXdenom = 1;
  const CXXdenom = "CAD";
  console.log(OneCXXinCXXdenom + " CXX = 1 " + CXXdenom);

  const XAUbaseRates = _.mapValues(
    USDbaseRates,
    (value) => value / USDbaseRates.XAU
  );
  const dayZeroCXXrates = _.mapValues(
    XAUbaseRates,
    (value) => (1 / value) * OneCXXinCXXdenom * XAUbaseRates[CXXdenom]
  );
  dayZeroCXXrates.CXX = 1;

  console.log("Day zero CXX rates:", dayZeroCXXrates);
  return dayZeroCXXrates;
}

/**
 * Creates the day zero daynode in the database.
 */
async function createDayZeroDaynode(
  session: any,
  dayZero: string,
  dayZeroCXXrates: any
): Promise<void> {
  console.log("Creating day zero daynode...");
  await session.run(
    `
    CREATE (daynode:Daynode)
    SET daynode = $dayZeroCXXrates,
        daynode.Date = date($dayZero),
        daynode.Active = TRUE,
        daynode.DCOrunningNow = TRUE
  `,
    { dayZeroCXXrates, dayZero }
  );
}

/**
 * Creates initial accounts and relationships for the DCO process.
 */
async function createInitialAccounts(session: any): Promise<void> {
  console.log("Creating initialization accounts and relationships...");

  const rdubs = await createRdubsAccount();
  const credexFoundationID = await createCredexFoundation(
    rdubs.onboardedMemberID
  );
  const greatSunID = await createGreatSun(rdubs.onboardedMemberID);
  const vimbisoPayID = await createVimbisoPay(rdubs.onboardedMemberID);

  await createInitialRelationships(
    session,
    credexFoundationID,
    greatSunID,
    vimbisoPayID
  );
  await createInitialCredex(
    rdubs.onboardedMemberID,
    greatSunID,
    rdubs.personalAccountID
  );
}

async function createRdubsAccount(): Promise<{
  onboardedMemberID: string;
  personalAccountID: string;
}> {
  const result = await OnboardMemberController(
    "Ryan",
    "Watson",
    "263778177125"
  );

  if ("error" in result) {
    throw new Error(`Failed to create rdubs account: ${result.error}`);
  }

  const onboardedMemberID = result.memberDashboard.memberID;

  const updateTierResult = await UpdateMemberTierController(onboardedMemberID, 5);
  if (!updateTierResult.success) {
    throw new Error(`Failed to update member tier: ${updateTierResult.message}`);
  }

  const rdubsPersonalAccount = await CreateAccountService(
    onboardedMemberID,
    "PERSONAL_CONSUMPTION",
    "Ryan Watson Personal",
    "263778177125",
    "USD",
    1,
    "CAD"
  );

  return {
    onboardedMemberID,
    personalAccountID: rdubsPersonalAccount.accountID,
  };
}

async function createCredexFoundation(memberID: string): Promise<string> {
  const credexFoundation = await CreateAccountService(
    memberID,
    "CREDEX_FOUNDATION",
    "Credex Foundation",
    "credexfoundation",
    "CXX"
  );

  if (
    typeof credexFoundation.account === "boolean" ||
    !credexFoundation.accountID
  ) {
    throw new Error("Failed to create Credex Foundation account");
  }

  return credexFoundation.accountID;
}

async function createGreatSun(memberID: string): Promise<string> {
  const greatSun = await CreateAccountService(
    memberID,
    "BUSINESS",
    "Great Sun Financial",
    "greatsunfinancial",
    "CAD"
  );

  if (!greatSun || !greatSun.accountID) {
    throw new Error("Failed to create Great Sun account");
  }

  return greatSun.accountID;
}

async function createVimbisoPay(memberID: string): Promise<string> {
  const vimbisoPay = await CreateAccountService(
    memberID,
    "BUSINESS",
    "VimbisoPay",
    "vimbisopay.audited",
    "CAD"
  );

  if (!vimbisoPay || !vimbisoPay.accountID) {
    throw new Error("Failed to create VimbisoPay account");
  }

  return vimbisoPay.accountID;
}

async function createInitialRelationships(
  session: any,
  credexFoundationID: string,
  greatSunID: string,
  vimbisoPayID: string
): Promise<void> {
  await session.run(
    `
    MATCH (credexFoundation: Account { accountID: $credexFoundationID })
    MATCH (greatSun: Account { accountID: $greatSunID })
    MATCH (vimbisoPay: Account { accountID: $vimbisoPayID })
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (credexFoundation)
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (greatSun)
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (vimbisoPay)
  `,
    { credexFoundationID, greatSunID, vimbisoPayID }
  );
}

async function createInitialCredex(
  memberID: string,
  issuerAccountID: string,
  receiverAccountID: string
): Promise<void> {
  const credexData = {
    memberID,
    issuerAccountID,
    receiverAccountID,
    Denomination: "CAD",
    InitialAmount: 365, // fund DCO for a year with no adjustments
    credexType: "PURCHASE",
    securedCredex: true,
  };

  const DCOinitializationOfferCredex = await OfferCredexService(credexData);
  if (typeof DCOinitializationOfferCredex.credex === "boolean") {
    throw new Error("Invalid response from OfferCredexService");
  }
  if (
    DCOinitializationOfferCredex.credex &&
    typeof DCOinitializationOfferCredex.credex.credexID === "string"
  ) {
    await AcceptCredexService(
      DCOinitializationOfferCredex.credex.credexID,
      memberID
    );
  } else {
    throw new Error("Invalid credexID from OfferCredexService");
  }
}



File: src/core-cron/DCO/DBbackup.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import fs from "fs";
import path from "path";

const exportDatabase = async (
  driver: any,
  databaseName: string,
  previousDate: string,
  append: string
): Promise<void> => {
  const session = driver.session();
  try {
    const fileName = `${previousDate}_${databaseName}${append}.json`;
    const filePath = path.join(__dirname, "DCOsnapshots", fileName);

    const result = await session.run(`
      CALL apoc.export.json.all(null, {stream:true, useTypes:true})
    `);

    const records = result.records;
    let jsonData = "";
    records.forEach((record: any) => {
      jsonData += record.get(0);
    });

    fs.writeFileSync(filePath, jsonData);
    console.log(`Backup for ${databaseName} created successfully: ${filePath}`);
  } catch (error) {
    console.error(`Error creating backup for ${databaseName}:`, error);
    throw error;
  } finally {
    await session.close();
  }
};

export const createNeo4jBackup = async (
  previousDate: string,
  append: string
): Promise<void> => {
  try {
    await exportDatabase(ledgerSpaceDriver, "ledgerSpace_dev", previousDate, append);
    await exportDatabase(
      searchSpaceDriver,
      "searchSpace_dev",
      previousDate,
      append
    );
    console.log("Both databases backed up successfully.");
  } catch (error) {
    console.error("Error creating backups:", error);
    throw error;
  }
};



File: src/core-cron/MTQ/MinuteTransactionQueue.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { Session } from "neo4j-driver";
import { LoopFinder } from "./LoopFinder";
import _ from "lodash";
import logger from "../../../config/logger";

interface Account {
  accountID: string;
  accountName: string;
}

interface Credex {
  acceptedAt: string;
  issuerAccountID: string;
  acceptorAccountID: string;
  credexID: string;
  amount: number;
  denomination: string;
  CXXmultiplier: number;
  credexSecuredDenom: string;
  dueDate: string;
}

export async function MinuteTransactionQueue(): Promise<boolean> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  logger.info("MTQ start: checking if DCO or MTQ is in progress");

  try {
    const { DCOflag, MTQflag } = await checkDCOAndMTQStatus(ledgerSpaceSession);

    if (DCOflag === null || MTQflag === null) {
      logger.warn("No active daynode found. Skipping MTQ.");
      return false;
    }

    if (DCOflag || MTQflag) {
      if (DCOflag) logger.info("DCO in progress, holding MTQ");
      if (MTQflag) logger.info("MTQ already in progress, holding new MTQ");
      return false;
    }

    logger.info("Running MTQ");

    await setMTQRunningFlag(ledgerSpaceSession, true);

    const BAIL_TIME = 14 * 60 * 1000; // 14 minutes
    const bailTimer = setTimeout(() => {
      logger.warn("Bail timer reached");
      return true;
    }, BAIL_TIME);

    try {
      await processQueuedAccounts(ledgerSpaceSession, searchSpaceSession);
      await processQueuedCredexes(ledgerSpaceSession, searchSpaceSession);
    } finally {
      clearTimeout(bailTimer);
      await setMTQRunningFlag(ledgerSpaceSession, false);
    }

    logger.info("MTQ processing completed");
    return true;
  } catch (error) {
    logger.error("Error in MinuteTransactionQueue:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}

async function checkDCOAndMTQStatus(
  session: Session
): Promise<{ DCOflag: boolean | null; MTQflag: boolean | null }> {
  const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN
      daynode.DCOrunningNow AS DCOflag,
      daynode.MTQrunningNow AS MTQflag
  `);

  if (result.records.length === 0) {
    logger.warn("No active daynode found");
    return { DCOflag: null, MTQflag: null };
  }

  return {
    DCOflag: result.records[0].get("DCOflag"),
    MTQflag: result.records[0].get("MTQflag"),
  };
}

async function setMTQRunningFlag(
  session: Session,
  value: boolean
): Promise<void> {
  const result = await session.run(
    `
    MATCH (daynode:Daynode {Active: true})
    SET daynode.MTQrunningNow = $value
    RETURN daynode
  `,
    { value }
  );

  if (result.records.length === 0) {
    logger.warn("No active daynode found when setting MTQ running flag");
  }
}

async function processQueuedAccounts(
  ledgerSpaceSession: Session,
  searchSpaceSession: Session
): Promise<void> {
  const queuedAccounts = await getQueuedAccounts(ledgerSpaceSession);

  for (const account of queuedAccounts) {
    try {
      await createAccountInSearchSpace(searchSpaceSession, account);
      await markAccountAsProcessed(ledgerSpaceSession, account.accountID);
      logger.info(`Account created in searchSpace: ${account.accountName}`);
    } catch (error) {
      logger.error(`Error processing account ${account.accountName}:`, error);
    }
  }
}

async function getQueuedAccounts(session: Session): Promise<Account[]> {
  const result = await session.run(`
    MATCH (newAccount:Account {queueStatus: "PENDING_ACCOUNT"})
    RETURN
      newAccount.accountID AS accountID,
      newAccount.accountName AS accountName
  `);
  return result.records.map((record: any) => ({
    accountID: record.get("accountID"),
    accountName: record.get("accountName"),
  }));
}

async function createAccountInSearchSpace(
  session: Session,
  account: Account
): Promise<void> {
  const result = await session.run(
    `
    CREATE (newAccount:Account)
    SET newAccount = $account
    RETURN newAccount.accountID AS accountID
    `,
    { account }
  );

  if (result.records.length === 0) {
    throw new Error(
      `Failed to create account in searchSpace: ${account.accountName}`
    );
  }
}

async function markAccountAsProcessed(
  session: Session,
  accountID: string
): Promise<void> {
  await session.run(
    `
    MATCH (processedAccount:Account {accountID: $accountID})
    SET processedAccount.queueStatus = "PROCESSED"
    `,
    { accountID }
  );
}

async function processQueuedCredexes(
  ledgerSpaceSession: Session,
  searchSpaceSession: Session
): Promise<void> {
  const queuedCredexes = await getQueuedCredexes(ledgerSpaceSession);
  const sortedQueuedCredexes = _.sortBy(queuedCredexes, "acceptedAt");

  for (const credex of sortedQueuedCredexes) {
    try {
      await LoopFinder(
        credex.issuerAccountID,
        credex.credexID,
        credex.amount,
        credex.denomination,
        credex.CXXmultiplier,
        credex.credexSecuredDenom,
        credex.dueDate,
        credex.acceptorAccountID
      );
    } catch (error) {
      logger.error(`Error processing credex ${credex.credexID}:`, error);
    }
  }
}

async function getQueuedCredexes(session: Session): Promise<Credex[]> {
  const result = await session.run(`
    MATCH
      (issuerAccount:Account)
      -[:OWES]->(queuedCredex:Credex {queueStatus: "PENDING_CREDEX"})
      -[:OWES]->(acceptorAccount:Account)
    OPTIONAL MATCH (queuedCredex)<-[:SECURES]-(securer:Account)
    RETURN queuedCredex.acceptedAt AS acceptedAt,
           issuerAccount.accountID AS issuerAccountID,
           acceptorAccount.accountID AS acceptorAccountID,
           securer.accountID AS securerID,
           queuedCredex.credexID AS credexID,
           queuedCredex.InitialAmount AS amount,
           queuedCredex.Denomination AS denomination,
           queuedCredex.CXXmultiplier AS CXXmultiplier,
           queuedCredex.dueDate AS dueDate
  `);

  return result.records.map((record: any) => ({
    acceptedAt: record.get("acceptedAt"),
    issuerAccountID: record.get("issuerAccountID"),
    acceptorAccountID: record.get("acceptorAccountID"),
    credexID: record.get("credexID"),
    amount: record.get("amount").toNumber(),
    denomination: record.get("denomination"),
    CXXmultiplier: record.get("CXXmultiplier").toNumber(),
    credexSecuredDenom:
      record.get("securerID") !== null
        ? record.get("denomination")
        : "floating",
    dueDate: record.get("dueDate"),
  }));
}



File: src/core-cron/MTQ/LoopFinder.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { Session } from "neo4j-driver";
import logger from "../../../config/logger";

export async function LoopFinder(
  issuerAccountID: string,
  credexID: string,
  credexAmount: number,
  Denomination: string,
  CXXmultiplier: number,
  credexSecuredDenom: string,
  credexDueDate: string,
  acceptorAccountID: string
): Promise<boolean> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    const searchOwesType = getSearchOwesType(credexSecuredDenom);
    credexDueDate = await adjustCredexDueDate(ledgerSpaceSession, credexSecuredDenom, credexDueDate);

    await createOrUpdateSearchSpaceCredex(
      searchSpaceSession,
      issuerAccountID,
      acceptorAccountID,
      credexID,
      credexAmount,
      Denomination,
      CXXmultiplier,
      credexDueDate,
      searchOwesType
    );

    let searchForCredloops = true;
    while (searchForCredloops) {
      logger.info("Searching for credloops...");
      const { valueToClear, credexesInLoop, credexesRedeemed } = await findCredloop(searchSpaceSession, issuerAccountID, searchOwesType);

      if (credexesInLoop.length > 0) {
        await processCredloop(ledgerSpaceSession, searchSpaceSession, valueToClear, credexesInLoop, credexesRedeemed);
      } else {
        await markCredexAsProcessed(ledgerSpaceSession, credexID);
        logger.info("No credloops found. Credex marked as processed.");
        searchForCredloops = false;
      }
    }

    return true;
  } catch (error) {
    logger.error("Error in LoopFinder:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}

function getSearchOwesType(credexSecuredDenom: string): string {
  return credexSecuredDenom !== "floating" ? `${credexSecuredDenom}_SECURED` : "FLOATING";
}

async function adjustCredexDueDate(session: Session, credexSecuredDenom: string, credexDueDate: string): Promise<string> {
  if (credexSecuredDenom !== "floating") {
    const result = await session.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.Date AS today
    `);
    return result.records[0].get("today");
  }
  return credexDueDate;
}

async function createOrUpdateSearchSpaceCredex(
  session: Session,
  issuerAccountID: string,
  acceptorAccountID: string,
  credexID: string,
  credexAmount: number,
  Denomination: string,
  CXXmultiplier: number,
  credexDueDate: string,
  searchOwesType: string
): Promise<void> {
  const credexExists = await checkCredexExists(session, credexID);

  if (!credexExists) {
    await createSearchSpaceCredex(
      session,
      issuerAccountID,
      acceptorAccountID,
      credexID,
      credexAmount,
      Denomination,
      CXXmultiplier,
      credexDueDate,
      searchOwesType
    );
  } else {
    logger.info(`Credex already exists in SearchSpace: ${credexID}`);
  }
}

async function checkCredexExists(session: Session, credexID: string): Promise<boolean> {
  const result = await session.run(
    `
    OPTIONAL MATCH (credex:Credex {credexID: $credexID})
    RETURN credex IS NOT NULL AS credexExists
    `,
    { credexID }
  );
  return result.records[0].get("credexExists");
}

async function createSearchSpaceCredex(
  session: Session,
  issuerAccountID: string,
  acceptorAccountID: string,
  credexID: string,
  credexAmount: number,
  Denomination: string,
  CXXmultiplier: number,
  credexDueDate: string,
  searchOwesType: string
): Promise<void> {
  try {
    const result = await session.run(
      `
      MATCH (issuer:Account {accountID: $issuerAccountID})
      MATCH (acceptor:Account {accountID: $acceptorAccountID})
      MERGE (issuer)-[:${searchOwesType}]->(searchOwesType:${searchOwesType})-[:${searchOwesType}]->(acceptor)
        ON CREATE SET searchOwesType.searchAnchorID = randomUUID()
      CREATE (searchOwesType)<-[:SEARCH_SECURED]-(credex:Credex {
          credexID: $credexID,
          outstandingAmount: $credexAmount,
          Denomination: $Denomination,
          CXXmultiplier: $CXXmultiplier,
          dueDate: date($credexDueDate)
      })
      WITH searchOwesType, credex
      CALL apoc.do.case(
          [
              searchOwesType.earliestDueDate IS NULL
              OR searchOwesType.earliestDueDate > date($credexDueDate), 
              'SET searchOwesType.earliestDueDate = date($credexDueDate) RETURN true'
          ],
          'RETURN false',
          {
            searchOwesType: searchOwesType,
            credexDueDate: credex.dueDate
          }
      ) YIELD value
      RETURN credex.credexID AS credexID
      `,
      {
        issuerAccountID,
        acceptorAccountID,
        credexID,
        credexAmount,
        Denomination,
        CXXmultiplier,
        credexDueDate,
        searchOwesType,
      }
    );

    if (result.records.length === 0) {
      throw new Error("Unable to create SearchSpace credex");
    }

    logger.info(`Credex created in SearchSpace: ${result.records[0].get("credexID")}`);
  } catch (error) {
    logger.error("Error creating SearchSpace credex:", error);
    throw error;
  }
}

async function findCredloop(session: Session, issuerAccountID: string, searchOwesType: string): Promise<{ valueToClear: number; credexesInLoop: string[]; credexesRedeemed: string[] }> {
  const result = await session.run(
    `
    // Step 1: Find all loops starting and ending at the specified account, with the specified searchOwesType
    MATCH credloops = (issuer:Account {accountID: $issuerAccountID})-[:${searchOwesType}*]->(issuer)
    
    WITH credloops, nodes(credloops) AS loopNodes
    UNWIND loopNodes AS node
    WITH credloops, node
    WITH credloops, MIN(node.earliestDueDate) AS earliestDueDate

    // Step 3: Filter loops to include only those containing a node with the earliest earliestDueDate
    WITH credloops, earliestDueDate, nodes(credloops) AS loopNodes
    UNWIND loopNodes AS node
    WITH credloops, node
    WHERE node.earliestDueDate = earliestDueDate
    WITH credloops, length(credloops) AS loopLength

    // Step 4: Return only the longest loop, breaking ties with rand()
    ORDER BY loopLength DESC, rand()
    LIMIT 1
    WITH nodes(credloops) AS credloopNodes

    // Step 5: Each node returns the credex it is connected to with the earliest dueDate
    // on tie, credex with largest amount
    UNWIND credloopNodes AS loopNode
    MATCH (loopNode)<-[:SEARCH_SECURED]-(credex:Credex)
    WITH loopNode, collect(credex) AS credexList
    WITH 
           reduce(minCredex = credexList[0], c IN credexList | 
                  CASE 
                    WHEN c.dueDate < minCredex.dueDate THEN c
                    WHEN c.dueDate = minCredex.dueDate AND c.outstandingAmount > minCredex.outstandingAmount THEN c
                    ELSE minCredex 
                  END) AS earliestCredex
    WITH collect(earliestCredex) AS finalCredexes, COLLECT(earliestCredex.credexID) AS credexIDs

    // Step 6: Identify the minimum outstandingAmount and subtract it from all credexes
    UNWIND finalCredexes AS credexInLoop
    WITH finalCredexes, min(credexInLoop.outstandingAmount) AS lowestAmount, credexIDs

    UNWIND finalCredexes AS credex
    SET credex.outstandingAmount = credex.outstandingAmount - lowestAmount

    // Step 7: Collect all credexes and filter those with outstandingAmount = 0.
    WITH lowestAmount, COLLECT(credex) AS allCredexes, credexIDs
    WITH lowestAmount, allCredexes, [credex IN allCredexes WHERE credex.outstandingAmount = 0] AS zeroCredexes, credexIDs

    //Step 8: collect credexIDs of the zeroCredexes
    UNWIND zeroCredexes as zeroCredex
    RETURN collect(zeroCredex.credexID) AS zeroCredexIDs, lowestAmount, credexIDs
    `,
    { issuerAccountID, searchOwesType }
  );

  if (result.records.length > 0) {
    return {
      valueToClear: result.records[0].get("lowestAmount").toNumber(),
      credexesInLoop: result.records[0].get("credexIDs"),
      credexesRedeemed: result.records[0].get("zeroCredexIDs")
    };
  }

  return { valueToClear: 0, credexesInLoop: [], credexesRedeemed: [] };
}

async function processCredloop(ledgerSpaceSession: Session, searchSpaceSession: Session, valueToClear: number, credexesInLoop: string[], credexesRedeemed: string[]): Promise<void> {
  logger.info("Credexes in loop:", credexesInLoop);
  logger.info("Credexes redeemed:", credexesRedeemed);

  await cleanupSearchSpace(searchSpaceSession, credexesRedeemed);
  await updateLedgerSpace(ledgerSpaceSession, valueToClear, credexesInLoop, credexesRedeemed);
}

async function cleanupSearchSpace(session: Session, credexesRedeemed: string[]): Promise<void> {
  await session.run(
    `
    // Step 10: Delete zeroCredexes
    UNWIND $credexesRedeemed AS credexRedeemedID
    MATCH (credex:Credex {credexID: credexRedeemedID})-[:SEARCH_SECURED]->(searchAnchor)
    DETACH DELETE credex
    WITH DISTINCT searchAnchor

    // Step 11: Handle orphaned searchAnchors
    OPTIONAL MATCH (searchAnchor)<-[:SEARCH_SECURED]-(otherCredex:Credex)
    WITH searchAnchor, collect(otherCredex) AS otherCredexes
    CALL apoc.do.when(
      size(otherCredexes) = 0,
      'DETACH DELETE searchAnchor RETURN "searchAnchorDeleted" AS result',
      'RETURN "noChanges" AS result',
      {searchAnchor: searchAnchor}
    ) YIELD value AS deleteValue
    WITH deleteValue, searchAnchor, otherCredexes
    WHERE deleteValue <> "searchAnchorDeleted"

    // Step 12: Update earliestDueDate on remaining searchAnchors
    UNWIND otherCredexes AS otherCredex
    WITH DISTINCT searchAnchor, otherCredex
    CALL apoc.do.when(
      (searchAnchor.earliestDueDate IS NULL OR searchAnchor.earliestDueDate > date(otherCredex.dueDate)),
      'SET searchAnchor.earliestDueDate = date(otherCredex.dueDate) RETURN "searchAnchorEarliestUpdated" AS result',
      'RETURN "noChanges" AS result',
      {searchAnchor: searchAnchor, otherCredex: otherCredex}
    ) YIELD value AS updateValue
    RETURN searchAnchor
    `,
    { credexesRedeemed }
  );
}

async function updateLedgerSpace(session: Session, valueToClear: number, credexesInLoop: string[], credexesRedeemed: string[]): Promise<void> {
  logger.info(`Credloop of ${valueToClear} CXX found and cleared, now updating ledgerSpace`);

  const result = await session.run(
    `
    MATCH (daynode:Daynode {Active: true})
    CREATE (loopAnchor:LoopAnchor {
        loopedAt: DateTime(),
        loopID: randomUUID(),
        LoopedAmount: $valueToClear,
        CXXmultiplier: 1,
        Denomination: "CXX"
    })-[to_daynode:CREATED_ON]->(daynode)
    WITH loopAnchor

    UNWIND $credexesInLoop AS credexID
    MATCH (thisCredex:Credex {credexID: credexID})
    SET thisCredex.OutstandingAmount = thisCredex.OutstandingAmount - $valueToClear,
        thisCredex.RedeemedAmount = thisCredex.RedeemedAmount + $valueToClear
    WITH thisCredex, loopAnchor
    CREATE (thisCredex)-[:REDEEMED {
        AmountRedeemed: $valueToClear,
        AmountOutstandingNow: thisCredex.OutstandingAmount,
        Denomination: thisCredex.Denomination,
        CXXmultiplier: thisCredex.CXXmultiplier,
        createdAt: DateTime(),
        redeemedRelID: randomUUID()
    }]->(loopAnchor)

    WITH thisCredex, loopAnchor
    MATCH (loopAnchor)<-[:REDEEMED]-(thisCredex)
      -[:OWES]->(:Account)-[:OWES]->(nextCredex:Credex)
      -[:REDEEMED]->(loopAnchor)
    CREATE (thisCredex)-[:CREDLOOP {
        AmountRedeemed: $valueToClear,
        AmountOutstandingNow: thisCredex.OutstandingAmount,
        Denomination: thisCredex.Denomination,
        CXXmultiplier: thisCredex.CXXmultiplier,
        createdAt: DateTime(),
        loopID: loopAnchor.loopID,
        credloopRelID: randomUUID()
    }]->(nextCredex)

    WITH DISTINCT loopAnchor
    UNWIND $credexesRedeemed AS redeemedCredexID
    MATCH
      (owesOutAccount:Account)-[owes1:OWES]->
        (thisRedeemedCredex:Credex {credexID: redeemedCredexID})-[owes2:OWES]->
        (owesInAccount:Account),
      (thisRedeemedCredex)-[:REDEEMED]->(loopAnchor)
    CREATE
      (owesOutAccount)-[:CLEARED]->(thisRedeemedCredex)-[:CLEARED]->(owesInAccount)
    SET thisRedeemedCredex.DateRedeemed = DateTime()
    DELETE owes1, owes2

    RETURN DISTINCT loopAnchor.loopID AS loopID
    `,
    { valueToClear, credexesInLoop, credexesRedeemed }
  );

  logger.info(`LoopAnchor created: ${result.records[0].get("loopID")}`);
}

async function markCredexAsProcessed(session: Session, credexID: string): Promise<void> {
  await session.run(
    `
    MATCH (processedCredex:Credex {credexID: $credexID})
    SET processedCredex.queueStatus = "PROCESSED"
    RETURN processedCredex.credexID AS credexID
    `,
    { credexID }
  );
}

// TODO: Implement notification system
/*
async function createNotifications(session: Session, loopID: string): Promise<void> {
  // Implementation for creating notifications
}
*/



File: src/core-cron/cronJobs.ts
----------------------------------------
import cron from "node-cron";
import { DailyCredcoinOffering } from "./DCO/DailyCredcoinOffering";
import { MinuteTransactionQueue } from "./MTQ/MinuteTransactionQueue";

export default function startCronJobs() {
  // Running DailyCredcoinOffering every day at midnight UTC
  cron.schedule(
    "0 0 * * *",
    async () => {
      try {
        await DailyCredcoinOffering();
      } catch (error) {
        console.error("Error running DailyCredcoinOffering:", error);
      }
    },
    {
      timezone: "UTC",
    }
  );

  // Running MinuteTransactionQueue every minute
  cron.schedule("* * * * *", async () => {
    try {
      await MinuteTransactionQueue();
    } catch (error) {
      console.error("Error running MinuteTransactionQueue:", error);
    }
  });
}



File: middleware/errorHandler.ts
----------------------------------------
import { Request, Response, NextFunction } from 'express';
import logger from '../config/logger';
import { config } from '../config/config';

export interface AppError extends Error {
  statusCode?: number;
}

/**
 * Global error handling middleware
 * @param err - Error object
 * @param req - Express request object
 * @param res - Express response object
 * @param _ - Next middleware function (unused)
 */
export function errorHandler(err: AppError, req: Request, res: Response, _: NextFunction) {
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  // Log the error
  logger.error(`[Error] ${statusCode} - ${message}`, {
    error: err,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
  });
  
  // Send error response
  res.status(statusCode).json({
    status: 'error',
    statusCode,
    message: config.nodeEnv === 'production' ? message : `${message}\n${err.stack}`,
  });
}

/**
 * Middleware to handle 404 Not Found errors
 * @param req - Express request object
 * @param _res - Express response object (unused)
 * @param next - Next middleware function
 */
export function notFoundHandler(req: Request, _res: Response, next: NextFunction) {
  const err: AppError = new Error(`Not Found - ${req.originalUrl}`);
  err.statusCode = 404;
  next(err);
}

// TODO: Implement custom error classes for different types of errors (e.g., ValidationError, DatabaseError)
// TODO: Consider adding a central error catalog for consistent error messages and codes


File: config/swagger.ts
----------------------------------------
import swaggerJsdoc from "swagger-jsdoc";
import { config } from "./config";

const options: swaggerJsdoc.Options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "Credex Core API",
      version: "1.0.0",
      description:
        "API documentation for the Credex Core system. This API provides endpoints for managing members, accounts, Credex transactions, and recurring payments.",
    },
    servers: [
      {
        url: `http://localhost:${config.port}`,
        description: "Development server",
      },
      {
        url: "https://api.credex.example.com",
        description: "Production server",
      },
      {
        url: "https://staging-api.credex.example.com",
        description: "Staging server",
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
    tags: [
      { name: "Members", description: "Member management operations" },
      { name: "Accounts", description: "Account management operations" },
      { name: "Credex", description: "Credex transaction operations" },
      { name: "Recurring", description: "Recurring payment operations" },
      {
        name: "DevAdmin",
        description: "Development and administration operations",
      },
    ],
  },
  apis: ["./src/**/*.ts"], // Path to the API docs
};

export const swaggerSpec = swaggerJsdoc(options);



File: config/logger.ts
----------------------------------------
import winston from "winston";
import DailyRotateFile from "winston-daily-rotate-file";
import { config } from "./config";
import { v4 as uuidv4 } from 'uuid';

// Configure the logger
const logger = winston.createLogger({
  level: config.nodeEnv === "production" ? "info" : "debug",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    winston.format.json()
  ),
  defaultMeta: { service: "credex-core" },
  transports: [
    // Rotate error logs daily
    new DailyRotateFile({
      filename: "logs/error-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      zippedArchive: true,
      maxSize: "20m",
      maxFiles: "14d",
      level: "error",
    }),
    // Rotate combined logs daily
    new DailyRotateFile({
      filename: "logs/combined-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      zippedArchive: true,
      maxSize: "20m",
      maxFiles: "14d",
    }),
  ],
});

// Add console transport for non-production environments
if (config.nodeEnv !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

function sanitizeData(data: any): any {
  const sensitiveFields = ['password', 'token', 'apiKey', 'creditCard'];
  if (typeof data === 'object' && data !== null) {
    return Object.keys(data).reduce((acc: { [key: string]: any }, key: string) => {
      if (sensitiveFields.includes(key)) {
        acc[key] = '[REDACTED]';
      } else if (typeof data[key] === 'object') {
        acc[key] = sanitizeData(data[key]);
      } else {
        acc[key] = data[key];
      }
      return acc;
    }, {});
  }
  return data;
}

export default logger;

/**
 * Middleware for adding a unique request ID
 */
export const addRequestId = (req: any, res: any, next: any) => {
  req.id = uuidv4();
  res.setHeader('X-Request-ID', req.id);
  next();
};

/**
 * Middleware for logging Express requests
 */
export const expressLogger = (req: any, res: any, next: any) => {
  const start = Date.now();
  res.on("finish", () => {
    const duration = Date.now() - start;
    logger.info('User Input', {
      requestId: req.id,
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      body: sanitizeData(req.body),
      params: sanitizeData(req.params),
      query: sanitizeData(req.query),
      headers: sanitizeData(req.headers),
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });
  });
  next();
};

/**
 * Middleware for logging errors
 */
export const errorLogger = (err: Error, req: any, res: any, next: any) => {
  logger.error('Error', {
    requestId: req.id,
    message: err.message,
    stack: err.stack,
    method: req.method,
    url: req.originalUrl,
    body: sanitizeData(req.body),
    params: sanitizeData(req.params),
    query: sanitizeData(req.query),
    headers: sanitizeData(req.headers)
  });
  next(err);
};

/**
 * Function to log DCO rates
 */
export const logDCORates = (XAUrate: number, CXXrate: number, CXXmultiplier: number) => {
  logger.info('DCO Rates', { XAUrate, CXXrate, CXXmultiplier });
};

// TODO: Implement log aggregation and centralized logging for production environments
// TODO: Implement log retention policies based on compliance requirements
// TODO: Add performance monitoring for database queries and external API calls
// TODO: Implement log analysis tools to detect patterns, anomalies, and potential security threats



File: config/neo4j.ts
----------------------------------------
import * as neo4j from "neo4j-driver";

require("dotenv").config();

const ledgerSpace_url = `${process.env.NEO_4J_LEDGER_SPACE_BOLT_URL}`;
const ledgerSpace_user = `${process.env.NEO_4J_LEDGER_SPACE_USER}`;
const ledgerSpace_password = `${process.env.NEO_4J_LEDGER_SPACE_PASS}`;
const searchSpace_url = `${process.env.NEO_4J_SEARCH_SPACE_BOLT_URL}`;
const searchSpace_user = `${process.env.NEO_4J_SEARCH_SPACE_USER}`;
const searchSpace_password = `${process.env.NEO_4J_SEARCH_SPACE_PASS}`;

const createDriverWithRetry = (url: string, user: string, password: string) => {
  const driver = neo4j.driver(url, neo4j.auth.basic(user, password), {
    maxConnectionPoolSize: 50,
    connectionAcquisitionTimeout: 30000,
    maxTransactionRetryTime: 30000,
  });

  // Verify connectivity on first use
  driver.verifyConnectivity()
    .then(() => console.log(`Successfully connected to Neo4j at ${url}`))
    .catch(error => console.error(`Failed to connect to Neo4j at ${url}:`, error));

  return driver;
};

export const ledgerSpaceDriver = createDriverWithRetry(ledgerSpace_url, ledgerSpace_user, ledgerSpace_password);
export const searchSpaceDriver = createDriverWithRetry(searchSpace_url, searchSpace_user, searchSpace_password);

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Closing Neo4j drivers...');
  Promise.all([ledgerSpaceDriver.close(), searchSpaceDriver.close()])
    .then(() => {
      console.log('Neo4j drivers closed.');
      process.exit(0);
    })
    .catch(error => {
      console.error('Error closing Neo4j drivers:', error);
      process.exit(1);
    });
});



File: config/config.ts
----------------------------------------
import dotenv from 'dotenv';

dotenv.config();

export const config = {
  // Server configuration
  port: process.env.PORT || 5000,
  nodeEnv: process.env.NODE_ENV || 'development',
  deployment: process.env.DEPLOYMENT || 'dev',

  // WhatsApp Bot API configuration
  whatsappBotApiKey: process.env.WHATSAPP_BOT_API_KEY,

  // Neo4j database configuration
  neo4j: {
    ledgerSpace: {
      url: process.env.NEO_4J_LEDGER_SPACE_BOLT_URL,
      user: process.env.NEO_4J_LEDGER_SPACE_USER,
      password: process.env.NEO_4J_LEDGER_SPACE_PASS,
    },
    searchSpace: {
      url: process.env.NEO_4J_SEARCH_SPACE_BOLT_URL,
      user: process.env.NEO_4J_SEARCH_SPACE_USER,
      password: process.env.NEO_4J_SEARCH_SPACE_PASS,
    },
  },

  // External API configuration
  openExchangeRatesApiKey: process.env.OPEN_EXCHANGE_RATES_API,

  // Rate limiting configuration
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
  },

  // Cron job schedules
  cron: {
    dailyCredcoinOffering: '0 0 * * *', // Every day at midnight UTC
    minuteTransactionQueue: '* * * * *', // Every minute
  },
};

// TODO: Consider adding validation for required environment variables
// and throw meaningful errors if they're missing


File: config/authenticate.ts
----------------------------------------
import { Request, Response, NextFunction } from "express";
import crypto from "crypto";
import { config } from "./config";

interface UserRequest extends Request {
  user?: any;
}

/**
 * Middleware to authenticate API requests using a WhatsApp Bot API key.
 * This middleware should be applied to routes that require authentication.
 *
 * @param req - The Express request object
 * @param res - The Express response object
 * @param next - The next middleware function
 */
const authenticate = (req: UserRequest, res: Response, next: NextFunction) => {
  const apiKeySubmitted = req.header("whatsappBotAPIkey");
  const validApiKey = config.whatsappBotApiKey;

  if (!validApiKey) {
    console.error(
      "WHATSAPP_BOT_API_KEY is not defined in environment variables"
    );
    return res.status(500).json({ message: "Server configuration error" });
  }

  if (!apiKeySubmitted) {
    console.warn("Authentication failed: API key not provided.");
    return res.status(401).json({ message: "API key is required" });
  }

  // Use timing-safe comparison to prevent timing attacks
  if (crypto.timingSafeEqual(Buffer.from(apiKeySubmitted), Buffer.from(validApiKey))) {
    next();
  } else {
    return res.status(401).json({ message: "Unauthorized" });
  }
};

export default authenticate;

// TODO: Consider implementing a more robust authentication system,
// such as JWT or OAuth2, for enhanced security and flexibility



File: build/config/swagger.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.swaggerSpec = void 0;
const swagger_jsdoc_1 = __importDefault(require("swagger-jsdoc"));
const config_1 = require("./config");
const options = {
    definition: {
        openapi: "3.0.0",
        info: {
            title: "Credex Core API",
            version: "1.0.0",
            description: "API documentation for the Credex Core system. This API provides endpoints for managing members, accounts, Credex transactions, and recurring payments.",
        },
        servers: [
            {
                url: `http://localhost:${config_1.config.port}`,
                description: "Development server",
            },
            {
                url: "https://api.credex.example.com",
                description: "Production server",
            },
            {
                url: "https://staging-api.credex.example.com",
                description: "Staging server",
            },
        ],
        components: {
            securitySchemes: {
                bearerAuth: {
                    type: "http",
                    scheme: "bearer",
                    bearerFormat: "JWT",
                },
            },
        },
        security: [
            {
                bearerAuth: [],
            },
        ],
        tags: [
            { name: "Members", description: "Member management operations" },
            { name: "Accounts", description: "Account management operations" },
            { name: "Credex", description: "Credex transaction operations" },
            { name: "Recurring", description: "Recurring payment operations" },
            {
                name: "DevAdmin",
                description: "Development and administration operations",
            },
        ],
    },
    apis: ["./src/**/*.ts"], // Path to the API docs
};
exports.swaggerSpec = (0, swagger_jsdoc_1.default)(options);
//# sourceMappingURL=swagger.js.map


File: build/config/neo4j.js
----------------------------------------
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchSpaceDriver = exports.ledgerSpaceDriver = void 0;
const neo4j = __importStar(require("neo4j-driver"));
require("dotenv").config();
const ledgerSpace_url = `${process.env.NEO_4J_LEDGER_SPACE_BOLT_URL}`;
const ledgerSpace_user = `${process.env.NEO_4J_LEDGER_SPACE_USER}`;
const ledgerSpace_password = `${process.env.NEO_4J_LEDGER_SPACE_PASS}`;
const searchSpace_url = `${process.env.NEO_4J_SEARCH_SPACE_BOLT_URL}`;
const searchSpace_user = `${process.env.NEO_4J_SEARCH_SPACE_USER}`;
const searchSpace_password = `${process.env.NEO_4J_SEARCH_SPACE_PASS}`;
const createDriverWithRetry = (url, user, password) => {
    const driver = neo4j.driver(url, neo4j.auth.basic(user, password), {
        maxConnectionPoolSize: 50,
        connectionAcquisitionTimeout: 30000,
        maxTransactionRetryTime: 30000,
    });
    // Verify connectivity on first use
    driver.verifyConnectivity()
        .then(() => console.log(`Successfully connected to Neo4j at ${url}`))
        .catch(error => console.error(`Failed to connect to Neo4j at ${url}:`, error));
    return driver;
};
exports.ledgerSpaceDriver = createDriverWithRetry(ledgerSpace_url, ledgerSpace_user, ledgerSpace_password);
exports.searchSpaceDriver = createDriverWithRetry(searchSpace_url, searchSpace_user, searchSpace_password);
// Graceful shutdown
process.on('SIGINT', () => {
    console.log('Closing Neo4j drivers...');
    Promise.all([exports.ledgerSpaceDriver.close(), exports.searchSpaceDriver.close()])
        .then(() => {
        console.log('Neo4j drivers closed.');
        process.exit(0);
    })
        .catch(error => {
        console.error('Error closing Neo4j drivers:', error);
        process.exit(1);
    });
});
//# sourceMappingURL=neo4j.js.map


File: build/config/logger.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logDCORates = exports.errorLogger = exports.expressLogger = exports.addRequestId = void 0;
const winston_1 = __importDefault(require("winston"));
const winston_daily_rotate_file_1 = __importDefault(require("winston-daily-rotate-file"));
const config_1 = require("./config");
const uuid_1 = require("uuid");
// Configure the logger
const logger = winston_1.default.createLogger({
    level: config_1.config.nodeEnv === "production" ? "info" : "debug",
    format: winston_1.default.format.combine(winston_1.default.format.timestamp(), winston_1.default.format.errors({ stack: true }), winston_1.default.format.splat(), winston_1.default.format.json()),
    defaultMeta: { service: "credex-core" },
    transports: [
        // Rotate error logs daily
        new winston_daily_rotate_file_1.default({
            filename: "logs/error-%DATE%.log",
            datePattern: "YYYY-MM-DD",
            zippedArchive: true,
            maxSize: "20m",
            maxFiles: "14d",
            level: "error",
        }),
        // Rotate combined logs daily
        new winston_daily_rotate_file_1.default({
            filename: "logs/combined-%DATE%.log",
            datePattern: "YYYY-MM-DD",
            zippedArchive: true,
            maxSize: "20m",
            maxFiles: "14d",
        }),
    ],
});
// Add console transport for non-production environments
if (config_1.config.nodeEnv !== "production") {
    logger.add(new winston_1.default.transports.Console({
        format: winston_1.default.format.simple(),
    }));
}
function sanitizeData(data) {
    const sensitiveFields = ['password', 'token', 'apiKey', 'creditCard'];
    if (typeof data === 'object' && data !== null) {
        return Object.keys(data).reduce((acc, key) => {
            if (sensitiveFields.includes(key)) {
                acc[key] = '[REDACTED]';
            }
            else if (typeof data[key] === 'object') {
                acc[key] = sanitizeData(data[key]);
            }
            else {
                acc[key] = data[key];
            }
            return acc;
        }, {});
    }
    return data;
}
exports.default = logger;
/**
 * Middleware for adding a unique request ID
 */
const addRequestId = (req, res, next) => {
    req.id = (0, uuid_1.v4)();
    res.setHeader('X-Request-ID', req.id);
    next();
};
exports.addRequestId = addRequestId;
/**
 * Middleware for logging Express requests
 */
const expressLogger = (req, res, next) => {
    const start = Date.now();
    res.on("finish", () => {
        const duration = Date.now() - start;
        logger.info('User Input', {
            requestId: req.id,
            method: req.method,
            url: req.originalUrl,
            statusCode: res.statusCode,
            duration: `${duration}ms`,
            body: sanitizeData(req.body),
            params: sanitizeData(req.params),
            query: sanitizeData(req.query),
            headers: sanitizeData(req.headers),
            ip: req.ip,
            userAgent: req.get('User-Agent')
        });
    });
    next();
};
exports.expressLogger = expressLogger;
/**
 * Middleware for logging errors
 */
const errorLogger = (err, req, res, next) => {
    logger.error('Error', {
        requestId: req.id,
        message: err.message,
        stack: err.stack,
        method: req.method,
        url: req.originalUrl,
        body: sanitizeData(req.body),
        params: sanitizeData(req.params),
        query: sanitizeData(req.query),
        headers: sanitizeData(req.headers)
    });
    next(err);
};
exports.errorLogger = errorLogger;
/**
 * Function to log DCO rates
 */
const logDCORates = (XAUrate, CXXrate, CXXmultiplier) => {
    logger.info('DCO Rates', { XAUrate, CXXrate, CXXmultiplier });
};
exports.logDCORates = logDCORates;
// TODO: Implement log aggregation and centralized logging for production environments
// TODO: Implement log retention policies based on compliance requirements
// TODO: Add performance monitoring for database queries and external API calls
// TODO: Implement log analysis tools to detect patterns, anomalies, and potential security threats
//# sourceMappingURL=logger.js.map


File: build/config/config.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
exports.config = {
    // Server configuration
    port: process.env.PORT || 5000,
    nodeEnv: process.env.NODE_ENV || 'development',
    deployment: process.env.DEPLOYMENT || 'dev',
    // WhatsApp Bot API configuration
    whatsappBotApiKey: process.env.WHATSAPP_BOT_API_KEY,
    // Neo4j database configuration
    neo4j: {
        ledgerSpace: {
            url: process.env.NEO_4J_LEDGER_SPACE_BOLT_URL,
            user: process.env.NEO_4J_LEDGER_SPACE_USER,
            password: process.env.NEO_4J_LEDGER_SPACE_PASS,
        },
        searchSpace: {
            url: process.env.NEO_4J_SEARCH_SPACE_BOLT_URL,
            user: process.env.NEO_4J_SEARCH_SPACE_USER,
            password: process.env.NEO_4J_SEARCH_SPACE_PASS,
        },
    },
    // External API configuration
    openExchangeRatesApiKey: process.env.OPEN_EXCHANGE_RATES_API,
    // Rate limiting configuration
    rateLimit: {
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100, // limit each IP to 100 requests per windowMs
    },
    // Cron job schedules
    cron: {
        dailyCredcoinOffering: '0 0 * * *', // Every day at midnight UTC
        minuteTransactionQueue: '* * * * *', // Every minute
    },
};
// TODO: Consider adding validation for required environment variables
// and throw meaningful errors if they're missing
//# sourceMappingURL=config.js.map


File: build/config/authenticate.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const config_1 = require("./config");
/**
 * Middleware to authenticate API requests using a WhatsApp Bot API key.
 * This middleware should be applied to routes that require authentication.
 *
 * @param req - The Express request object
 * @param res - The Express response object
 * @param next - The next middleware function
 */
const authenticate = (req, res, next) => {
    const apiKeySubmitted = req.header("whatsappBotAPIkey");
    const validApiKey = config_1.config.whatsappBotApiKey;
    if (!validApiKey) {
        console.error("WHATSAPP_BOT_API_KEY is not defined in environment variables");
        return res.status(500).json({ message: "Server configuration error" });
    }
    if (!apiKeySubmitted) {
        console.warn("Authentication failed: API key not provided.");
        return res.status(401).json({ message: "API key is required" });
    }
    // Use timing-safe comparison to prevent timing attacks
    if (crypto_1.default.timingSafeEqual(Buffer.from(apiKeySubmitted), Buffer.from(validApiKey))) {
        next();
    }
    else {
        return res.status(401).json({ message: "Unauthorized" });
    }
};
exports.default = authenticate;
// TODO: Consider implementing a more robust authentication system,
// such as JWT or OAuth2, for enhanced security and flexibility
//# sourceMappingURL=authenticate.js.map


File: build/middleware/errorHandler.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorHandler = errorHandler;
exports.notFoundHandler = notFoundHandler;
const logger_1 = __importDefault(require("../config/logger"));
const config_1 = require("../config/config");
/**
 * Global error handling middleware
 * @param err - Error object
 * @param req - Express request object
 * @param res - Express response object
 * @param _ - Next middleware function (unused)
 */
function errorHandler(err, req, res, _) {
    const statusCode = err.statusCode || 500;
    const message = err.message || 'Internal Server Error';
    // Log the error
    logger_1.default.error(`[Error] ${statusCode} - ${message}`, {
        error: err,
        stack: err.stack,
        url: req.originalUrl,
        method: req.method,
        ip: req.ip,
    });
    // Send error response
    res.status(statusCode).json({
        status: 'error',
        statusCode,
        message: config_1.config.nodeEnv === 'production' ? message : `${message}\n${err.stack}`,
    });
}
/**
 * Middleware to handle 404 Not Found errors
 * @param req - Express request object
 * @param _res - Express response object (unused)
 * @param next - Next middleware function
 */
function notFoundHandler(req, _res, next) {
    const err = new Error(`Not Found - ${req.originalUrl}`);
    err.statusCode = 404;
    next(err);
}
// TODO: Implement custom error classes for different types of errors (e.g., ValidationError, DatabaseError)
// TODO: Consider adding a central error catalog for consistent error messages and codes
//# sourceMappingURL=errorHandler.js.map


File: build/src/utils/__tests__/validators.test.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const validators_1 = require("../validators");
describe('Validators', () => {
    describe('validateUUID', () => {
        it('should return true for valid UUIDs', () => {
            expect((0, validators_1.validateUUID)('123e4567-e89b-12d3-a456-426614174000')).toBe(true);
            expect((0, validators_1.validateUUID)('550e8400-e29b-41d4-a716-446655440000')).toBe(true);
        });
        it('should return false for invalid UUIDs', () => {
            expect((0, validators_1.validateUUID)('not-a-uuid')).toBe(false);
            expect((0, validators_1.validateUUID)('123e4567-e89b-12d3-a456-42661417400')).toBe(false);
            expect((0, validators_1.validateUUID)('123e4567-e89b-12d3-a456-4266141740000')).toBe(false);
        });
    });
    describe('validateMemberHandle', () => {
        it('should return true for valid member handles', () => {
            expect((0, validators_1.validateMemberHandle)('john_doe')).toBe(true);
            expect((0, validators_1.validateMemberHandle)('user123')).toBe(true);
            expect((0, validators_1.validateMemberHandle)('a.b.c')).toBe(true);
        });
        it('should return false for invalid member handles', () => {
            expect((0, validators_1.validateMemberHandle)('jo')).toBe(false);
            expect((0, validators_1.validateMemberHandle)('user_name_too_long_123456789012345678901234567890')).toBe(false);
            expect((0, validators_1.validateMemberHandle)('Invalid-Handle')).toBe(false);
            expect((0, validators_1.validateMemberHandle)('user@name')).toBe(false);
        });
    });
    describe('validateAccountName', () => {
        it('should return true for valid account names', () => {
            expect((0, validators_1.validateAccountName)('John Doe')).toBe(true);
            expect((0, validators_1.validateAccountName)('Company Name 123')).toBe(true);
            expect((0, validators_1.validateAccountName)('A'.repeat(50))).toBe(true);
        });
        it('should return false for invalid account names', () => {
            expect((0, validators_1.validateAccountName)('Jo')).toBe(false);
            expect((0, validators_1.validateAccountName)('A'.repeat(51))).toBe(false);
            expect((0, validators_1.validateAccountName)('')).toBe(false);
        });
    });
    describe('validateAccountHandle', () => {
        it('should return true for valid account handles', () => {
            expect((0, validators_1.validateAccountHandle)('johndoe')).toBe(true);
            expect((0, validators_1.validateAccountHandle)('company_123')).toBe(true);
            expect((0, validators_1.validateAccountHandle)('a.b.c')).toBe(true);
        });
        it('should return false for invalid account handles', () => {
            expect((0, validators_1.validateAccountHandle)('jo')).toBe(false);
            expect((0, validators_1.validateAccountHandle)('handle_too_long_123456789012345678901234567890')).toBe(false);
            expect((0, validators_1.validateAccountHandle)('Invalid-Handle')).toBe(false);
            expect((0, validators_1.validateAccountHandle)('handle@invalid')).toBe(false);
        });
    });
});
//# sourceMappingURL=validators.test.js.map


File: build/src/utils/denomUtils.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.denomFormatter = void 0;
/**
 * Formats a numerical amount according to the specified denomination.
 * @param amount - The numerical amount to format.
 * @param code - The denomination code.
 * @returns A formatted string representation of the amount.
 */
const denomFormatter = (amount, code) => {
    // Ensure amount is a finite number
    if (!isFinite(amount)) {
        amount = 0;
    }
    /**
     * Formats a currency amount with the specified precision and regionalization.
     * @param amount - The amount to format.
     * @param precision - The number of decimal places to round to.
     * @param regionalization - The locale string for number formatting.
     * @returns A formatted string representation of the amount.
     */
    const formatCurrencyAmount = (amount, precision, regionalization) => {
        return new Intl.NumberFormat(regionalization, {
            minimumFractionDigits: precision,
            maximumFractionDigits: precision,
        }).format(amount);
    };
    const getDenominations = (options) => {
        // This function needs to be imported from denominations.ts
        // For now, we'll just return a mock implementation
        return [{ code, regionalization: 'en-US', fulldescription: '', sourceForRate: '' }];
    };
    const denomData = getDenominations({ code });
    const regionalization = denomData.length > 0 ? denomData[0].regionalization : "en-US";
    let precision;
    switch (code) {
        case "CXX":
            precision = 3;
            break;
        case "XAU":
            precision = 4;
            break;
        default:
            precision = 2;
    }
    return formatCurrencyAmount(amount, precision, regionalization);
};
exports.denomFormatter = denomFormatter;
//# sourceMappingURL=denomUtils.js.map


File: build/src/utils/validators.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateUUID = validateUUID;
exports.validateMemberHandle = validateMemberHandle;
exports.validateAccountName = validateAccountName;
exports.validateAccountHandle = validateAccountHandle;
function validateUUID(uuid) {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
}
function validateMemberHandle(handle) {
    const handleRegex = /^[a-z0-9._]{3,30}$/;
    return handleRegex.test(handle);
}
function validateAccountName(name) {
    return name.length >= 3 && name.length <= 50;
}
function validateAccountHandle(handle) {
    const handleRegex = /^[a-z0-9._]{3,30}$/;
    return handleRegex.test(handle);
}
//# sourceMappingURL=validators.js.map


File: build/src/constants/accountTypes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountTypes = void 0;
exports.checkPermittedAccountType = checkPermittedAccountType;
exports.accountTypes = ["PERSONAL_CONSUMPTION", "BUSINESS", "CREDEX_FOUNDATION"];
function checkPermittedAccountType(credexTypeToCheck) {
    return exports.accountTypes.includes(credexTypeToCheck);
}
//# sourceMappingURL=accountTypes.js.map


File: build/src/constants/credspan.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.credspan = void 0;
exports.checkDueDate = checkDueDate;
const neo4j_1 = require("../../config/neo4j");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
exports.credspan = 35;
async function checkDueDate(dueDate) {
    const dueDateMoment = moment_timezone_1.default.utc(dueDate, "YYYY-MM-DD", true);
    if (!dueDateMoment.isValid()) {
        console.error("Due date not in valid format");
        return false;
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const currentDateQuery = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      RETURN daynode.Date AS today
    `);
    const today = currentDateQuery.records[0].get("today");
    if (!today) {
        console.log("could not get date from daynode");
        return false;
    }
    const lastPermittedDayMoment = (0, moment_timezone_1.default)(today)
        .subtract(1, "months") // because of diff date formats
        .add(exports.credspan, "days");
    const firstPermittedDayMoment = (0, moment_timezone_1.default)(today)
        .subtract(1, "months") // because of diff date formats
        .add(7, "days");
    if (dueDateMoment >= lastPermittedDayMoment ||
        dueDateMoment < firstPermittedDayMoment) {
        console.error("Due date is not within permitted credspan");
        return false;
    }
    return true;
}
//# sourceMappingURL=credspan.js.map


File: build/src/constants/denominations.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidDenomination = exports.getFullDescription = void 0;
exports.getDenominations = getDenominations;
/**
 * Array of supported denominations in the Credex system.
 */
const denominations = [
    {
        code: "CXX",
        fulldescription: "CXX (Credcoin)",
        regionalization: "en-CA",
        sourceForRate: "DCO",
    },
    {
        code: "CAD",
        fulldescription: "CAD (Canadian Dollars)",
        regionalization: "en-CA",
        sourceForRate: "OpenExchangeRates",
    },
    {
        code: "USD",
        fulldescription: "USD (United States Dollars)",
        regionalization: "en-US",
        sourceForRate: "OpenExchangeRates",
    },
    {
        code: "XAU",
        fulldescription: "XAU (Troy Gold Ounces)",
        regionalization: "en-CA",
        sourceForRate: "OpenExchangeRates",
    },
    {
        code: "ZIG",
        fulldescription: "ZIG (Zimbabwe Gold Official Rate)",
        regionalization: "en-CA",
        sourceForRate: "RBZ",
    },
];
/**
 * Retrieves denominations based on provided options.
 * @param options - Options for filtering denominations.
 * @returns An array of Denomination objects or a comma-separated string of denomination codes.
 */
function getDenominations(options) {
    let result = denominations;
    if (options.code) {
        result = result.filter((denom) => denom.code === options.code);
    }
    if (options.sourceForRate) {
        result = result.filter((denom) => denom.sourceForRate === options.sourceForRate);
    }
    if (options.formatAsList) {
        return result.map((denom) => denom.code).join(",");
    }
    return result;
}
/**
 * Retrieves the full description of a denomination by its code.
 * @param code - The denomination code.
 * @returns The full description of the denomination, or undefined if not found.
 */
const getFullDescription = (code) => {
    const denom = denominations.find((d) => d.code === code);
    return denom?.fulldescription;
};
exports.getFullDescription = getFullDescription;
/**
 * Checks if a given code is a valid denomination.
 * @param code - The denomination code to check.
 * @returns True if the code is a valid denomination, false otherwise.
 */
const isValidDenomination = (code) => {
    return denominations.some((d) => d.code === code);
};
exports.isValidDenomination = isValidDenomination;
//# sourceMappingURL=denominations.js.map


File: build/src/constants/credexTypes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.credexTypes = void 0;
exports.checkPermittedCredexType = checkPermittedCredexType;
exports.credexTypes = [
    "PURCHASE",
    "GIFT",
    "DCO_GIVE",
    "DCO_RECEIVE"
];
function checkPermittedCredexType(credexTypeToCheck) {
    return exports.credexTypes.includes(credexTypeToCheck);
}
//# sourceMappingURL=credexTypes.js.map


File: build/src/Core/cronJobs.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = startCronJobs;
const node_cron_1 = __importDefault(require("node-cron"));
const DailyCredcoinOffering_1 = require("./DCO/DailyCredcoinOffering");
const MinuteTransactionQueue_1 = require("./MTQ/MinuteTransactionQueue");
function startCronJobs() {
    // Running DailyCredcoinOffering every day at midnight UTC
    node_cron_1.default.schedule("0 0 * * *", async () => {
        try {
            await (0, DailyCredcoinOffering_1.DailyCredcoinOffering)();
        }
        catch (error) {
            console.error("Error running DailyCredcoinOffering:", error);
        }
    }, {
        timezone: "UTC",
    });
    // Running MinuteTransactionQueue every minute
    node_cron_1.default.schedule("* * * * *", async () => {
        try {
            await (0, MinuteTransactionQueue_1.MinuteTransactionQueue)();
        }
        catch (error) {
            console.error("Error running MinuteTransactionQueue:", error);
        }
    });
}
//# sourceMappingURL=cronJobs.js.map


File: build/src/Core/constants/accountTypes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountTypes = void 0;
exports.checkPermittedAccountType = checkPermittedAccountType;
exports.accountTypes = ["PERSONAL_CONSUMPTION", "BUSINESS", "CREDEX_FOUNDATION"];
function checkPermittedAccountType(credexTypeToCheck) {
    return exports.accountTypes.includes(credexTypeToCheck);
}
//# sourceMappingURL=accountTypes.js.map


File: build/src/Core/constants/credspan.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.credspan = void 0;
exports.checkDueDate = checkDueDate;
const neo4j_1 = require("../../../config/neo4j");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
exports.credspan = 35;
async function checkDueDate(dueDate) {
    const dueDateMoment = moment_timezone_1.default.utc(dueDate, "YYYY-MM-DD", true);
    if (!dueDateMoment.isValid()) {
        console.error("Due date not in valid format");
        return false;
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const currentDateQuery = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      RETURN daynode.Date AS today
    `);
    const today = currentDateQuery.records[0].get("today");
    if (!today) {
        console.log("could not get date from daynode");
        return false;
    }
    const lastPermittedDayMoment = (0, moment_timezone_1.default)(today)
        .subtract(1, "months") // because of diff date formats
        .add(exports.credspan, "days");
    const firstPermittedDayMoment = (0, moment_timezone_1.default)(today)
        .subtract(1, "months") // because of diff date formats
        .add(7, "days");
    if (dueDateMoment >= lastPermittedDayMoment ||
        dueDateMoment < firstPermittedDayMoment) {
        console.error("Due date is not within permitted credspan");
        return false;
    }
    return true;
}
//# sourceMappingURL=credspan.js.map


File: build/src/Core/constants/denominations.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidDenomination = exports.getFullDescription = exports.denomFormatter = void 0;
exports.getDenominations = getDenominations;
/**
 * Array of supported denominations in the Credex system.
 */
const denominations = [
    {
        code: "CXX",
        fulldescription: "CXX (Credcoin)",
        regionalization: "en-CA",
        sourceForRate: "DCO",
    },
    {
        code: "CAD",
        fulldescription: "CAD (Canadian Dollars)",
        regionalization: "en-CA",
        sourceForRate: "OpenExchangeRates",
    },
    {
        code: "USD",
        fulldescription: "USD (United States Dollars)",
        regionalization: "en-US",
        sourceForRate: "OpenExchangeRates",
    },
    {
        code: "XAU",
        fulldescription: "XAU (Troy Gold Ounces)",
        regionalization: "en-CA",
        sourceForRate: "OpenExchangeRates",
    },
    {
        code: "ZIG",
        fulldescription: "ZIG (Zimbabwe Gold Official Rate)",
        regionalization: "en-CA",
        sourceForRate: "RBZ",
    },
];
/**
 * Retrieves denominations based on provided options.
 * @param options - Options for filtering denominations.
 * @returns An array of Denomination objects or a comma-separated string of denomination codes.
 */
function getDenominations(options) {
    let result = denominations;
    if (options.code) {
        result = result.filter((denom) => denom.code === options.code);
    }
    if (options.sourceForRate) {
        result = result.filter((denom) => denom.sourceForRate === options.sourceForRate);
    }
    if (options.formatAsList) {
        return result.map((denom) => denom.code).join(",");
    }
    return result;
}
/**
 * Formats a numerical amount according to the specified denomination.
 * @param amount - The numerical amount to format.
 * @param code - The denomination code.
 * @returns A formatted string representation of the amount.
 */
const denomFormatter = (amount, code) => {
    // Ensure amount is a finite number
    if (!isFinite(amount)) {
        amount = 0;
    }
    /**
     * Formats a currency amount with the specified precision and regionalization.
     * @param amount - The amount to format.
     * @param precision - The number of decimal places to round to.
     * @param regionalization - The locale string for number formatting.
     * @returns A formatted string representation of the amount.
     */
    const formatCurrencyAmount = (amount, precision, regionalization) => {
        const roundedAmount = Number(amount.toFixed(precision));
        return new Intl.NumberFormat(regionalization).format(roundedAmount);
    };
    const denomData = getDenominations({ code });
    const regionalization = denomData.length > 0 ? denomData[0].regionalization : "en-US";
    let formattedAmount;
    switch (code) {
        case "CXX":
            formattedAmount = formatCurrencyAmount(amount, 3, regionalization);
            break;
        case "XAU":
            formattedAmount = formatCurrencyAmount(amount, 4, regionalization);
            break;
        default:
            formattedAmount = formatCurrencyAmount(amount, 2, regionalization);
    }
    return formattedAmount;
};
exports.denomFormatter = denomFormatter;
/**
 * Retrieves the full description of a denomination by its code.
 * @param code - The denomination code.
 * @returns The full description of the denomination, or undefined if not found.
 */
const getFullDescription = (code) => {
    const denom = denominations.find((d) => d.code === code);
    return denom?.fulldescription;
};
exports.getFullDescription = getFullDescription;
/**
 * Checks if a given code is a valid denomination.
 * @param code - The denomination code to check.
 * @returns True if the code is a valid denomination, false otherwise.
 */
const isValidDenomination = (code) => {
    return denominations.some((d) => d.code === code);
};
exports.isValidDenomination = isValidDenomination;
//# sourceMappingURL=denominations.js.map


File: build/src/Core/constants/credexTypes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.credexTypes = void 0;
exports.checkPermittedCredexType = checkPermittedCredexType;
exports.credexTypes = [
    "PURCHASE",
    "GIFT",
    "DCO_GIVE",
    "DCO_RECEIVE"
];
function checkPermittedCredexType(credexTypeToCheck) {
    return exports.credexTypes.includes(credexTypeToCheck);
}
//# sourceMappingURL=credexTypes.js.map


File: build/src/Core/DCO/DCOavatars.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DCOavatars = DCOavatars;
const neo4j_1 = require("../../../config/neo4j");
const OfferCredex_1 = require("../../api/Credex/services/OfferCredex");
const AcceptCredex_1 = require("../../api/Credex/services/AcceptCredex");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
/**
 * DCOavatars function
 * This function is run as a cronjob every 24 hours to process recurring avatars.
 * It identifies active recurring avatars, creates credexes, and updates there status.
 */
async function DCOavatars() {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        console.log("Checking for activated recurring avatars...");
        // Query to get active recurring avatars that are due for processing
        const GetActiveRecurringAvatars = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      MATCH
        (issuer:Account)-[rel1:ACTIVE]->
        (avatar:Avatar { avatarType: "RECURRING", nextPayDate: daynode.Date})-[rel2:ACTIVE]->
        (acceptor:Account)
      MATCH
        (issuer)<-[authRel1:AUTHORIZED_FOR]-
        (avatar)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2
      
      // Reduce remainingPays by 1 if it exists
      SET avatar.remainingPays = 
        CASE
          WHEN avatar.remainingPays IS NOT NULL THEN avatar.remainingPays - 1
          ELSE null
        END
      
      // Calculate the new nextPayDate
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2,
           CASE
             WHEN avatar.remainingPays IS NULL OR avatar.remainingPays > 0 
             THEN date(avatar.nextPayDate) + duration({days: avatar.daysBetweenPays})
             ELSE null
           END AS newNextPayDate
      
      // Update nextPayDate
      SET avatar.nextPayDate = newNextPayDate
      
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2, newNextPayDate
      
      // Check if the avatar should be marked as completed
      OPTIONAL MATCH (issuer)-[completed1:COMPLETED]->(avatar)-[completed2:COMPLETED]->(acceptor)
      FOREACH(ignoreMe IN CASE WHEN newNextPayDate IS NULL AND completed1 IS NULL
               THEN [1] ELSE [] END |
        DELETE rel1, rel2
        SET
          authRel1.markedToDelete = true,
          authRel2.markedToDelete = true
        CREATE (issuer)-[:COMPLETED]->(avatar)-[:COMPLETED]->(acceptor)
      )
      
      RETURN
        avatar {
          .*,
          remainingPays: avatar.remainingPays,
          nextPayDate: avatar.nextPayDate
        } AS avatar,
        issuer.accountID AS issuerAccountID,
        acceptor.accountID AS acceptorAccountID,
        daynode.Date AS Date    
    `);
        // Process each active recurring avatar
        for (const record of GetActiveRecurringAvatars.records) {
            const avatar = record.get("avatar");
            const issuerAccountID = record.get("issuerAccountID");
            const acceptorAccountID = record.get("acceptorAccountID");
            try {
                // Prepare data for creating a new credex
                const offerData = {
                    memberID: avatar.memberID,
                    issuerAccountID: issuerAccountID,
                    receiverAccountID: acceptorAccountID,
                    Denomination: avatar.Denomination,
                    InitialAmount: avatar.InitialAmount,
                    credexType: "PURCHASE",
                    OFFERSorREQUESTS: "OFFERS",
                };
                // Handle secured and unsecured credexes differently
                if (avatar.securedCredex) {
                    offerData.securedCredex = true;
                }
                else {
                    // Calculate dueDate for unsecured credexes using the avatar's credspan
                    avatar.dueDate = (0, moment_timezone_1.default)(record.get("Date"))
                        .add(parseInt(avatar.credspan), "days")
                        .subtract(parseInt("1"), "month")
                        .format("YYYY-MM-DD");
                    offerData.dueDate = avatar.dueDate;
                }
                // Create a new credex offer
                const offerResult = await (0, OfferCredex_1.OfferCredexService)(offerData);
                // If offer is successful, automatically accept it
                if (offerResult &&
                    typeof offerResult.credex === "object" &&
                    offerResult.credex.credexID) {
                    const acceptResult = await (0, AcceptCredex_1.AcceptCredexService)(offerResult.credex.credexID, avatar.memberID);
                    if (acceptResult) {
                        console.log(`Successfully created credex for recurring avatar: ${avatar.memberID}. Remaining pays: ${avatar.remainingPays}, Next pay date: ${avatar.nextPayDate}`);
                    }
                    else {
                        throw new Error(`Failed to accept credex for avatar: ${avatar.memberID}`);
                    }
                }
                else {
                    throw new Error(`Failed to create offer for avatar: ${avatar.memberID}`);
                }
                const deleteAvatarAuths = await ledgerSpaceSession.run(`
          MATCH ()-[rel:AUTHORIZED_FOR {markedToDelete: true}]->()
          DELETE rel
          `);
            }
            catch (error) {
                console.error(`Error processing avatar ${avatar.memberID}:`, error);
                // TODO: Implement member notification about the failure
                console.log(`Placeholder: Notify member ${avatar.memberID} about the failure in processing their recurring avatar.`);
            }
        }
    }
    catch (error) {
        console.error("Error in DCOavatars:", error);
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=DCOavatars.js.map


File: build/src/Core/DCO/DailyCredcoinOffering.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DailyCredcoinOffering = DailyCredcoinOffering;
const neo4j_1 = require("../../../config/neo4j");
const DBinitialization_1 = require("./DBinitialization");
const DCOexecute_1 = require("./DCOexecute");
const DCOavatars_1 = require("./DCOavatars");
const logger_1 = __importDefault(require("../../../config/logger"));
/**
 * Executes the Daily Credcoin Offering (DCO) process.
 * This function checks for an active daynode, initializes the database if necessary,
 * and runs the DCO execution and avatar update processes.
 *
 * @returns {Promise<boolean>} Returns true if the DCO process completes successfully, false otherwise.
 */
async function DailyCredcoinOffering() {
    console.log("Starting Daily Credcoin Offering process");
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        // Check for active daynode
        const daynodeExists = await checkActiveDaynode(ledgerSpaceSession);
        if (!daynodeExists) {
            console.log("No active daynode found. Initializing database...");
            await (0, DBinitialization_1.DBinitialization)();
            console.log("Database initialization complete");
        }
        await (0, DCOexecute_1.DCOexecute)();
        await (0, DCOavatars_1.DCOavatars)();
        return true;
    }
    catch (error) {
        logger_1.default.error("Error in DailyCredcoinOffering", error);
        return false;
    }
    finally {
        await resetDCORunningFlag(ledgerSpaceSession);
        await ledgerSpaceSession.close();
    }
}
/**
 * Checks if an active daynode exists in the database.
 *
 * @param {Neo4jSession} session - The Neo4j session to use for the query.
 * @returns {Promise<boolean>} Returns true if an active daynode exists, false otherwise.
 */
async function checkActiveDaynode(session) {
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN daynode IS NOT NULL AS activeDaynodeExists
  `);
    return result.records[0].get("activeDaynodeExists");
}
/**
 * Resets the DCOrunningNow flag on the active daynode.
 *
 * @param {Neo4jSession} session - The Neo4j session to use for the query.
 */
async function resetDCORunningFlag(session) {
    console.log("Resetting DCOrunningNow flag");
    await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    SET daynode.DCOrunningNow = false
  `);
}
//# sourceMappingURL=DailyCredcoinOffering.js.map


File: build/src/Core/DCO/DBbackup.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNeo4jBackup = void 0;
const neo4j_1 = require("../../../config/neo4j");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const exportDatabase = async (driver, databaseName, previousDate, append) => {
    const session = driver.session();
    try {
        const fileName = `${previousDate}_${databaseName}${append}.json`;
        const filePath = path_1.default.join(__dirname, "DCOsnapshots", fileName);
        const result = await session.run(`
      CALL apoc.export.json.all(null, {stream:true, useTypes:true})
    `);
        const records = result.records;
        let jsonData = "";
        records.forEach((record) => {
            jsonData += record.get(0);
        });
        fs_1.default.writeFileSync(filePath, jsonData);
        console.log(`Backup for ${databaseName} created successfully: ${filePath}`);
    }
    catch (error) {
        console.error(`Error creating backup for ${databaseName}:`, error);
        throw error;
    }
    finally {
        await session.close();
    }
};
const createNeo4jBackup = async (previousDate, append) => {
    try {
        await exportDatabase(neo4j_1.ledgerSpaceDriver, "ledgerSpace_dev", previousDate, append);
        await exportDatabase(neo4j_1.searchSpaceDriver, "searchSpace_dev", previousDate, append);
        console.log("Both databases backed up successfully.");
    }
    catch (error) {
        console.error("Error creating backups:", error);
        throw error;
    }
};
exports.createNeo4jBackup = createNeo4jBackup;
//# sourceMappingURL=DBbackup.js.map


File: build/src/Core/DCO/DCOsnapshots/placeholder.js
----------------------------------------
"use strict";
//placeholder
//# sourceMappingURL=placeholder.js.map


File: build/src/Core/DCO/DCOexecute.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DCOexecute = DCOexecute;
const axios_1 = __importDefault(require("axios"));
const lodash_1 = __importDefault(require("lodash"));
const neo4j_1 = require("../../../config/neo4j");
const denominations_1 = require("../../constants/denominations");
const GetSecuredAuthorization_1 = require("../../api/Credex/services/GetSecuredAuthorization");
const OfferCredex_1 = require("../../api/Credex/services/OfferCredex");
const AcceptCredex_1 = require("../../api/Credex/services/AcceptCredex");
const fetchZigRate_1 = require("./fetchZigRate");
const DBbackup_1 = require("./DBbackup");
const logger_1 = __importDefault(require("../../../config/logger"));
/**
 * Executes the Daily Credcoin Offering (DCO) process.
 * This function handles the daily operations of the Credcoin system,
 * including rate updates, participant validation, and transaction processing.
 */
async function DCOexecute() {
    console.log("Starting DCOexecute");
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    try {
        await waitForMTQCompletion(ledgerSpaceSession);
        const { previousDate, nextDate } = await setDCORunningFlag(ledgerSpaceSession);
        await (0, DBbackup_1.createNeo4jBackup)(previousDate, "_end");
        await handleDefaultingCredexes(ledgerSpaceSession);
        await expirePendingOffers(ledgerSpaceSession);
        const USDbaseRates = await fetchCurrencyRates(nextDate);
        const { newCXXrates, CXXprior_CXXcurrent, DCOinCXX, DCOinXAU, numberConfirmedParticipants, } = await processDCOParticipants(ledgerSpaceSession, USDbaseRates);
        await createNewDaynode(ledgerSpaceSession, newCXXrates, nextDate, CXXprior_CXXcurrent);
        await updateCredexBalances(ledgerSpaceSession, searchSpaceSession, newCXXrates, CXXprior_CXXcurrent);
        const { foundationID, foundationXOid } = await getFoundationData(ledgerSpaceSession);
        await processDCOTransactions(ledgerSpaceSession, foundationID, foundationXOid, DCOinCXX, numberConfirmedParticipants);
        await (0, DBbackup_1.createNeo4jBackup)(nextDate, "_start");
        console.log(`DCOexecute completed for ${nextDate}`);
        return true;
    }
    catch (error) {
        logger_1.default.error("Error during DCOexecute", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
async function waitForMTQCompletion(session) {
    console.log("Waiting for MTQ completion");
    let MTQflag = true;
    while (MTQflag) {
        const result = await session.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.MTQrunningNow AS MTQflag
    `);
        MTQflag = result.records[0]?.get("MTQflag");
        if (MTQflag) {
            console.log("MTQ running. Waiting 5 seconds...");
            await new Promise((resolve) => setTimeout(resolve, 5000));
        }
    }
    console.log("MTQ not running. Proceeding...");
}
async function setDCORunningFlag(session) {
    console.log("Setting DCOrunningNow flag");
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    SET daynode.DCOrunningNow = true
    RETURN
      daynode.Date AS previousDate,
      daynode.Date + Duration({days: 1}) AS nextDate
  `);
    const previousDate = result.records[0].get("previousDate");
    const nextDate = result.records[0].get("nextDate");
    console.log(`Expiring day: ${previousDate}`);
    return { previousDate, nextDate };
}
async function handleDefaultingCredexes(session) {
    console.log("Processing defaulting unsecured credexes");
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    OPTIONAL MATCH (account1:Account)-[rel1:OWES]->(defaulting:Credex)-[rel2:OWES]->(account2:Account)
    WHERE defaulting.dueDate <= daynode.Date AND defaulting.DefaultedAmount <= 0
    SET defaulting.DefaultedAmount = defaulting.OutstandingAmount
    WITH defaulting, daynode
    UNWIND defaulting AS defaultingCredex
    CREATE (defaultingCredex)-[:DEFAULTED_ON]->(daynode)
    RETURN count(defaulting) AS numberDefaulted
  `);
    const numberDefaulted = result.records[0]?.get("numberDefaulted") || 0;
    console.log(`Defaults: ${numberDefaulted}`);
}
async function expirePendingOffers(session) {
    console.log("Expiring pending offers/requests");
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    OPTIONAL MATCH (:Account)-[rel1:OFFERS|REQUESTS]->(expiringPending:Credex)-[rel2:OFFERS|REQUESTS]->(:Account),
    (expiringPending)-[:CREATED_ON]->(createdDaynode:Daynode)
    WHERE createdDaynode.Date + Duration({days: 1}) < daynode.Date
    DELETE rel1, rel2
    RETURN count(expiringPending) AS numberExpiringPending
  `);
    const numberExpiringPending = result.records[0]?.get("numberExpiringPending") || 0;
    console.log(`Expired pending offers/requests: ${numberExpiringPending}`);
}
async function fetchCurrencyRates(nextDate) {
    console.log("Fetching currency rates");
    const symbols = (0, denominations_1.getDenominations)({
        sourceForRate: "OpenExchangeRates",
        formatAsList: true,
    });
    const { data: { rates: USDbaseRates }, } = await axios_1.default.get(`https://openexchangerates.org/api/historical/${nextDate}.json`, { params: { app_id: process.env.OPEN_EXCHANGE_RATES_API, symbols } });
    const ZIGrates = await (0, fetchZigRate_1.fetchZigRate)();
    USDbaseRates.ZIG = ZIGrates.length > 0 ? parseFloat(ZIGrates[1].avg) : NaN;
    validateRates(USDbaseRates);
    return USDbaseRates;
}
function validateRates(rates) {
    const allDenoms = (0, denominations_1.getDenominations)({});
    const denomsToCheck = allDenoms.filter((denom) => denom.code !== "CXX");
    const allValid = denomsToCheck.every((denom) => rates.hasOwnProperty(denom.code) &&
        typeof rates[denom.code] === "number" &&
        !isNaN(rates[denom.code]));
    if (!allValid) {
        throw new Error("Invalid or missing currency rates");
    }
}
async function processDCOParticipants(session, USDbaseRates) {
    console.log("Processing DCO participants");
    const denomsInXAU = lodash_1.default.mapValues(USDbaseRates, (value) => value / USDbaseRates.XAU);
    const result = await session.run(`
    MATCH (daynode:Daynode{Active:true})
    MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
    WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
    RETURN
      DCOparticpantsDeclared.accountID AS accountID,
      DCOmember.memberID AS DCOmemberID,
      DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
      DCOparticpantsDeclared.DCOgiveInCXX / daynode[DCOparticpantsDeclared.DCOdenom] AS DCOgiveInDenom,
      DCOparticpantsDeclared.DCOdenom AS DCOdenom
  `);
    const declaredParticipants = result.records;
    console.log(`Declared participants: ${declaredParticipants.length}`);
    let DCOinCXX = 0;
    let DCOinXAU = 0;
    const confirmedParticipants = [];
    for (const participant of declaredParticipants) {
        const { accountID, DCOmemberID, DCOdenom, DCOgiveInCXX, DCOgiveInDenom } = participant.toObject();
        const { securableAmountInDenom } = await (0, GetSecuredAuthorization_1.GetSecuredAuthorizationService)(accountID, DCOdenom);
        if (DCOgiveInDenom <= securableAmountInDenom) {
            confirmedParticipants.push({
                accountID,
                DCOmemberID,
                DCOdenom,
                DCOgiveInCXX,
                DCOgiveInDenom,
            });
            DCOinCXX += DCOgiveInCXX;
            DCOinXAU += DCOgiveInDenom / denomsInXAU[DCOdenom];
        }
    }
    const numberConfirmedParticipants = confirmedParticipants.length;
    const nextCXXinXAU = DCOinXAU / numberConfirmedParticipants;
    const CXXprior_CXXcurrent = DCOinCXX / numberConfirmedParticipants;
    console.log(`Confirmed participants: ${numberConfirmedParticipants}`);
    console.log(`DCO in CXX: ${DCOinCXX}`);
    console.log(`DCO in XAU: ${DCOinXAU}`);
    console.log(`Next CXX in XAU: ${nextCXXinXAU}`);
    const newCXXrates = lodash_1.default.mapValues(denomsInXAU, (value) => 1 / nextCXXinXAU / value);
    newCXXrates.CXX = 1;
    logger_1.default.info("DCO Rates", {
        USDinXAU: denomsInXAU.XAU,
        CXXinXAU: newCXXrates.CXX,
        CXXprior_CXXcurrent,
    });
    return {
        newCXXrates,
        CXXprior_CXXcurrent,
        DCOinCXX,
        DCOinXAU,
        numberConfirmedParticipants,
        confirmedParticipants,
    };
}
async function createNewDaynode(session, newCXXrates, nextDate, CXXprior_CXXcurrent) {
    console.log("Creating new daynode");
    await session.run(`
    MATCH (expiringDaynode:Daynode {Active: TRUE})
    CREATE (expiringDaynode)-[:NEXT_DAY]->(nextDaynode:Daynode)
    SET expiringDaynode.Active = false,
        expiringDaynode.DCOrunningNow = false,
        nextDaynode = $newCXXrates,
        nextDaynode.CXXprior_CXXcurrent = $CXXprior_CXXcurrent,
        nextDaynode.Date = date($nextDate),
        nextDaynode.Active = true,
        nextDaynode.DCOrunningNow = true
  `, { newCXXrates, nextDate, CXXprior_CXXcurrent });
}
async function updateCredexBalances(ledgerSession, searchSession, newCXXrates, CXXprior_CXXcurrent) {
    console.log("Updating credex and asset balances");
    // Update ledger space
    await ledgerSession.run(`
    MATCH (newDaynode:Daynode {Active: TRUE})

    // Update CXX credexes
    MATCH (credcoinCredex:Credex)
    WHERE credcoinCredex.Denomination = "CXX"
    SET 
      credcoinCredex.InitialAmount = credcoinCredex.InitialAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.OutstandingAmount = credcoinCredex.OutstandingAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.RedeemedAmount = credcoinCredex.RedeemedAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.DefaultedAmount = credcoinCredex.DefaultedAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.WrittenOffAmount = credcoinCredex.WrittenOffAmount / newDaynode.CXXprior_CXXcurrent

    // Update currency credexes
    MATCH (currencyCredex:Credex)
    WHERE currencyCredex.Denomination <> "CXX"
    SET
      currencyCredex.InitialAmount = (currencyCredex.InitialAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.OutstandingAmount = (currencyCredex.OutstandingAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.RedeemedAmount = (currencyCredex.RedeemedAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.DefaultedAmount = (currencyCredex.DefaultedAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.WrittenOffAmount = (currencyCredex.WrittenOffAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.CXXmultiplier = newDaynode[currencyCredex.Denomination]

    // Update CXX :REDEEMED relationships
    MATCH ()-[CXXredeemed:REDEEMED]-()
    WHERE CXXredeemed.Denomination = "CXX"
    SET
      CXXredeemed.AmountRedeemed = CXXredeemed.AmountRedeemed / newDaynode.CXXprior_CXXcurrent,
      CXXredeemed.AmountOutstandingNow = CXXredeemed.AmountOutstandingNow / newDaynode.CXXprior_CXXcurrent

    // Update currency :REDEEMED relationships
    MATCH ()-[currencyRedeemed:REDEEMED]-()
    WHERE currencyRedeemed.Denomination <> "CXX"
    SET
      currencyRedeemed.AmountOutstandingNow = (currencyRedeemed.AmountOutstandingNow / currencyRedeemed.CXXmultiplier) * newDaynode[currencyRedeemed.Denomination],
      currencyRedeemed.AmountRedeemed = (currencyRedeemed.AmountRedeemed / currencyRedeemed.CXXmultiplier) * newDaynode[currencyRedeemed.Denomination],
      currencyRedeemed.CXXmultiplier = newDaynode[currencyRedeemed.Denomination]

    // Update CXX :CREDLOOP relationships
    MATCH ()-[CXXcredloop:CREDLOOP]-()
    WHERE CXXcredloop.Denomination = "CXX"
    SET
      CXXcredloop.AmountRedeemed = CXXcredloop.AmountRedeemed / newDaynode.CXXprior_CXXcurrent,
      CXXcredloop.AmountOutstandingNow = CXXcredloop.AmountOutstandingNow / newDaynode.CXXprior_CXXcurrent

    // Update currency :CREDLOOP relationships
    MATCH ()-[currencyCredloop:CREDLOOP]-()
    WHERE currencyCredloop.Denomination <> "CXX"
    SET
      currencyCredloop.AmountOutstandingNow = (currencyCredloop.AmountOutstandingNow / currencyCredloop.CXXmultiplier) * newDaynode[currencyCredloop.Denomination],
      currencyCredloop.AmountRedeemed = (currencyCredloop.AmountRedeemed / currencyCredloop.CXXmultiplier) * newDaynode[currencyCredloop.Denomination],
      currencyCredloop.CXXmultiplier = newDaynode[currencyCredloop.Denomination]

    // Update loop anchors (always CXX)
    MATCH (loopAnchors:LoopAnchor)
    SET
      loopAnchors.LoopedAmount = loopAnchors.LoopedAmount / newDaynode.CXXprior_CXXcurrent
  `);
    // Update search space
    await searchSession.run(`
    MATCH (credex:Credex)
    WHERE credex.Denomination = "CXX"
    SET credex.outstandingAmount = credex.outstandingAmount / $CXXprior_CXXcurrent
  `, { CXXprior_CXXcurrent });
    await searchSession.run(`
    MATCH (credex:Credex)
    WHERE credex.Denomination <> "CXX"
    WITH credex, $newCXXrates AS rates
    SET credex.outstandingAmount = (credex.outstandingAmount / credex.CXXmultiplier) * coalesce(rates[credex.Denomination], 1),
        credex.CXXmultiplier = coalesce(rates[credex.Denomination], 1)
  `, { newCXXrates });
}
async function getFoundationData(session) {
    const result = await session.run(`
    MATCH (credexFoundation:Account {accountType: "CREDEX_FOUNDATION"})<-[:OWNS]-(foundationXO:Member)
    RETURN credexFoundation.accountID AS foundationID, foundationXO.memberID AS foundationXOid
  `);
    return {
        foundationID: result.records[0].get("foundationID"),
        foundationXOid: result.records[0].get("foundationXOid"),
    };
}
async function processDCOTransactions(session, foundationID, foundationXOid, DCOinCXX, numberConfirmedParticipants) {
    console.log("Processing DCO transactions");
    const confirmedParticipants = (await session.run(`
    MATCH (daynode:Daynode{Active:true})
    MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
    WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
    RETURN
      DCOparticpantsDeclared.accountID AS accountID,
      DCOmember.memberID AS DCOmemberID,
      DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
      DCOparticpantsDeclared.DCOgiveInCXX / daynode[DCOparticpantsDeclared.DCOdenom] AS DCOgiveInDenom,
      DCOparticpantsDeclared.DCOdenom AS DCOdenom
  `)).records.map((record) => record.toObject());
    // Process DCO give transactions
    await Promise.all(confirmedParticipants.map(async (participant) => {
        const dataForDCOgive = {
            memberID: participant.DCOmemberID,
            issuerAccountID: participant.accountID,
            receiverAccountID: foundationID,
            Denomination: participant.DCOdenom,
            InitialAmount: participant.DCOgiveInDenom,
            credexType: "DCO_GIVE",
            securedCredex: true,
        };
        const DCOgiveCredex = await (0, OfferCredex_1.OfferCredexService)(dataForDCOgive);
        if (typeof DCOgiveCredex.credex === "boolean" ||
            !DCOgiveCredex.credex?.credexID) {
            throw new Error("Invalid response from OfferCredexService for DCO give");
        }
        await (0, AcceptCredex_1.AcceptCredexService)(DCOgiveCredex.credex.credexID, foundationXOid);
    }));
    // Process DCO receive transactions
    await Promise.all(confirmedParticipants.map(async (participant) => {
        const dataForDCOreceive = {
            memberID: foundationXOid,
            issuerAccountID: foundationID,
            receiverAccountID: participant.accountID,
            Denomination: "CXX",
            InitialAmount: DCOinCXX / numberConfirmedParticipants,
            credexType: "DCO_RECEIVE",
            securedCredex: true,
        };
        const DCOreceiveCredex = await (0, OfferCredex_1.OfferCredexService)(dataForDCOreceive);
        if (typeof DCOreceiveCredex.credex === "boolean" ||
            !DCOreceiveCredex.credex?.credexID) {
            throw new Error("Invalid response from OfferCredexService for DCO receive");
        }
        await (0, AcceptCredex_1.AcceptCredexService)(DCOreceiveCredex.credex.credexID, foundationXOid);
    }));
}
//# sourceMappingURL=DCOexecute.js.map


File: build/src/Core/DCO/fetchZigRate.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchZigRate = fetchZigRate;
const axios_1 = __importDefault(require("axios"));
const cheerio_1 = __importDefault(require("cheerio"));
const https = require("https");
const url = "https://www.rbz.co.zw/index.php";
const httpsAgent = new https.Agent({
    rejectUnauthorized: false, // To Ignore SSL errors in dev
});
async function fetchZigRate() {
    try {
        const { data } = await axios_1.default.get(url, { httpsAgent });
        const parsedHtml = cheerio_1.default.load(data);
        const rates = [];
        parsedHtml("#baTab1 table tbody tr").each((index, element) => {
            const currency = parsedHtml(element)
                .find("td")
                .eq(0)
                .text()
                .trim();
            const bid = parsedHtml(element).find("td").eq(1).text().trim();
            const ask = parsedHtml(element).find("td").eq(2).text().trim();
            const avg = parsedHtml(element).find("td").eq(3).text().trim();
            if (currency && bid && ask && avg) {
                rates.push({ currency, bid, ask, avg });
            }
        });
        //console.log(rates);
        return rates;
    }
    catch (error) {
        console.error("Error fetching exchange rates:", error);
        return [];
    }
}
//# sourceMappingURL=fetchZigRate.js.map


File: build/src/Core/DCO/DBinitialization.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBinitialization = DBinitialization;
const neo4j_1 = require("../../../config/neo4j");
const denominations_1 = require("../../constants/denominations");
const onboardMember_1 = require("../../api/Member/controllers/onboardMember");
const updateMemberTier_1 = require("../../api/Member/controllers/updateMemberTier");
const CreateAccount_1 = require("../../api/Account/services/CreateAccount");
const OfferCredex_1 = require("../../api/Credex/services/OfferCredex");
const AcceptCredex_1 = require("../../api/Credex/services/AcceptCredex");
const fetchZigRate_1 = require("./fetchZigRate");
const axios_1 = __importDefault(require("axios"));
const lodash_1 = __importDefault(require("lodash"));
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const logger_1 = __importDefault(require("../../../config/logger"));
/**
 * Initializes the database for the Daily Credcoin Offering (DCO) process.
 * This function sets up necessary constraints, creates initial accounts,
 * and establishes the starting state for the DCO.
 */
async function DBinitialization() {
    console.log("Starting DBinitialization");
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    try {
        await setupDatabaseConstraints(ledgerSpaceSession, searchSpaceSession);
        const dayZero = establishDayZero();
        const dayZeroCXXrates = await fetchAndProcessRates(dayZero);
        await createDayZeroDaynode(ledgerSpaceSession, dayZero, dayZeroCXXrates);
        await createInitialAccounts(ledgerSpaceSession);
    }
    catch (error) {
        logger_1.default.error("Error during DBinitialization", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
/**
 * Sets up necessary database constraints and indexes.
 */
async function setupDatabaseConstraints(ledgerSpaceSession, searchSpaceSession) {
    console.log("Creating database constraints and indexes...");
    // Remove any current db constraints
    await ledgerSpaceSession.run("CALL apoc.schema.assert({}, {})");
    await searchSpaceSession.run("CALL apoc.schema.assert({}, {})");
    // Set new constraints
    const constraints = [
        "CREATE CONSTRAINT daynodeDate_unique IF NOT EXISTS FOR (daynode:Daynode) REQUIRE daynode.Date IS UNIQUE",
        "CREATE CONSTRAINT memberID_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.memberID IS UNIQUE",
        "CREATE CONSTRAINT memberHandle_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.memberHandle IS UNIQUE",
        "CREATE CONSTRAINT memberPhone_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.phone IS UNIQUE",
        "CREATE CONSTRAINT accountID_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountID IS UNIQUE",
        "CREATE CONSTRAINT accountHandle_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountHandle IS UNIQUE",
    ];
    for (const constraint of constraints) {
        await ledgerSpaceSession.run(constraint);
    }
    await searchSpaceSession.run("CREATE CONSTRAINT accountID_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountID IS UNIQUE");
    await searchSpaceSession.run("CREATE CONSTRAINT credexID_unique IF NOT EXISTS FOR (credex:Credex) REQUIRE credex.credexID IS UNIQUE");
}
/**
 * Establishes the day zero date.
 */
function establishDayZero() {
    console.log("Establishing day zero");
    const dayZero = process.env.DEPLOYMENT === "dev"
        ? "2021-01-01"
        : moment_timezone_1.default.utc().subtract(1, "days").format("YYYY-MM-DD");
    console.log("Day zero:", dayZero);
    return dayZero;
}
/**
 * Fetches and processes currency rates for day zero.
 */
async function fetchAndProcessRates(dayZero) {
    console.log("Loading currencies and current rates...");
    const symbols = (0, denominations_1.getDenominations)({
        sourceForRate: "OpenExchangeRates",
        formatAsList: true,
    });
    const baseUrl = `https://openexchangerates.org/api/historical/${dayZero}.json?app_id=${process.env.OPEN_EXCHANGE_RATES_API}&symbols=${symbols}`;
    const { data: { rates: USDbaseRates }, } = await axios_1.default.get(baseUrl);
    USDbaseRates.ZIG = (await (0, fetchZigRate_1.fetchZigRate)())[1].avg;
    const OneCXXinCXXdenom = 1;
    const CXXdenom = "CAD";
    console.log(OneCXXinCXXdenom + " CXX = 1 " + CXXdenom);
    const XAUbaseRates = lodash_1.default.mapValues(USDbaseRates, (value) => value / USDbaseRates.XAU);
    const dayZeroCXXrates = lodash_1.default.mapValues(XAUbaseRates, (value) => (1 / value) * OneCXXinCXXdenom * XAUbaseRates[CXXdenom]);
    dayZeroCXXrates.CXX = 1;
    console.log("Day zero CXX rates:", dayZeroCXXrates);
    return dayZeroCXXrates;
}
/**
 * Creates the day zero daynode in the database.
 */
async function createDayZeroDaynode(session, dayZero, dayZeroCXXrates) {
    console.log("Creating day zero daynode...");
    await session.run(`
    CREATE (daynode:Daynode)
    SET daynode = $dayZeroCXXrates,
        daynode.Date = date($dayZero),
        daynode.Active = TRUE,
        daynode.DCOrunningNow = TRUE
  `, { dayZeroCXXrates, dayZero });
}
/**
 * Creates initial accounts and relationships for the DCO process.
 */
async function createInitialAccounts(session) {
    console.log("Creating initialization accounts and relationships...");
    const rdubs = await createRdubsAccount();
    const credexFoundationID = await createCredexFoundation(rdubs.onboardedMemberID);
    const greatSunID = await createGreatSun(rdubs.onboardedMemberID);
    const vimbisoPayID = await createVimbisoPay(rdubs.onboardedMemberID);
    await createInitialRelationships(session, credexFoundationID, greatSunID, vimbisoPayID);
    await createInitialCredex(rdubs.onboardedMemberID, greatSunID, rdubs.personalAccountID);
}
async function createRdubsAccount() {
    const result = await (0, onboardMember_1.OnboardMemberController)("Ryan", "Watson", "263778177125");
    if ("error" in result) {
        throw new Error(`Failed to create rdubs account: ${result.error}`);
    }
    const onboardedMemberID = result.memberDashboard.memberID;
    const updateTierResult = await (0, updateMemberTier_1.UpdateMemberTierController)(onboardedMemberID, 5);
    if (!updateTierResult.success) {
        throw new Error(`Failed to update member tier: ${updateTierResult.message}`);
    }
    const rdubsPersonalAccount = await (0, CreateAccount_1.CreateAccountService)(onboardedMemberID, "PERSONAL_CONSUMPTION", "Ryan Watson Personal", "263778177125", "USD", 1, "CAD");
    return {
        onboardedMemberID,
        personalAccountID: rdubsPersonalAccount.accountID,
    };
}
async function createCredexFoundation(memberID) {
    const credexFoundation = await (0, CreateAccount_1.CreateAccountService)(memberID, "CREDEX_FOUNDATION", "Credex Foundation", "credexfoundation", "CXX");
    if (typeof credexFoundation.account === "boolean" ||
        !credexFoundation.accountID) {
        throw new Error("Failed to create Credex Foundation account");
    }
    return credexFoundation.accountID;
}
async function createGreatSun(memberID) {
    const greatSun = await (0, CreateAccount_1.CreateAccountService)(memberID, "BUSINESS", "Great Sun Financial", "greatsunfinancial", "CAD");
    if (!greatSun || !greatSun.accountID) {
        throw new Error("Failed to create Great Sun account");
    }
    return greatSun.accountID;
}
async function createVimbisoPay(memberID) {
    const vimbisoPay = await (0, CreateAccount_1.CreateAccountService)(memberID, "BUSINESS", "VimbisoPay", "vimbisopay.audited", "CAD");
    if (!vimbisoPay || !vimbisoPay.accountID) {
        throw new Error("Failed to create VimbisoPay account");
    }
    return vimbisoPay.accountID;
}
async function createInitialRelationships(session, credexFoundationID, greatSunID, vimbisoPayID) {
    await session.run(`
    MATCH (credexFoundation: Account { accountID: $credexFoundationID })
    MATCH (greatSun: Account { accountID: $greatSunID })
    MATCH (vimbisoPay: Account { accountID: $vimbisoPayID })
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (credexFoundation)
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (greatSun)
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (vimbisoPay)
  `, { credexFoundationID, greatSunID, vimbisoPayID });
}
async function createInitialCredex(memberID, issuerAccountID, receiverAccountID) {
    const credexData = {
        memberID,
        issuerAccountID,
        receiverAccountID,
        Denomination: "CAD",
        InitialAmount: 365, // fund DCO for a year with no adjustments
        credexType: "PURCHASE",
        securedCredex: true,
    };
    const DCOinitializationOfferCredex = await (0, OfferCredex_1.OfferCredexService)(credexData);
    if (typeof DCOinitializationOfferCredex.credex === "boolean") {
        throw new Error("Invalid response from OfferCredexService");
    }
    if (DCOinitializationOfferCredex.credex &&
        typeof DCOinitializationOfferCredex.credex.credexID === "string") {
        await (0, AcceptCredex_1.AcceptCredexService)(DCOinitializationOfferCredex.credex.credexID, memberID);
    }
    else {
        throw new Error("Invalid credexID from OfferCredexService");
    }
}
//# sourceMappingURL=DBinitialization.js.map


File: build/src/Core/MTQ/MinuteTransactionQueue.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MinuteTransactionQueue = MinuteTransactionQueue;
const neo4j_1 = require("../../../config/neo4j");
const LoopFinder_1 = require("./LoopFinder");
const lodash_1 = __importDefault(require("lodash"));
const logger_1 = __importDefault(require("../../../config/logger"));
async function MinuteTransactionQueue() {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    logger_1.default.info("MTQ start: checking if DCO or MTQ is in progress");
    try {
        const { DCOflag, MTQflag } = await checkDCOAndMTQStatus(ledgerSpaceSession);
        if (DCOflag === null || MTQflag === null) {
            logger_1.default.warn("No active daynode found. Skipping MTQ.");
            return false;
        }
        if (DCOflag || MTQflag) {
            if (DCOflag)
                logger_1.default.info("DCO in progress, holding MTQ");
            if (MTQflag)
                logger_1.default.info("MTQ already in progress, holding new MTQ");
            return false;
        }
        logger_1.default.info("Running MTQ");
        await setMTQRunningFlag(ledgerSpaceSession, true);
        const BAIL_TIME = 14 * 60 * 1000; // 14 minutes
        const bailTimer = setTimeout(() => {
            logger_1.default.warn("Bail timer reached");
            return true;
        }, BAIL_TIME);
        try {
            await processQueuedAccounts(ledgerSpaceSession, searchSpaceSession);
            await processQueuedCredexes(ledgerSpaceSession, searchSpaceSession);
        }
        finally {
            clearTimeout(bailTimer);
            await setMTQRunningFlag(ledgerSpaceSession, false);
        }
        logger_1.default.info("MTQ processing completed");
        return true;
    }
    catch (error) {
        logger_1.default.error("Error in MinuteTransactionQueue:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
async function checkDCOAndMTQStatus(session) {
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN
      daynode.DCOrunningNow AS DCOflag,
      daynode.MTQrunningNow AS MTQflag
  `);
    if (result.records.length === 0) {
        logger_1.default.warn("No active daynode found");
        return { DCOflag: null, MTQflag: null };
    }
    return {
        DCOflag: result.records[0].get("DCOflag"),
        MTQflag: result.records[0].get("MTQflag"),
    };
}
async function setMTQRunningFlag(session, value) {
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    SET daynode.MTQrunningNow = $value
    RETURN daynode
  `, { value });
    if (result.records.length === 0) {
        logger_1.default.warn("No active daynode found when setting MTQ running flag");
    }
}
async function processQueuedAccounts(ledgerSpaceSession, searchSpaceSession) {
    const queuedAccounts = await getQueuedAccounts(ledgerSpaceSession);
    for (const account of queuedAccounts) {
        try {
            await createAccountInSearchSpace(searchSpaceSession, account);
            await markAccountAsProcessed(ledgerSpaceSession, account.accountID);
            logger_1.default.info(`Account created in searchSpace: ${account.accountName}`);
        }
        catch (error) {
            logger_1.default.error(`Error processing account ${account.accountName}:`, error);
        }
    }
}
async function getQueuedAccounts(session) {
    const result = await session.run(`
    MATCH (newAccount:Account {queueStatus: "PENDING_ACCOUNT"})
    RETURN
      newAccount.accountID AS accountID,
      newAccount.accountName AS accountName
  `);
    return result.records.map((record) => ({
        accountID: record.get("accountID"),
        accountName: record.get("accountName"),
    }));
}
async function createAccountInSearchSpace(session, account) {
    const result = await session.run(`
    CREATE (newAccount:Account)
    SET newAccount = $account
    RETURN newAccount.accountID AS accountID
    `, { account });
    if (result.records.length === 0) {
        throw new Error(`Failed to create account in searchSpace: ${account.accountName}`);
    }
}
async function markAccountAsProcessed(session, accountID) {
    await session.run(`
    MATCH (processedAccount:Account {accountID: $accountID})
    SET processedAccount.queueStatus = "PROCESSED"
    `, { accountID });
}
async function processQueuedCredexes(ledgerSpaceSession, searchSpaceSession) {
    const queuedCredexes = await getQueuedCredexes(ledgerSpaceSession);
    const sortedQueuedCredexes = lodash_1.default.sortBy(queuedCredexes, "acceptedAt");
    for (const credex of sortedQueuedCredexes) {
        try {
            await (0, LoopFinder_1.LoopFinder)(credex.issuerAccountID, credex.credexID, credex.amount, credex.denomination, credex.CXXmultiplier, credex.credexSecuredDenom, credex.dueDate, credex.acceptorAccountID);
        }
        catch (error) {
            logger_1.default.error(`Error processing credex ${credex.credexID}:`, error);
        }
    }
}
async function getQueuedCredexes(session) {
    const result = await session.run(`
    MATCH
      (issuerAccount:Account)
      -[:OWES]->(queuedCredex:Credex {queueStatus: "PENDING_CREDEX"})
      -[:OWES]->(acceptorAccount:Account)
    OPTIONAL MATCH (queuedCredex)<-[:SECURES]-(securer:Account)
    RETURN queuedCredex.acceptedAt AS acceptedAt,
           issuerAccount.accountID AS issuerAccountID,
           acceptorAccount.accountID AS acceptorAccountID,
           securer.accountID AS securerID,
           queuedCredex.credexID AS credexID,
           queuedCredex.InitialAmount AS amount,
           queuedCredex.Denomination AS denomination,
           queuedCredex.CXXmultiplier AS CXXmultiplier,
           queuedCredex.dueDate AS dueDate
  `);
    return result.records.map((record) => ({
        acceptedAt: record.get("acceptedAt"),
        issuerAccountID: record.get("issuerAccountID"),
        acceptorAccountID: record.get("acceptorAccountID"),
        credexID: record.get("credexID"),
        amount: record.get("amount").toNumber(),
        denomination: record.get("denomination"),
        CXXmultiplier: record.get("CXXmultiplier").toNumber(),
        credexSecuredDenom: record.get("securerID") !== null
            ? record.get("denomination")
            : "floating",
        dueDate: record.get("dueDate"),
    }));
}
//# sourceMappingURL=MinuteTransactionQueue.js.map


File: build/src/Core/MTQ/LoopFinder.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoopFinder = LoopFinder;
const neo4j_1 = require("../../../config/neo4j");
const logger_1 = __importDefault(require("../../../config/logger"));
async function LoopFinder(issuerAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexSecuredDenom, credexDueDate, acceptorAccountID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    try {
        const searchOwesType = getSearchOwesType(credexSecuredDenom);
        credexDueDate = await adjustCredexDueDate(ledgerSpaceSession, credexSecuredDenom, credexDueDate);
        await createOrUpdateSearchSpaceCredex(searchSpaceSession, issuerAccountID, acceptorAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexDueDate, searchOwesType);
        let searchForCredloops = true;
        while (searchForCredloops) {
            logger_1.default.info("Searching for credloops...");
            const { valueToClear, credexesInLoop, credexesRedeemed } = await findCredloop(searchSpaceSession, issuerAccountID, searchOwesType);
            if (credexesInLoop.length > 0) {
                await processCredloop(ledgerSpaceSession, searchSpaceSession, valueToClear, credexesInLoop, credexesRedeemed);
            }
            else {
                await markCredexAsProcessed(ledgerSpaceSession, credexID);
                logger_1.default.info("No credloops found. Credex marked as processed.");
                searchForCredloops = false;
            }
        }
        return true;
    }
    catch (error) {
        logger_1.default.error("Error in LoopFinder:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
function getSearchOwesType(credexSecuredDenom) {
    return credexSecuredDenom !== "floating" ? `${credexSecuredDenom}_SECURED` : "FLOATING";
}
async function adjustCredexDueDate(session, credexSecuredDenom, credexDueDate) {
    if (credexSecuredDenom !== "floating") {
        const result = await session.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.Date AS today
    `);
        return result.records[0].get("today");
    }
    return credexDueDate;
}
async function createOrUpdateSearchSpaceCredex(session, issuerAccountID, acceptorAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexDueDate, searchOwesType) {
    const credexExists = await checkCredexExists(session, credexID);
    if (!credexExists) {
        await createSearchSpaceCredex(session, issuerAccountID, acceptorAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexDueDate, searchOwesType);
    }
    else {
        logger_1.default.info(`Credex already exists in SearchSpace: ${credexID}`);
    }
}
async function checkCredexExists(session, credexID) {
    const result = await session.run(`
    OPTIONAL MATCH (credex:Credex {credexID: $credexID})
    RETURN credex IS NOT NULL AS credexExists
    `, { credexID });
    return result.records[0].get("credexExists");
}
async function createSearchSpaceCredex(session, issuerAccountID, acceptorAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexDueDate, searchOwesType) {
    try {
        const result = await session.run(`
      MATCH (issuer:Account {accountID: $issuerAccountID})
      MATCH (acceptor:Account {accountID: $acceptorAccountID})
      MERGE (issuer)-[:${searchOwesType}]->(searchOwesType:${searchOwesType})-[:${searchOwesType}]->(acceptor)
        ON CREATE SET searchOwesType.searchAnchorID = randomUUID()
      CREATE (searchOwesType)<-[:SEARCH_SECURED]-(credex:Credex {
          credexID: $credexID,
          outstandingAmount: $credexAmount,
          Denomination: $Denomination,
          CXXmultiplier: $CXXmultiplier,
          dueDate: date($credexDueDate)
      })
      WITH searchOwesType, credex
      CALL apoc.do.case(
          [
              searchOwesType.earliestDueDate IS NULL
              OR searchOwesType.earliestDueDate > date($credexDueDate), 
              'SET searchOwesType.earliestDueDate = date($credexDueDate) RETURN true'
          ],
          'RETURN false',
          {
            searchOwesType: searchOwesType,
            credexDueDate: credex.dueDate
          }
      ) YIELD value
      RETURN credex.credexID AS credexID
      `, {
            issuerAccountID,
            acceptorAccountID,
            credexID,
            credexAmount,
            Denomination,
            CXXmultiplier,
            credexDueDate,
            searchOwesType,
        });
        if (result.records.length === 0) {
            throw new Error("Unable to create SearchSpace credex");
        }
        logger_1.default.info(`Credex created in SearchSpace: ${result.records[0].get("credexID")}`);
    }
    catch (error) {
        logger_1.default.error("Error creating SearchSpace credex:", error);
        throw error;
    }
}
async function findCredloop(session, issuerAccountID, searchOwesType) {
    const result = await session.run(`
    // Step 1: Find all loops starting and ending at the specified account, with the specified searchOwesType
    MATCH credloops = (issuer:Account {accountID: $issuerAccountID})-[:${searchOwesType}*]->(issuer)
    
    WITH credloops, nodes(credloops) AS loopNodes
    UNWIND loopNodes AS node
    WITH credloops, node
    WITH credloops, MIN(node.earliestDueDate) AS earliestDueDate

    // Step 3: Filter loops to include only those containing a node with the earliest earliestDueDate
    WITH credloops, earliestDueDate, nodes(credloops) AS loopNodes
    UNWIND loopNodes AS node
    WITH credloops, node
    WHERE node.earliestDueDate = earliestDueDate
    WITH credloops, length(credloops) AS loopLength

    // Step 4: Return only the longest loop, breaking ties with rand()
    ORDER BY loopLength DESC, rand()
    LIMIT 1
    WITH nodes(credloops) AS credloopNodes

    // Step 5: Each node returns the credex it is connected to with the earliest dueDate
    // on tie, credex with largest amount
    UNWIND credloopNodes AS loopNode
    MATCH (loopNode)<-[:SEARCH_SECURED]-(credex:Credex)
    WITH loopNode, collect(credex) AS credexList
    WITH 
           reduce(minCredex = credexList[0], c IN credexList | 
                  CASE 
                    WHEN c.dueDate < minCredex.dueDate THEN c
                    WHEN c.dueDate = minCredex.dueDate AND c.outstandingAmount > minCredex.outstandingAmount THEN c
                    ELSE minCredex 
                  END) AS earliestCredex
    WITH collect(earliestCredex) AS finalCredexes, COLLECT(earliestCredex.credexID) AS credexIDs

    // Step 6: Identify the minimum outstandingAmount and subtract it from all credexes
    UNWIND finalCredexes AS credexInLoop
    WITH finalCredexes, min(credexInLoop.outstandingAmount) AS lowestAmount, credexIDs

    UNWIND finalCredexes AS credex
    SET credex.outstandingAmount = credex.outstandingAmount - lowestAmount

    // Step 7: Collect all credexes and filter those with outstandingAmount = 0.
    WITH lowestAmount, COLLECT(credex) AS allCredexes, credexIDs
    WITH lowestAmount, allCredexes, [credex IN allCredexes WHERE credex.outstandingAmount = 0] AS zeroCredexes, credexIDs

    //Step 8: collect credexIDs of the zeroCredexes
    UNWIND zeroCredexes as zeroCredex
    RETURN collect(zeroCredex.credexID) AS zeroCredexIDs, lowestAmount, credexIDs
    `, { issuerAccountID, searchOwesType });
    if (result.records.length > 0) {
        return {
            valueToClear: result.records[0].get("lowestAmount").toNumber(),
            credexesInLoop: result.records[0].get("credexIDs"),
            credexesRedeemed: result.records[0].get("zeroCredexIDs")
        };
    }
    return { valueToClear: 0, credexesInLoop: [], credexesRedeemed: [] };
}
async function processCredloop(ledgerSpaceSession, searchSpaceSession, valueToClear, credexesInLoop, credexesRedeemed) {
    logger_1.default.info("Credexes in loop:", credexesInLoop);
    logger_1.default.info("Credexes redeemed:", credexesRedeemed);
    await cleanupSearchSpace(searchSpaceSession, credexesRedeemed);
    await updateLedgerSpace(ledgerSpaceSession, valueToClear, credexesInLoop, credexesRedeemed);
}
async function cleanupSearchSpace(session, credexesRedeemed) {
    await session.run(`
    // Step 10: Delete zeroCredexes
    UNWIND $credexesRedeemed AS credexRedeemedID
    MATCH (credex:Credex {credexID: credexRedeemedID})-[:SEARCH_SECURED]->(searchAnchor)
    DETACH DELETE credex
    WITH DISTINCT searchAnchor

    // Step 11: Handle orphaned searchAnchors
    OPTIONAL MATCH (searchAnchor)<-[:SEARCH_SECURED]-(otherCredex:Credex)
    WITH searchAnchor, collect(otherCredex) AS otherCredexes
    CALL apoc.do.when(
      size(otherCredexes) = 0,
      'DETACH DELETE searchAnchor RETURN "searchAnchorDeleted" AS result',
      'RETURN "noChanges" AS result',
      {searchAnchor: searchAnchor}
    ) YIELD value AS deleteValue
    WITH deleteValue, searchAnchor, otherCredexes
    WHERE deleteValue <> "searchAnchorDeleted"

    // Step 12: Update earliestDueDate on remaining searchAnchors
    UNWIND otherCredexes AS otherCredex
    WITH DISTINCT searchAnchor, otherCredex
    CALL apoc.do.when(
      (searchAnchor.earliestDueDate IS NULL OR searchAnchor.earliestDueDate > date(otherCredex.dueDate)),
      'SET searchAnchor.earliestDueDate = date(otherCredex.dueDate) RETURN "searchAnchorEarliestUpdated" AS result',
      'RETURN "noChanges" AS result',
      {searchAnchor: searchAnchor, otherCredex: otherCredex}
    ) YIELD value AS updateValue
    RETURN searchAnchor
    `, { credexesRedeemed });
}
async function updateLedgerSpace(session, valueToClear, credexesInLoop, credexesRedeemed) {
    logger_1.default.info(`Credloop of ${valueToClear} CXX found and cleared, now updating ledgerSpace`);
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    CREATE (loopAnchor:LoopAnchor {
        loopedAt: DateTime(),
        loopID: randomUUID(),
        LoopedAmount: $valueToClear,
        CXXmultiplier: 1,
        Denomination: "CXX"
    })-[to_daynode:CREATED_ON]->(daynode)
    WITH loopAnchor

    UNWIND $credexesInLoop AS credexID
    MATCH (thisCredex:Credex {credexID: credexID})
    SET thisCredex.OutstandingAmount = thisCredex.OutstandingAmount - $valueToClear,
        thisCredex.RedeemedAmount = thisCredex.RedeemedAmount + $valueToClear
    WITH thisCredex, loopAnchor
    CREATE (thisCredex)-[:REDEEMED {
        AmountRedeemed: $valueToClear,
        AmountOutstandingNow: thisCredex.OutstandingAmount,
        Denomination: thisCredex.Denomination,
        CXXmultiplier: thisCredex.CXXmultiplier,
        createdAt: DateTime(),
        redeemedRelID: randomUUID()
    }]->(loopAnchor)

    WITH thisCredex, loopAnchor
    MATCH (loopAnchor)<-[:REDEEMED]-(thisCredex)
      -[:OWES]->(:Account)-[:OWES]->(nextCredex:Credex)
      -[:REDEEMED]->(loopAnchor)
    CREATE (thisCredex)-[:CREDLOOP {
        AmountRedeemed: $valueToClear,
        AmountOutstandingNow: thisCredex.OutstandingAmount,
        Denomination: thisCredex.Denomination,
        CXXmultiplier: thisCredex.CXXmultiplier,
        createdAt: DateTime(),
        loopID: loopAnchor.loopID,
        credloopRelID: randomUUID()
    }]->(nextCredex)

    WITH DISTINCT loopAnchor
    UNWIND $credexesRedeemed AS redeemedCredexID
    MATCH
      (owesOutAccount:Account)-[owes1:OWES]->
        (thisRedeemedCredex:Credex {credexID: redeemedCredexID})-[owes2:OWES]->
        (owesInAccount:Account),
      (thisRedeemedCredex)-[:REDEEMED]->(loopAnchor)
    CREATE
      (owesOutAccount)-[:CLEARED]->(thisRedeemedCredex)-[:CLEARED]->(owesInAccount)
    SET thisRedeemedCredex.DateRedeemed = DateTime()
    DELETE owes1, owes2

    RETURN DISTINCT loopAnchor.loopID AS loopID
    `, { valueToClear, credexesInLoop, credexesRedeemed });
    logger_1.default.info(`LoopAnchor created: ${result.records[0].get("loopID")}`);
}
async function markCredexAsProcessed(session, credexID) {
    await session.run(`
    MATCH (processedCredex:Credex {credexID: $credexID})
    SET processedCredex.queueStatus = "PROCESSED"
    RETURN processedCredex.credexID AS credexID
    `, { credexID });
}
// TODO: Implement notification system
/*
async function createNotifications(session: Session, loopID: string): Promise<void> {
  // Implementation for creating notifications
}
*/
//# sourceMappingURL=LoopFinder.js.map


File: build/src/tests/controllers/forceMTQ.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForceMtqController = ForceMtqController;
const MinuteTransactionQueue_1 = require("../../core-cron/MTQ/MinuteTransactionQueue");
async function ForceMtqController(req, res) {
    try {
        const responseData = await (0, MinuteTransactionQueue_1.MinuteTransactionQueue)();
        res.json(responseData);
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=forceMTQ.js.map


File: build/src/tests/controllers/createTestMembersAndAccounts.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTestMembersAndAccountsController = CreateTestMembersAndAccountsController;
const CreateTestMembersAndAccounts_1 = require("../services/CreateTestMembersAndAccounts");
async function CreateTestMembersAndAccountsController(req, res) {
    // Check if numNewAccounts is provided in the request body
    if (!req.body.numNewAccounts) {
        return res.status(400).json({ message: "numNewAccounts is required" });
    }
    try {
        // Call the service to create test accounts
        const responseData = await (0, CreateTestMembersAndAccounts_1.CreateTestMembersAndAccountsService)(req.body.numNewAccounts);
        // Send the response with the created test accounts
        res.status(200).json(responseData);
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error creating test accounts:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=createTestMembersAndAccounts.js.map


File: build/src/tests/controllers/createTestLoop.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTestLoopController = CreateTestLoopController;
const CreateTestLoop_1 = require("../services/CreateTestLoop");
async function CreateTestLoopController(req, res) {
    // Check if numNewTransactions is provided in the request body
    if (!req.body.numNewTransactions) {
        return res.status(400).json({ message: "numNewTransactions is required" });
    }
    try {
        // Call the service to create test transactions
        const responseData = await (0, CreateTestLoop_1.CreateTestLoopService)(req.body.numNewTransactions);
        // Send the response with the created test transactions
        res.status(200).json(responseData);
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error creating test transactions:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=createTestLoop.js.map


File: build/src/tests/controllers/offerAndAcceptCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfferAndAcceptCredexController = OfferAndAcceptCredexController;
async function OfferAndAcceptCredexController(req, res) {
    try {
        /*
        const responseDataOffer = await OfferCredexService(req.body);
        if (typeof responseDataOffer.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (
          responseDataOffer.credex &&
          typeof responseDataOffer.credex.credexID === "string"
        ) {
          const responseDataAccept = await AcceptCredexService(
            responseDataOffer.credex.credexID
          );
          if (responseDataAccept) {
            res.json(responseDataAccept.acceptedCredexID);
          }
        } else {
          res.status(500).json(responseDataOffer.message);
        }
          */
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=offerAndAcceptCredex.js.map


File: build/src/tests/controllers/checkLedgerVsSearchBalances.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckLedgerVsSearchBalancesController = CheckLedgerVsSearchBalancesController;
const CheckLedgerVsSearchBalances_1 = require("../services/CheckLedgerVsSearchBalances");
async function CheckLedgerVsSearchBalancesController(_req, res) {
    try {
        const balanceCheck = await (0, CheckLedgerVsSearchBalances_1.CheckLedgerVsSearchBalances)();
        // Send a success response
        res.status(200).json({ balanceCheck });
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error checking balances:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=checkLedgerVsSearchBalances.js.map


File: build/src/tests/controllers/createRandomFloatingCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateRandomFloatingCredexesController = CreateRandomFloatingCredexesController;
const CreateRandomFloatingCredexes_1 = require("../services/CreateRandomFloatingCredexes");
async function CreateRandomFloatingCredexesController(req, res) {
    // Check if numNewTransactions is provided in the request body
    if (!req.body.numNewTransactions) {
        return res.status(400).json({ message: "numNewTransactions is required" });
    }
    try {
        // Call the service to create test transactions
        const responseData = await (0, CreateRandomFloatingCredexes_1.CreateRandomFloatingCredexesService)(req.body.numNewTransactions);
        // Send the response with the created test transactions
        res.status(200).json(responseData);
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error creating test transactions:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=createRandomFloatingCredexes.js.map


File: build/src/tests/controllers/forceDCO.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForceDcoController = ForceDcoController;
const DailyCredcoinOffering_1 = require("../../core-cron/DCO/DailyCredcoinOffering");
async function ForceDcoController(req, res) {
    try {
        const responseData = await (0, DailyCredcoinOffering_1.DailyCredcoinOffering)();
        res.json(responseData);
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=forceDCO.js.map


File: build/src/tests/controllers/clearDevDb.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClearDevDbController = ClearDevDbController;
const ClearDevDb_1 = require("../services/ClearDevDb");
async function ClearDevDbController(req, res) {
    try {
        // Call the service to clear the development database
        await (0, ClearDevDb_1.ClearDevDbService)();
        // Send a success response
        res
            .status(200)
            .json({ message: "Development databases cleared successfully" });
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error clearing development databases:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=clearDevDb.js.map


File: build/src/tests/controllers/growthTest.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrowthTestController = GrowthTestController;
const GrowthTest_1 = require("../services/GrowthTest");
async function GrowthTestController(req, res) {
    const fieldsRequired = [
        "numberDays",
        "accountGrowthRate",
        "USD_SECURED_fractionToPurchase",
        "USD_SECURED_amountPerPurchaseLow",
        "USD_SECURED_amountPerPurchaseHigh",
        "USD_SECURED_fractionToSell",
        "ZIG_SECURED_fractionToPurchase",
        "ZIG_SECURED_amountPerPurchaseLow",
        "ZIG_SECURED_amountPerPurchaseHigh",
        "ZIG_SECURED_fractionToSell",
        "dailyFloatingRandomTransactionsPerAccount",
    ];
    for (const field of fieldsRequired) {
        if (!req.body[field]) {
            return res
                .status(400)
                .json({ message: `${field} is required` })
                .send();
        }
    }
    try {
        const responseData = await (0, GrowthTest_1.GrowthTestService)(req.body);
        res.status(200).json(responseData);
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error in growthTest:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=growthTest.js.map


File: build/src/tests/testRoutes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TestRoutes;
const __1 = require("..");
const clearDevDb_1 = require("./controllers/clearDevDb");
const forceDCO_1 = require("./controllers/forceDCO");
const forceMTQ_1 = require("./controllers/forceMTQ");
const offerAndAcceptCredex_1 = require("./controllers/offerAndAcceptCredex");
const createTestMembersAndAccounts_1 = require("./controllers/createTestMembersAndAccounts");
const createRandomFloatingCredexes_1 = require("./controllers/createRandomFloatingCredexes");
const createTestLoop_1 = require("./controllers/createTestLoop");
const growthTest_1 = require("./controllers/growthTest");
const checkLedgerVsSearchBalances_1 = require("./controllers/checkLedgerVsSearchBalances");
function TestRoutes(app, jsonParser) {
    app.delete(`${__1.apiVersionOneRoute}clearDevDB`, jsonParser, clearDevDb_1.ClearDevDbController);
    app.post(`${__1.apiVersionOneRoute}forceDCO`, jsonParser, forceDCO_1.ForceDcoController);
    app.post(`${__1.apiVersionOneRoute}forceMTQ`, jsonParser, forceMTQ_1.ForceMtqController);
    app.post(`${__1.apiVersionOneRoute}offerAndAcceptCredex`, jsonParser, offerAndAcceptCredex_1.OfferAndAcceptCredexController);
    app.post(`${__1.apiVersionOneRoute}createTestMembersAndAccounts`, jsonParser, createTestMembersAndAccounts_1.CreateTestMembersAndAccountsController);
    app.post(`${__1.apiVersionOneRoute}createRandomFloatingCredexes`, jsonParser, createRandomFloatingCredexes_1.CreateRandomFloatingCredexesController);
    app.post(`${__1.apiVersionOneRoute}createTestLoop`, jsonParser, createTestLoop_1.CreateTestLoopController);
    app.post(`${__1.apiVersionOneRoute}growthTest`, jsonParser, growthTest_1.GrowthTestController);
    app.get(`${__1.apiVersionOneRoute}checkLedgerVsSearchBalances`, jsonParser, checkLedgerVsSearchBalances_1.CheckLedgerVsSearchBalancesController);
}
//# sourceMappingURL=testRoutes.js.map


File: build/src/tests/services/GrowthTest.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrowthTestService = GrowthTestService;
const CreateTestMembersAndAccounts_1 = require("./CreateTestMembersAndAccounts");
const CreateRandomFloatingCredexes_1 = require("./CreateRandomFloatingCredexes");
const DailyCredcoinOffering_1 = require("../../core-cron/DCO/DailyCredcoinOffering");
const MinuteTransactionQueue_1 = require("../../core-cron/MTQ/MinuteTransactionQueue");
const neo4j_1 = require("../../../config/neo4j");
const PurchaseSecuredCredexes_1 = require("./PurchaseSecuredCredexes");
const SellSecuredCredexes_1 = require("./SellSecuredCredexes");
const InEcosystemSecuredCredexes_1 = require("./InEcosystemSecuredCredexes");
async function GrowthTestService(variables) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        // Get current number of accounts
        const numberAccountsQuery = await ledgerSpaceSession.run(`
      MATCH (account:Account)
      RETURN count(account) AS numberAccounts
    `);
        let numberAccounts = parseFloat(numberAccountsQuery.records[0].get("numberAccounts"));
        for (let index = 0; index < variables.numberDays; index++) {
            let numberNewAccounts = Math.round(numberAccounts * variables.accountGrowthRate);
            if (numberNewAccounts < 1) {
                numberNewAccounts = 1;
            }
            console.log(`Day ${index + 1}`);
            console.log(`Current number of accounts: ${numberAccounts}`);
            console.log(`Creating new accounts: ${numberNewAccounts}`);
            numberAccounts += numberNewAccounts;
            await (0, CreateTestMembersAndAccounts_1.CreateTestMembersAndAccountsService)(numberNewAccounts);
            const numberUSDpurchases = Math.round(numberAccounts * variables.USD_SECURED_fractionToPurchase);
            await (0, PurchaseSecuredCredexes_1.PurchaseSecuredCredexesService)("USD", numberUSDpurchases, variables.USD_SECURED_amountPerPurchaseLow, variables.USD_SECURED_amountPerPurchaseHigh);
            const numberUSDsecuredCirculate = Math.round(numberAccounts * variables.USD_SECURED_fractionToCirculate);
            await (0, InEcosystemSecuredCredexes_1.InEcosystemSecuredCredexesService)("USD", numberUSDsecuredCirculate);
            const numberUSDsales = Math.round(numberAccounts * variables.USD_SECURED_fractionToSell);
            await (0, SellSecuredCredexes_1.SellSecuredCredexesService)("USD", numberUSDsales);
            const numberZIGpurchases = Math.round(numberAccounts * variables.ZIG_SECURED_fractionToPurchase);
            await (0, PurchaseSecuredCredexes_1.PurchaseSecuredCredexesService)("ZIG", numberZIGpurchases, variables.ZIG_SECURED_amountPerPurchaseLow, variables.ZIG_SECURED_amountPerPurchaseHigh);
            const numberZIGsecuredCirculate = Math.round(numberAccounts * variables.ZIG_SECURED_fractionToCirculate);
            await (0, InEcosystemSecuredCredexes_1.InEcosystemSecuredCredexesService)("ZIG", numberZIGsecuredCirculate);
            const numberZIGsales = Math.round(numberAccounts * variables.ZIG_SECURED_fractionToSell);
            await (0, SellSecuredCredexes_1.SellSecuredCredexesService)("ZIG", numberZIGsales);
            const numberRandomFloatingTransactions = Math.round(numberAccounts * variables.dailyFloatingRandomTransactionsPerAccount);
            console.log(`Creating random floating credexes: ${numberRandomFloatingTransactions}`);
            if (numberRandomFloatingTransactions > 0) {
                await (0, CreateRandomFloatingCredexes_1.CreateRandomFloatingCredexesService)(numberRandomFloatingTransactions);
            }
            await (0, DailyCredcoinOffering_1.DailyCredcoinOffering)();
            await (0, MinuteTransactionQueue_1.MinuteTransactionQueue)();
        }
        console.log("This run of GrowthTestService is complete");
    }
    catch (error) {
        console.error("An error occurred during the GrowthTestService execution:", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GrowthTest.js.map


File: build/src/tests/services/CreateTestMembersAndAccounts.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTestMembersAndAccountsService = CreateTestMembersAndAccountsService;
const axios_1 = __importDefault(require("axios"));
const neo4j_1 = require("../../../config/neo4j");
const OnboardMember_1 = require("../../api/Member/services/OnboardMember");
const CreateAccount_1 = require("../../api/Account/services/CreateAccount");
const lodash_1 = require("lodash");
async function CreateTestMembersAndAccountsService(numNewAccounts) {
    const batchSize = 3; // Size of each batch
    const numNewMembers = Math.round(numNewAccounts * 0.75);
    const numNewAccountsForExisting = numNewAccounts - numNewMembers;
    const memberPromises = [];
    for (let i = 0; i < numNewMembers; i++) {
        memberPromises.push((async () => {
            // Fetch a new name for each iteration
            // comment out when daily limit reached        
            const nameObject = await axios_1.default.get("https://api.parser.name/?api_key=f30409d63186d13cfa335a40e14dcd17&endpoint=generate");
            const firstname = nameObject.data.data[0].name.firstname.name_ascii;
            const lastname = nameObject.data.data[0].name.lastname.name_ascii;
            /*
            // comment out when name coming from query above
            const randomNum1 = random(100, 999);
            const randomNum2 = random(100, 999);
            const firstname = "first" + randomNum1;
            const lastname = "last" + randomNum2;
            */
            const phone = "263" + Math.floor(100000000 + Math.random() * 900000000);
            // need to check if phone unique here and generate new if not
            const onboardedMember = await (0, OnboardMember_1.OnboardMemberService)(firstname, lastname, phone);
            if (!onboardedMember.onboardedMemberID) {
                throw new Error("member could not be onboarded");
            }
            const consumptionAccount = await (0, CreateAccount_1.CreateAccountService)(onboardedMember.onboardedMemberID, "PERSONAL_CONSUMPTION", `${firstname} ${lastname} Personal`, `${firstname}_${lastname}`, "USD");
            if (!consumptionAccount.accountID) {
                console.log(consumptionAccount.message);
                throw new Error("new consumption account could not be created");
            }
            return {
                onboardedMemberID: onboardedMember.onboardedMemberID,
                consumptionAccountID: consumptionAccount.accountID,
            };
        })());
        // Process in batches of `batchSize`
        if ((i + 1) % batchSize === 0 || i === numNewMembers - 1) {
            await Promise.all(memberPromises);
            memberPromises.length = 0; // Clear the array for the next batch
        }
    }
    const accountPromises = [];
    for (let i = 0; i < numNewAccountsForExisting; i++) {
        accountPromises.push((async () => {
            var ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
            const getRandomMemberQuery = await ledgerSpaceSession.run(`
          MATCH (members:Member)
          WITH members.memberID AS memberID, rand() AS rand
          ORDER BY rand LIMIT 1
          RETURN memberID
        `);
            await ledgerSpaceSession.close();
            const ownerID = getRandomMemberQuery.records[0].get("memberID");
            const businessName = "biz" + (0, lodash_1.random)(100000, 999999);
            const newAccount = await (0, CreateAccount_1.CreateAccountService)(ownerID, "BUSINESS", businessName, businessName, "USD");
            if (!newAccount.accountID) {
                console.log(newAccount.message);
                throw new Error("new account could not be created");
            }
        })());
        // Process in batches of `batchSize`
        if ((i + 1) % batchSize === 0 || i === numNewAccountsForExisting - 1) {
            await Promise.all(accountPromises);
            accountPromises.length = 0; // Clear the array for the next batch
        }
    }
    return true;
}
//# sourceMappingURL=CreateTestMembersAndAccounts.js.map


File: build/src/tests/services/InEcosystemSecuredCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InEcosystemSecuredCredexesService = InEcosystemSecuredCredexesService;
async function InEcosystemSecuredCredexesService(denom, number) {
    /*
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    console.log(`Creating in-ecosystem ${denom} secured credexes: ${number}`);
  
    try {
      if (number > 0) {
        const result = await ledgerSpaceSession.run(
          `
          MATCH
            (issuer:Account)<-[transactionType:OWES]-
            (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
          OPTIONAL MATCH
            (issuer)-[transactionType:OWES]->
            (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
          WITH
            issuer,
            sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
          WHERE netIn > 0
          WITH
            issuer.accountID AS issuerAccountID
          ORDER BY rand()
          LIMIT $number
          WITH collect(issuerAccountID) AS issuerAccountIDs
          UNWIND issuerAccountIDs AS issuerAccountID
          MATCH (randomCounterparty:Account)
          WHERE randomCounterparty.accountID <> issuerAccountID
          WITH issuerAccountID, randomCounterparty.accountID AS receiverAccountID
          ORDER BY rand()
          RETURN issuerAccountID, receiverAccountID
          LIMIT $number
          `,
          {
            number: neo4j.int(number),
            denom,
          }
        );
  
        if (result.records.length === 0) {
          console.log("No records found for circulation.");
          return;
        }
  
        const batchSize = 3;
        const records = result.records;
  
        for (let i = 0; i < records.length; i += batchSize) {
          const batch = records.slice(i, i + batchSize);
  
          const offerPromises = batch.map(async (record) => {
            const issuerAccountID: string = record.get("issuerAccountID");
            const receiverAccountID: string = record.get("receiverAccountID");
  
            try {
              const securableData = await GetSecuredAuthorizationService(
                issuerAccountID,
                denom
              );
  
              const maxSecurable = securableData.securableAmountInDenom;
              let InitialAmount;
              if (maxSecurable >= 1) {
                InitialAmount = random(maxSecurable);
              } else {
                InitialAmount = random(0.1, maxSecurable);
              }
              console.log("random initialAmount: " + InitialAmount);
  
              const credexSpecs = {
                issuerAccountID: issuerAccountID,
                receiverAccountID: receiverAccountID,
                Denomination: denom,
                InitialAmount: InitialAmount,
                credexType: "PURCHASE",
                securedCredex: true,
              };
  
              const newcredex = await OfferCredexService(credexSpecs);
  
              if (
                typeof newcredex.credex === "boolean" ||
                !newcredex.credex?.credexID
              ) {
                throw new Error("Invalid response from OfferCredexService");
              }
  
              await AcceptCredexService(newcredex.credex.credexID);
            } catch (error) {
              console.error("Error processing credex offer:", error);
              // Handle error as needed
            }
          });
  
          await Promise.all(offerPromises);
        }
      }
    } catch (error) {
      console.error("Error in InEcosystemSecuredCredexesService:", error);
    } finally {
      await ledgerSpaceSession.close();
    }
  */
}
//# sourceMappingURL=InEcosystemSecuredCredexes.js.map


File: build/src/tests/services/SellSecuredCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SellSecuredCredexesService = SellSecuredCredexesService;
async function SellSecuredCredexesService(denom, number) {
    /*
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    console.log(`Selling ${denom} secured credexes for cash: ${number}`);
  
    try {
      if (number > 0) {
        const result = await ledgerSpaceSession.run(
          `
          MATCH
            (issuer:Account)<-[transactionType:OWES]-
            (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
          OPTIONAL MATCH
            (issuer)-[transactionType:OWES]->
            (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
          WITH
            issuer, securer,
            sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
          WHERE netIn > 0
          RETURN
            issuer.accountID AS issuerAccountID,
            securer.accountID AS receiverAccountID
            ORDER BY rand() LIMIT $number;
          `,
          {
            number: neo4j.int(number),
            denom,
          }
        );
  
        if (result.records.length === 0) {
          console.log("No records found for selling secured credexes.");
          return;
        }
  
        const batchSize = 3;
        const records = result.records;
  
        for (let i = 0; i < records.length; i += batchSize) {
          const batch = records.slice(i, i + batchSize);
  
          const offerPromises = batch.map(async (record) => {
            const issuerAccountID: string = record.get("issuerAccountID");
            const receiverAccountID: string = record.get("receiverAccountID");
  
            try {
              const securableData = await GetSecuredAuthorizationService(
                issuerAccountID,
                denom
              );
  
              const InitialAmount = random(
                1,
                securableData.securableAmountInDenom || 1
              );
  
              const credexSpecs = {
                issuerAccountID: issuerAccountID,
                receiverAccountID: receiverAccountID,
                Denomination: denom,
                InitialAmount: InitialAmount,
                credexType: "PURCHASE",
                securedCredex: true,
              };
  
              const newcredex = await OfferCredexService(credexSpecs);
  
              if (
                typeof newcredex.credex === "boolean" ||
                !newcredex.credex?.credexID
              ) {
                throw new Error("Invalid response from OfferCredexService");
              }
  
              await AcceptCredexService(newcredex.credex.credexID);
            } catch (error) {
              console.error("Error processing credex offer:", error);
              // Handle error as needed
            }
          });
  
          await Promise.all(offerPromises);
        }
      }
    } catch (error) {
      console.error("Error in SellSecuredCredexesService:", error);
    } finally {
      await ledgerSpaceSession.close();
    }
    */
}
//# sourceMappingURL=SellSecuredCredexes.js.map


File: build/src/tests/services/ClearDevDb.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClearDevDbService = ClearDevDbService;
const neo4j_1 = require("../../../config/neo4j");
async function ClearDevDbService() {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    await ledgerSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
    await searchSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
    //check success first
    console.log("LedgerSpace and SearchSpace DBs cleared");
    return true;
}
//# sourceMappingURL=ClearDevDb.js.map


File: build/src/tests/services/CreateTestLoop.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTestLoopService = CreateTestLoopService;
async function CreateTestLoopService(numNewTransactions) {
    /*
    var ledgerSpaceSession = ledgerSpaceDriver.session();
    const getRandomCounterpartiesQuery = await ledgerSpaceSession.run(
      `
        MATCH (account:Account)
        WITH account, rand() AS rand1
        ORDER BY rand1
        RETURN account.accountID AS accountID LIMIT $numNewTransactions
      `,
      {
        numNewTransactions: neo4j.int(numNewTransactions),
      }
    );
  
    const getDaynodeDate = await ledgerSpaceSession.run(`
        MATCH (daynode:Daynode {Active: true})
        RETURN daynode.Date AS today
    `);
    const today = getDaynodeDate.records[0].get("today");
  
    let credexesCreated = [];
    // Iterate numNewTransactions times
    for (let i = 0; i < numNewTransactions; i++) {
      const issuerAccountID =
        getRandomCounterpartiesQuery.records[i].get("accountID");
  
      let receiverAccountID;
      if (getRandomCounterpartiesQuery.records[i + 1]) {
        receiverAccountID =
          getRandomCounterpartiesQuery.records[i + 1].get("accountID");
      } else {
        receiverAccountID =
          getRandomCounterpartiesQuery.records[0].get("accountID");
      }
  
      const credexSpecs = {
        issuerAccountID: issuerAccountID,
        receiverAccountID: receiverAccountID,
        Denomination: "USD",
        InitialAmount: random(1, 100),
        credexType: "PURCHASE",
        //securedCredex: true,
        dueDate: moment(today)
          .utc()
          .add(8, "days")
          .subtract(1, "month")
          .format("YYYY-MM-DD"),
      };
  
      console.log(
        "Amount: " + credexSpecs.InitialAmount + " " + credexSpecs.Denomination
      );
      const newcredex = await OfferCredexService(credexSpecs);
      if (typeof newcredex.credex == "boolean") {
        throw new Error("Invalid response from OfferCredexService");
      }
      if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
        const credexCreatedData = await AcceptCredexService(
          newcredex.credex.credexID
        );
        credexesCreated.push(credexCreatedData);
      } else {
        return newcredex.message;
      }
    }
    console.log(numNewTransactions + " new transactions created");
    return credexesCreated;
    */
}
//# sourceMappingURL=CreateTestLoop.js.map


File: build/src/tests/services/CheckLedgerVsSearchBalances.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckLedgerVsSearchBalances = CheckLedgerVsSearchBalances;
const neo4j_1 = require("../../../config/neo4j");
async function CheckLedgerVsSearchBalances() {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    try {
        // Query ledgerSpace for credex data
        const ledgerSpaceCredexesQuery = await ledgerSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDledger,
        credex.OutstandingAmount AS OutstandingAmountLedger
    `);
        // Query searchSpace for credex data
        const searchSpaceCredexesQuery = await searchSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDsearch,
        credex.outstandingAmount AS OutstandingAmountSearch
    `);
        // Process ledgerSpace results
        const ledgerSpaceCredexes = ledgerSpaceCredexesQuery.records.map((record) => ({
            credexID: record.get("credexIDledger"),
            OutstandingAmount: record.get("OutstandingAmountLedger"),
        }));
        // Process searchSpace results
        const searchSpaceCredexes = searchSpaceCredexesQuery.records.map((record) => ({
            credexID: record.get("credexIDsearch"),
            OutstandingAmount: record.get("OutstandingAmountSearch"),
        }));
        // Create a map for quick lookup from searchSpace
        const searchSpaceCredexMap = new Map(searchSpaceCredexes.map((credex) => [
            credex.credexID,
            credex.OutstandingAmount,
        ]));
        // Compare and analyze the data
        let matchingCount = 0;
        const mismatchedCredexes = [];
        for (const ledgerCredex of ledgerSpaceCredexes) {
            const searchOutstandingAmount = searchSpaceCredexMap.get(ledgerCredex.credexID);
            // If the credex does not exist in searchSpace and the amount in ledgerSpace is 0, count as a match
            if (searchOutstandingAmount === undefined &&
                ledgerCredex.OutstandingAmount === 0) {
                matchingCount++;
            }
            else if (ledgerCredex.OutstandingAmount === searchOutstandingAmount) {
                matchingCount++;
            }
            else {
                mismatchedCredexes.push({
                    credexID: ledgerCredex.credexID,
                    OutstandingAmountLedger: ledgerCredex.OutstandingAmount,
                    OutstandingAmountSearch: searchOutstandingAmount || 0,
                });
            }
        }
        // Return the results
        return {
            matchingCount,
            mismatchedCredexes,
        };
    }
    catch (error) {
        console.error("An error occurred during the execution:", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
//# sourceMappingURL=CheckLedgerVsSearchBalances.js.map


File: build/src/tests/services/PurchaseSecuredCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PurchaseSecuredCredexesService = PurchaseSecuredCredexesService;
async function PurchaseSecuredCredexesService(denom, number, lowValue, highValue) {
    /*
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    console.log(`Purchasing ${denom} secured credexes: ${number}`);
  
    if (number > 0) {
      const getSecuredUSDCounterparties = await ledgerSpaceSession.run(
        `
          // Step 1: Select a random audited account
          MATCH (auditedAccount:Account)<-[:CREDEX_FOUNDATION_AUDITED]-(foundation:Account)
          WITH auditedAccount, rand() AS rand
          ORDER BY rand LIMIT 1
  
          // Step 2: Collect account IDs for purchasers
          MATCH (accounts:Account)
          WHERE accounts.accountID <> auditedAccount.accountID
          WITH auditedAccount, collect(accounts.accountID) AS allaccounts
          RETURN auditedAccount.accountID AS auditedID, allaccounts[0..$number] AS accountsToPurchaseUSDsecured
        `,
        {
          number: neo4j.int(number),
        }
      );
  
      const issuerAccountID =
        getSecuredUSDCounterparties.records[0].get("auditedID");
      const accountsToPurchaseUSDsecured =
        getSecuredUSDCounterparties.records[0].get(
          "accountsToPurchaseUSDsecured"
        );
  
      const batchSize = 3;
  
      for (let i = 0; i < accountsToPurchaseUSDsecured.length; i += batchSize) {
        const batch = accountsToPurchaseUSDsecured.slice(i, i + batchSize);
  
        const offerPromises = batch.map((receiverAccountID: string) => {
          const InitialAmount = random(lowValue, highValue);
  
          const credexSpecs = {
            issuerAccountID: issuerAccountID,
            receiverAccountID: receiverAccountID,
            Denomination: denom,
            InitialAmount: InitialAmount,
            credexType: "PURCHASE",
            securedCredex: true,
          };
  
          return OfferCredexService(credexSpecs);
        });
  
        const offerCredexArray = await Promise.all(offerPromises);
  
        const acceptPromises = offerCredexArray.map((newcredex) => {
          if (typeof newcredex.credex == "boolean") {
            throw new Error("Invalid response from OfferCredexService");
          }
          if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
            return AcceptCredexService(newcredex.credex.credexID);
          } else {
            return Promise.reject(newcredex.message);
          }
        });
  
        await Promise.all(acceptPromises);
      }
    }
  
    await ledgerSpaceSession.close();
    */
}
//# sourceMappingURL=PurchaseSecuredCredexes.js.map


File: build/src/tests/services/CreateRandomFloatingCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateRandomFloatingCredexesService = CreateRandomFloatingCredexesService;
const neo4j_1 = require("../../../config/neo4j");
async function getDateAndRandCounterparties() {
    var ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const getDateAndRandomCounterpartiesQuery = await ledgerSpaceSession.run(`
    MATCH (accounts1:Account)
    WITH accounts1, rand() AS rand1
    ORDER BY rand1
    WITH accounts1.accountID AS accountID_1 LIMIT 1
    MATCH (accounts2:Account)
    WHERE accounts2.accountID <> accountID_1
    WITH accountID_1, accounts2, rand() AS rand2
    ORDER BY rand2
    WITH accountID_1, accounts2.accountID AS accountID_2 LIMIT 1
    MATCH (daynode:Daynode{Active:true})
    RETURN daynode.Date AS date, accountID_1, accountID_2
  `);
    await ledgerSpaceSession.close();
    return {
        accountID_1: getDateAndRandomCounterpartiesQuery.records[0].get("accountID_1"),
        accountID_2: getDateAndRandomCounterpartiesQuery.records[0].get("accountID_2"),
        date: getDateAndRandomCounterpartiesQuery.records[0].get("date"),
    };
}
async function CreateRandomFloatingCredexesService(numNewTransactions) {
    /*
    const credexesCreated = [];
    const batchSize = 3;
    const transactionPromises = [];
  
    for (let i = 0; i < numNewTransactions; i++) {
      transactionPromises.push(
        (async () => {
          const dateAndCounterparties = await getDateAndRandCounterparties();
          const date = dateAndCounterparties.date;
          const issuerAccountID = dateAndCounterparties.accountID_1;
          const receiverAccountID = dateAndCounterparties.accountID_2;
          const InitialAmount = random(1, 100);
          const Denomination = InitialAmount < 80 ? "USD" : "ZIG";
  
          // floating credex due in 8-34 days
          const credspanDays = random(8, 34);
          const dueDate = moment(date)
            .subtract(1, "months")
            .add(credspanDays, "days")
            .format("YYYY-MM-DD");
  
          const credexSpecs = {
            issuerAccountID: issuerAccountID,
            receiverAccountID: receiverAccountID,
            Denomination: Denomination,
            InitialAmount: InitialAmount,
            credexType: "PURCHASE",
            dueDate: dueDate,
            securedCredex: false,
          };
  
          const newcredex = await OfferCredexService(credexSpecs);
          if (typeof newcredex.credex == "boolean") {
            throw new Error("Invalid response from OfferCredexService");
          }
          if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
            const credexCreatedData = await AcceptCredexService(
              newcredex.credex.credexID
            );
            return credexCreatedData;
          } else {
            return newcredex.message;
          }
        })()
      );
  
      // Process in batches of `batchSize`
      if ((i + 1) % batchSize === 0 || i === numNewTransactions - 1) {
        const batchResults = await Promise.all(transactionPromises);
        credexesCreated.push(
          ...batchResults.filter((result) => result !== undefined)
        );
        transactionPromises.length = 0; // Clear the array for the next batch
      }
    }
  
    console.log(`${numNewTransactions} new floating transactions created`);
    return credexesCreated;
    */
}
//# sourceMappingURL=CreateRandomFloatingCredexes.js.map


File: build/src/tests/testDenomFormatter.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const denomUtils_1 = require("../utils/denomUtils");
console.log('Testing denomFormatter function:');
console.log('USD test:', (0, denomUtils_1.denomFormatter)(1234.56, 'USD') === '1,234.56' ? 'PASS' : 'FAIL');
console.log('CXX test:', (0, denomUtils_1.denomFormatter)(1234.567, 'CXX') === '1,234.567' ? 'PASS' : 'FAIL');
console.log('XAU test:', (0, denomUtils_1.denomFormatter)(1234.5678, 'XAU') === '1,234.5678' ? 'PASS' : 'FAIL');
console.log('Negative number test:', (0, denomUtils_1.denomFormatter)(-1234.56, 'USD') === '-1,234.56' ? 'PASS' : 'FAIL');
console.log('Zero test:', (0, denomUtils_1.denomFormatter)(0, 'USD') === '0.00' ? 'PASS' : 'FAIL');
console.log('\nActual outputs:');
console.log('USD:', (0, denomUtils_1.denomFormatter)(1234.56, 'USD'));
console.log('CXX:', (0, denomUtils_1.denomFormatter)(1234.567, 'CXX'));
console.log('XAU:', (0, denomUtils_1.denomFormatter)(1234.5678, 'XAU'));
console.log('Negative:', (0, denomUtils_1.denomFormatter)(-1234.56, 'USD'));
console.log('Zero:', (0, denomUtils_1.denomFormatter)(0, 'USD'));
//# sourceMappingURL=testDenomFormatter.js.map


File: build/src/tests/denomUtils.test.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const denomUtils_1 = require("../utils/denomUtils");
describe('denomFormatter', () => {
    test('formats USD correctly', () => {
        expect((0, denomUtils_1.denomFormatter)(1234.56, 'USD')).toBe('1,234.56');
    });
    test('formats CXX correctly', () => {
        expect((0, denomUtils_1.denomFormatter)(1234.567, 'CXX')).toBe('1,234.567');
    });
    test('formats XAU correctly', () => {
        expect((0, denomUtils_1.denomFormatter)(1234.5678, 'XAU')).toBe('1,234.5678');
    });
    test('handles negative numbers', () => {
        expect((0, denomUtils_1.denomFormatter)(-1234.56, 'USD')).toBe('-1,234.56');
    });
    test('handles zero', () => {
        expect((0, denomUtils_1.denomFormatter)(0, 'USD')).toBe('0.00');
    });
});
//# sourceMappingURL=denomUtils.test.js.map


File: build/src/tests/integration/account.test.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const supertest_1 = __importDefault(require("supertest"));
const index_1 = require("../../index"); // Adjust this import based on your app structure
const neo4j_1 = require("../../../config/neo4j");
describe('Account API Integration Tests', () => {
    beforeAll(async () => {
        // Set up any necessary test data
    });
    afterAll(async () => {
        // Clean up test data and close connections
        await neo4j_1.ledgerSpaceDriver.close();
    });
    describe('POST /api/v1/createAccount', () => {
        it('should create a new account with valid input', async () => {
            const response = await (0, supertest_1.default)(index_1.app)
                .post('/api/v1/createAccount')
                .send({
                ownerID: '123e4567-e89b-12d3-a456-426614174000',
                accountType: 'PERSONAL_CONSUMPTION',
                accountName: 'Test Account',
                accountHandle: 'test_account',
                defaultDenom: 'USD'
            });
            expect(response.status).toBe(201);
            expect(response.body).toHaveProperty('accountID');
        });
        it('should return 400 with invalid input', async () => {
            const response = await (0, supertest_1.default)(index_1.app)
                .post('/api/v1/createAccount')
                .send({
                ownerID: 'invalid-uuid',
                accountType: 'INVALID_TYPE',
                accountName: 'T', // Too short
                accountHandle: 'invalid handle',
                defaultDenom: 'INVALID_DENOM'
            });
            expect(response.status).toBe(400);
            expect(response.body).toHaveProperty('message');
        });
    });
    describe('PATCH /api/v1/updateAccount', () => {
        it('should update an account with valid input', async () => {
            const response = await (0, supertest_1.default)(index_1.app)
                .patch('/api/v1/updateAccount')
                .send({
                ownerID: '123e4567-e89b-12d3-a456-426614174000',
                accountID: '123e4567-e89b-12d3-a456-426614174001',
                accountName: 'Updated Account Name',
                accountHandle: 'updated_handle'
            });
            expect(response.status).toBe(200);
            expect(response.body).toHaveProperty('message', 'Account updated successfully');
        });
        it('should return 400 with invalid input', async () => {
            const response = await (0, supertest_1.default)(index_1.app)
                .patch('/api/v1/updateAccount')
                .send({
                ownerID: 'invalid-uuid',
                accountID: 'invalid-uuid',
                accountName: 'A', // Too short
                accountHandle: 'invalid handle'
            });
            expect(response.status).toBe(400);
            expect(response.body).toHaveProperty('message');
        });
    });
    // Add more test cases for other account-related endpoints
});
//# sourceMappingURL=account.test.js.map


File: build/src/DevAdmin/controllers/forceMTQ.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForceMtqController = ForceMtqController;
const MinuteTransactionQueue_1 = require("../../Core/MTQ/MinuteTransactionQueue");
async function ForceMtqController(req, res) {
    try {
        const responseData = await (0, MinuteTransactionQueue_1.MinuteTransactionQueue)();
        res.json(responseData);
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=forceMTQ.js.map


File: build/src/DevAdmin/controllers/createTestMembersAndAccounts.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTestMembersAndAccountsController = CreateTestMembersAndAccountsController;
const CreateTestMembersAndAccounts_1 = require("../services/CreateTestMembersAndAccounts");
async function CreateTestMembersAndAccountsController(req, res) {
    // Check if numNewAccounts is provided in the request body
    if (!req.body.numNewAccounts) {
        return res.status(400).json({ message: "numNewAccounts is required" });
    }
    try {
        // Call the service to create test accounts
        const responseData = await (0, CreateTestMembersAndAccounts_1.CreateTestMembersAndAccountsService)(req.body.numNewAccounts);
        // Send the response with the created test accounts
        res.status(200).json(responseData);
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error creating test accounts:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=createTestMembersAndAccounts.js.map


File: build/src/DevAdmin/controllers/createTestLoop.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTestLoopController = CreateTestLoopController;
const CreateTestLoop_1 = require("../services/CreateTestLoop");
async function CreateTestLoopController(req, res) {
    // Check if numNewTransactions is provided in the request body
    if (!req.body.numNewTransactions) {
        return res.status(400).json({ message: "numNewTransactions is required" });
    }
    try {
        // Call the service to create test transactions
        const responseData = await (0, CreateTestLoop_1.CreateTestLoopService)(req.body.numNewTransactions);
        // Send the response with the created test transactions
        res.status(200).json(responseData);
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error creating test transactions:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=createTestLoop.js.map


File: build/src/DevAdmin/controllers/offerAndAcceptCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfferAndAcceptCredexController = OfferAndAcceptCredexController;
async function OfferAndAcceptCredexController(req, res) {
    try {
        /*
        const responseDataOffer = await OfferCredexService(req.body);
        if (typeof responseDataOffer.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (
          responseDataOffer.credex &&
          typeof responseDataOffer.credex.credexID === "string"
        ) {
          const responseDataAccept = await AcceptCredexService(
            responseDataOffer.credex.credexID
          );
          if (responseDataAccept) {
            res.json(responseDataAccept.acceptedCredexID);
          }
        } else {
          res.status(500).json(responseDataOffer.message);
        }
          */
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=offerAndAcceptCredex.js.map


File: build/src/DevAdmin/controllers/checkLedgerVsSearchBalances.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckLedgerVsSearchBalancesController = CheckLedgerVsSearchBalancesController;
const CheckLedgerVsSearchBalances_1 = require("../services/CheckLedgerVsSearchBalances");
async function CheckLedgerVsSearchBalancesController(_req, res) {
    try {
        const balanceCheck = await (0, CheckLedgerVsSearchBalances_1.CheckLedgerVsSearchBalances)();
        // Send a success response
        res.status(200).json({ balanceCheck });
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error checking balances:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=checkLedgerVsSearchBalances.js.map


File: build/src/DevAdmin/controllers/createRandomFloatingCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateRandomFloatingCredexesController = CreateRandomFloatingCredexesController;
const CreateRandomFloatingCredexes_1 = require("../services/CreateRandomFloatingCredexes");
async function CreateRandomFloatingCredexesController(req, res) {
    // Check if numNewTransactions is provided in the request body
    if (!req.body.numNewTransactions) {
        return res.status(400).json({ message: "numNewTransactions is required" });
    }
    try {
        // Call the service to create test transactions
        const responseData = await (0, CreateRandomFloatingCredexes_1.CreateRandomFloatingCredexesService)(req.body.numNewTransactions);
        // Send the response with the created test transactions
        res.status(200).json(responseData);
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error creating test transactions:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=createRandomFloatingCredexes.js.map


File: build/src/DevAdmin/controllers/forceDCO.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForceDcoController = ForceDcoController;
const DailyCredcoinOffering_1 = require("../../Core/DCO/DailyCredcoinOffering");
async function ForceDcoController(req, res) {
    try {
        const responseData = await (0, DailyCredcoinOffering_1.DailyCredcoinOffering)();
        res.json(responseData);
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=forceDCO.js.map


File: build/src/DevAdmin/controllers/clearDevDb.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClearDevDbController = ClearDevDbController;
const ClearDevDb_1 = require("../services/ClearDevDb");
async function ClearDevDbController(req, res) {
    try {
        // Call the service to clear the development database
        await (0, ClearDevDb_1.ClearDevDbService)();
        // Send a success response
        res
            .status(200)
            .json({ message: "Development databases cleared successfully" });
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error clearing development databases:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=clearDevDb.js.map


File: build/src/DevAdmin/controllers/growthTest.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrowthTestController = GrowthTestController;
const GrowthTest_1 = require("../services/GrowthTest");
async function GrowthTestController(req, res) {
    const fieldsRequired = [
        "numberDays",
        "accountGrowthRate",
        "USD_SECURED_fractionToPurchase",
        "USD_SECURED_amountPerPurchaseLow",
        "USD_SECURED_amountPerPurchaseHigh",
        "USD_SECURED_fractionToSell",
        "ZIG_SECURED_fractionToPurchase",
        "ZIG_SECURED_amountPerPurchaseLow",
        "ZIG_SECURED_amountPerPurchaseHigh",
        "ZIG_SECURED_fractionToSell",
        "dailyFloatingRandomTransactionsPerAccount",
    ];
    for (const field of fieldsRequired) {
        if (!req.body[field]) {
            return res
                .status(400)
                .json({ message: `${field} is required` })
                .send();
        }
    }
    try {
        const responseData = await (0, GrowthTest_1.GrowthTestService)(req.body);
        res.status(200).json(responseData);
    }
    catch (err) {
        // Handle errors and send an appropriate error response
        console.error("Error in growthTest:", err);
        res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=growthTest.js.map


File: build/src/DevAdmin/devAdminRoutes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DevAdminRoutes;
const __1 = require("..");
const clearDevDb_1 = require("./controllers/clearDevDb");
const forceDCO_1 = require("./controllers/forceDCO");
const forceMTQ_1 = require("./controllers/forceMTQ");
const offerAndAcceptCredex_1 = require("./controllers/offerAndAcceptCredex");
const createTestMembersAndAccounts_1 = require("./controllers/createTestMembersAndAccounts");
const createRandomFloatingCredexes_1 = require("./controllers/createRandomFloatingCredexes");
const createTestLoop_1 = require("./controllers/createTestLoop");
const growthTest_1 = require("./controllers/growthTest");
const checkLedgerVsSearchBalances_1 = require("./controllers/checkLedgerVsSearchBalances");
function DevAdminRoutes(app, jsonParser) {
    app.delete(`${__1.apiVersionOneRoute}clearDevDB`, jsonParser, clearDevDb_1.ClearDevDbController);
    app.post(`${__1.apiVersionOneRoute}forceDCO`, jsonParser, forceDCO_1.ForceDcoController);
    app.post(`${__1.apiVersionOneRoute}forceMTQ`, jsonParser, forceMTQ_1.ForceMtqController);
    app.post(`${__1.apiVersionOneRoute}offerAndAcceptCredex`, jsonParser, offerAndAcceptCredex_1.OfferAndAcceptCredexController);
    app.post(`${__1.apiVersionOneRoute}createTestMembersAndAccounts`, jsonParser, createTestMembersAndAccounts_1.CreateTestMembersAndAccountsController);
    app.post(`${__1.apiVersionOneRoute}createRandomFloatingCredexes`, jsonParser, createRandomFloatingCredexes_1.CreateRandomFloatingCredexesController);
    app.post(`${__1.apiVersionOneRoute}createTestLoop`, jsonParser, createTestLoop_1.CreateTestLoopController);
    app.post(`${__1.apiVersionOneRoute}growthTest`, jsonParser, growthTest_1.GrowthTestController);
    app.get(`${__1.apiVersionOneRoute}checkLedgerVsSearchBalances`, jsonParser, checkLedgerVsSearchBalances_1.CheckLedgerVsSearchBalancesController);
}
//# sourceMappingURL=devAdminRoutes.js.map


File: build/src/DevAdmin/services/GrowthTest.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrowthTestService = GrowthTestService;
const CreateTestMembersAndAccounts_1 = require("./CreateTestMembersAndAccounts");
const CreateRandomFloatingCredexes_1 = require("./CreateRandomFloatingCredexes");
const DailyCredcoinOffering_1 = require("../../Core/DCO/DailyCredcoinOffering");
const MinuteTransactionQueue_1 = require("../../Core/MTQ/MinuteTransactionQueue");
const neo4j_1 = require("../../../config/neo4j");
const PurchaseSecuredCredexes_1 = require("./PurchaseSecuredCredexes");
const SellSecuredCredexes_1 = require("./SellSecuredCredexes");
const InEcosystemSecuredCredexes_1 = require("./InEcosystemSecuredCredexes");
async function GrowthTestService(variables) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        // Get current number of accounts
        const numberAccountsQuery = await ledgerSpaceSession.run(`
      MATCH (account:Account)
      RETURN count(account) AS numberAccounts
    `);
        let numberAccounts = parseFloat(numberAccountsQuery.records[0].get("numberAccounts"));
        for (let index = 0; index < variables.numberDays; index++) {
            let numberNewAccounts = Math.round(numberAccounts * variables.accountGrowthRate);
            if (numberNewAccounts < 1) {
                numberNewAccounts = 1;
            }
            console.log(`Day ${index + 1}`);
            console.log(`Current number of accounts: ${numberAccounts}`);
            console.log(`Creating new accounts: ${numberNewAccounts}`);
            numberAccounts += numberNewAccounts;
            await (0, CreateTestMembersAndAccounts_1.CreateTestMembersAndAccountsService)(numberNewAccounts);
            const numberUSDpurchases = Math.round(numberAccounts * variables.USD_SECURED_fractionToPurchase);
            await (0, PurchaseSecuredCredexes_1.PurchaseSecuredCredexesService)("USD", numberUSDpurchases, variables.USD_SECURED_amountPerPurchaseLow, variables.USD_SECURED_amountPerPurchaseHigh);
            const numberUSDsecuredCirculate = Math.round(numberAccounts * variables.USD_SECURED_fractionToCirculate);
            await (0, InEcosystemSecuredCredexes_1.InEcosystemSecuredCredexesService)("USD", numberUSDsecuredCirculate);
            const numberUSDsales = Math.round(numberAccounts * variables.USD_SECURED_fractionToSell);
            await (0, SellSecuredCredexes_1.SellSecuredCredexesService)("USD", numberUSDsales);
            const numberZIGpurchases = Math.round(numberAccounts * variables.ZIG_SECURED_fractionToPurchase);
            await (0, PurchaseSecuredCredexes_1.PurchaseSecuredCredexesService)("ZIG", numberZIGpurchases, variables.ZIG_SECURED_amountPerPurchaseLow, variables.ZIG_SECURED_amountPerPurchaseHigh);
            const numberZIGsecuredCirculate = Math.round(numberAccounts * variables.ZIG_SECURED_fractionToCirculate);
            await (0, InEcosystemSecuredCredexes_1.InEcosystemSecuredCredexesService)("ZIG", numberZIGsecuredCirculate);
            const numberZIGsales = Math.round(numberAccounts * variables.ZIG_SECURED_fractionToSell);
            await (0, SellSecuredCredexes_1.SellSecuredCredexesService)("ZIG", numberZIGsales);
            const numberRandomFloatingTransactions = Math.round(numberAccounts * variables.dailyFloatingRandomTransactionsPerAccount);
            console.log(`Creating random floating credexes: ${numberRandomFloatingTransactions}`);
            if (numberRandomFloatingTransactions > 0) {
                await (0, CreateRandomFloatingCredexes_1.CreateRandomFloatingCredexesService)(numberRandomFloatingTransactions);
            }
            await (0, DailyCredcoinOffering_1.DailyCredcoinOffering)();
            await (0, MinuteTransactionQueue_1.MinuteTransactionQueue)();
        }
        console.log("This run of GrowthTestService is complete");
    }
    catch (error) {
        console.error("An error occurred during the GrowthTestService execution:", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GrowthTest.js.map


File: build/src/DevAdmin/services/CreateTestMembersAndAccounts.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTestMembersAndAccountsService = CreateTestMembersAndAccountsService;
const axios_1 = __importDefault(require("axios"));
const neo4j_1 = require("../../../config/neo4j");
const OnboardMember_1 = require("../../api/Member/services/OnboardMember");
const CreateAccount_1 = require("../../api/Account/services/CreateAccount");
const lodash_1 = require("lodash");
async function CreateTestMembersAndAccountsService(numNewAccounts) {
    const batchSize = 3; // Size of each batch
    const numNewMembers = Math.round(numNewAccounts * 0.75);
    const numNewAccountsForExisting = numNewAccounts - numNewMembers;
    const memberPromises = [];
    for (let i = 0; i < numNewMembers; i++) {
        memberPromises.push((async () => {
            // Fetch a new name for each iteration
            // comment out when daily limit reached        
            const nameObject = await axios_1.default.get("https://api.parser.name/?api_key=f30409d63186d13cfa335a40e14dcd17&endpoint=generate");
            const firstname = nameObject.data.data[0].name.firstname.name_ascii;
            const lastname = nameObject.data.data[0].name.lastname.name_ascii;
            /*
            // comment out when name coming from query above
            const randomNum1 = random(100, 999);
            const randomNum2 = random(100, 999);
            const firstname = "first" + randomNum1;
            const lastname = "last" + randomNum2;
            */
            const phone = "263" + Math.floor(100000000 + Math.random() * 900000000);
            // need to check if phone unique here and generate new if not
            const onboardedMember = await (0, OnboardMember_1.OnboardMemberService)(firstname, lastname, phone);
            if (!onboardedMember.onboardedMemberID) {
                throw new Error("member could not be onboarded");
            }
            const consumptionAccount = await (0, CreateAccount_1.CreateAccountService)(onboardedMember.onboardedMemberID, "PERSONAL_CONSUMPTION", `${firstname} ${lastname} Personal`, `${firstname}_${lastname}`, "USD");
            if (!consumptionAccount.accountID) {
                console.log(consumptionAccount.message);
                throw new Error("new consumption account could not be created");
            }
            return {
                onboardedMemberID: onboardedMember.onboardedMemberID,
                consumptionAccountID: consumptionAccount.accountID,
            };
        })());
        // Process in batches of `batchSize`
        if ((i + 1) % batchSize === 0 || i === numNewMembers - 1) {
            await Promise.all(memberPromises);
            memberPromises.length = 0; // Clear the array for the next batch
        }
    }
    const accountPromises = [];
    for (let i = 0; i < numNewAccountsForExisting; i++) {
        accountPromises.push((async () => {
            var ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
            const getRandomMemberQuery = await ledgerSpaceSession.run(`
          MATCH (members:Member)
          WITH members.memberID AS memberID, rand() AS rand
          ORDER BY rand LIMIT 1
          RETURN memberID
        `);
            await ledgerSpaceSession.close();
            const ownerID = getRandomMemberQuery.records[0].get("memberID");
            const businessName = "biz" + (0, lodash_1.random)(100000, 999999);
            const newAccount = await (0, CreateAccount_1.CreateAccountService)(ownerID, "BUSINESS", businessName, businessName, "USD");
            if (!newAccount.accountID) {
                console.log(newAccount.message);
                throw new Error("new account could not be created");
            }
        })());
        // Process in batches of `batchSize`
        if ((i + 1) % batchSize === 0 || i === numNewAccountsForExisting - 1) {
            await Promise.all(accountPromises);
            accountPromises.length = 0; // Clear the array for the next batch
        }
    }
    return true;
}
//# sourceMappingURL=CreateTestMembersAndAccounts.js.map


File: build/src/DevAdmin/services/InEcosystemSecuredCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InEcosystemSecuredCredexesService = InEcosystemSecuredCredexesService;
async function InEcosystemSecuredCredexesService(denom, number) {
    /*
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    console.log(`Creating in-ecosystem ${denom} secured credexes: ${number}`);
  
    try {
      if (number > 0) {
        const result = await ledgerSpaceSession.run(
          `
          MATCH
            (issuer:Account)<-[transactionType:OWES]-
            (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
          OPTIONAL MATCH
            (issuer)-[transactionType:OWES]->
            (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
          WITH
            issuer,
            sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
          WHERE netIn > 0
          WITH
            issuer.accountID AS issuerAccountID
          ORDER BY rand()
          LIMIT $number
          WITH collect(issuerAccountID) AS issuerAccountIDs
          UNWIND issuerAccountIDs AS issuerAccountID
          MATCH (randomCounterparty:Account)
          WHERE randomCounterparty.accountID <> issuerAccountID
          WITH issuerAccountID, randomCounterparty.accountID AS receiverAccountID
          ORDER BY rand()
          RETURN issuerAccountID, receiverAccountID
          LIMIT $number
          `,
          {
            number: neo4j.int(number),
            denom,
          }
        );
  
        if (result.records.length === 0) {
          console.log("No records found for circulation.");
          return;
        }
  
        const batchSize = 3;
        const records = result.records;
  
        for (let i = 0; i < records.length; i += batchSize) {
          const batch = records.slice(i, i + batchSize);
  
          const offerPromises = batch.map(async (record) => {
            const issuerAccountID: string = record.get("issuerAccountID");
            const receiverAccountID: string = record.get("receiverAccountID");
  
            try {
              const securableData = await GetSecuredAuthorizationService(
                issuerAccountID,
                denom
              );
  
              const maxSecurable = securableData.securableAmountInDenom;
              let InitialAmount;
              if (maxSecurable >= 1) {
                InitialAmount = random(maxSecurable);
              } else {
                InitialAmount = random(0.1, maxSecurable);
              }
              console.log("random initialAmount: " + InitialAmount);
  
              const credexSpecs = {
                issuerAccountID: issuerAccountID,
                receiverAccountID: receiverAccountID,
                Denomination: denom,
                InitialAmount: InitialAmount,
                credexType: "PURCHASE",
                securedCredex: true,
              };
  
              const newcredex = await OfferCredexService(credexSpecs);
  
              if (
                typeof newcredex.credex === "boolean" ||
                !newcredex.credex?.credexID
              ) {
                throw new Error("Invalid response from OfferCredexService");
              }
  
              await AcceptCredexService(newcredex.credex.credexID);
            } catch (error) {
              console.error("Error processing credex offer:", error);
              // Handle error as needed
            }
          });
  
          await Promise.all(offerPromises);
        }
      }
    } catch (error) {
      console.error("Error in InEcosystemSecuredCredexesService:", error);
    } finally {
      await ledgerSpaceSession.close();
    }
  */
}
//# sourceMappingURL=InEcosystemSecuredCredexes.js.map


File: build/src/DevAdmin/services/SellSecuredCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SellSecuredCredexesService = SellSecuredCredexesService;
async function SellSecuredCredexesService(denom, number) {
    /*
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    console.log(`Selling ${denom} secured credexes for cash: ${number}`);
  
    try {
      if (number > 0) {
        const result = await ledgerSpaceSession.run(
          `
          MATCH
            (issuer:Account)<-[transactionType:OWES]-
            (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
          OPTIONAL MATCH
            (issuer)-[transactionType:OWES]->
            (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
          WITH
            issuer, securer,
            sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
          WHERE netIn > 0
          RETURN
            issuer.accountID AS issuerAccountID,
            securer.accountID AS receiverAccountID
            ORDER BY rand() LIMIT $number;
          `,
          {
            number: neo4j.int(number),
            denom,
          }
        );
  
        if (result.records.length === 0) {
          console.log("No records found for selling secured credexes.");
          return;
        }
  
        const batchSize = 3;
        const records = result.records;
  
        for (let i = 0; i < records.length; i += batchSize) {
          const batch = records.slice(i, i + batchSize);
  
          const offerPromises = batch.map(async (record) => {
            const issuerAccountID: string = record.get("issuerAccountID");
            const receiverAccountID: string = record.get("receiverAccountID");
  
            try {
              const securableData = await GetSecuredAuthorizationService(
                issuerAccountID,
                denom
              );
  
              const InitialAmount = random(
                1,
                securableData.securableAmountInDenom || 1
              );
  
              const credexSpecs = {
                issuerAccountID: issuerAccountID,
                receiverAccountID: receiverAccountID,
                Denomination: denom,
                InitialAmount: InitialAmount,
                credexType: "PURCHASE",
                securedCredex: true,
              };
  
              const newcredex = await OfferCredexService(credexSpecs);
  
              if (
                typeof newcredex.credex === "boolean" ||
                !newcredex.credex?.credexID
              ) {
                throw new Error("Invalid response from OfferCredexService");
              }
  
              await AcceptCredexService(newcredex.credex.credexID);
            } catch (error) {
              console.error("Error processing credex offer:", error);
              // Handle error as needed
            }
          });
  
          await Promise.all(offerPromises);
        }
      }
    } catch (error) {
      console.error("Error in SellSecuredCredexesService:", error);
    } finally {
      await ledgerSpaceSession.close();
    }
    */
}
//# sourceMappingURL=SellSecuredCredexes.js.map


File: build/src/DevAdmin/services/ClearDevDb.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClearDevDbService = ClearDevDbService;
const neo4j_1 = require("../../../config/neo4j");
async function ClearDevDbService() {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    await ledgerSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
    await searchSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
    //check success first
    console.log("LedgerSpace and SearchSpace DBs cleared");
    return true;
}
//# sourceMappingURL=ClearDevDb.js.map


File: build/src/DevAdmin/services/CreateTestLoop.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTestLoopService = CreateTestLoopService;
async function CreateTestLoopService(numNewTransactions) {
    /*
    var ledgerSpaceSession = ledgerSpaceDriver.session();
    const getRandomCounterpartiesQuery = await ledgerSpaceSession.run(
      `
        MATCH (account:Account)
        WITH account, rand() AS rand1
        ORDER BY rand1
        RETURN account.accountID AS accountID LIMIT $numNewTransactions
      `,
      {
        numNewTransactions: neo4j.int(numNewTransactions),
      }
    );
  
    const getDaynodeDate = await ledgerSpaceSession.run(`
        MATCH (daynode:Daynode {Active: true})
        RETURN daynode.Date AS today
    `);
    const today = getDaynodeDate.records[0].get("today");
  
    let credexesCreated = [];
    // Iterate numNewTransactions times
    for (let i = 0; i < numNewTransactions; i++) {
      const issuerAccountID =
        getRandomCounterpartiesQuery.records[i].get("accountID");
  
      let receiverAccountID;
      if (getRandomCounterpartiesQuery.records[i + 1]) {
        receiverAccountID =
          getRandomCounterpartiesQuery.records[i + 1].get("accountID");
      } else {
        receiverAccountID =
          getRandomCounterpartiesQuery.records[0].get("accountID");
      }
  
      const credexSpecs = {
        issuerAccountID: issuerAccountID,
        receiverAccountID: receiverAccountID,
        Denomination: "USD",
        InitialAmount: random(1, 100),
        credexType: "PURCHASE",
        //securedCredex: true,
        dueDate: moment(today)
          .utc()
          .add(8, "days")
          .subtract(1, "month")
          .format("YYYY-MM-DD"),
      };
  
      console.log(
        "Amount: " + credexSpecs.InitialAmount + " " + credexSpecs.Denomination
      );
      const newcredex = await OfferCredexService(credexSpecs);
      if (typeof newcredex.credex == "boolean") {
        throw new Error("Invalid response from OfferCredexService");
      }
      if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
        const credexCreatedData = await AcceptCredexService(
          newcredex.credex.credexID
        );
        credexesCreated.push(credexCreatedData);
      } else {
        return newcredex.message;
      }
    }
    console.log(numNewTransactions + " new transactions created");
    return credexesCreated;
    */
}
//# sourceMappingURL=CreateTestLoop.js.map


File: build/src/DevAdmin/services/CheckLedgerVsSearchBalances.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckLedgerVsSearchBalances = CheckLedgerVsSearchBalances;
const neo4j_1 = require("../../../config/neo4j");
async function CheckLedgerVsSearchBalances() {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    try {
        // Query ledgerSpace for credex data
        const ledgerSpaceCredexesQuery = await ledgerSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDledger,
        credex.OutstandingAmount AS OutstandingAmountLedger
    `);
        // Query searchSpace for credex data
        const searchSpaceCredexesQuery = await searchSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDsearch,
        credex.outstandingAmount AS OutstandingAmountSearch
    `);
        // Process ledgerSpace results
        const ledgerSpaceCredexes = ledgerSpaceCredexesQuery.records.map((record) => ({
            credexID: record.get("credexIDledger"),
            OutstandingAmount: record.get("OutstandingAmountLedger"),
        }));
        // Process searchSpace results
        const searchSpaceCredexes = searchSpaceCredexesQuery.records.map((record) => ({
            credexID: record.get("credexIDsearch"),
            OutstandingAmount: record.get("OutstandingAmountSearch"),
        }));
        // Create a map for quick lookup from searchSpace
        const searchSpaceCredexMap = new Map(searchSpaceCredexes.map((credex) => [
            credex.credexID,
            credex.OutstandingAmount,
        ]));
        // Compare and analyze the data
        let matchingCount = 0;
        const mismatchedCredexes = [];
        for (const ledgerCredex of ledgerSpaceCredexes) {
            const searchOutstandingAmount = searchSpaceCredexMap.get(ledgerCredex.credexID);
            // If the credex does not exist in searchSpace and the amount in ledgerSpace is 0, count as a match
            if (searchOutstandingAmount === undefined &&
                ledgerCredex.OutstandingAmount === 0) {
                matchingCount++;
            }
            else if (ledgerCredex.OutstandingAmount === searchOutstandingAmount) {
                matchingCount++;
            }
            else {
                mismatchedCredexes.push({
                    credexID: ledgerCredex.credexID,
                    OutstandingAmountLedger: ledgerCredex.OutstandingAmount,
                    OutstandingAmountSearch: searchOutstandingAmount || 0,
                });
            }
        }
        // Return the results
        return {
            matchingCount,
            mismatchedCredexes,
        };
    }
    catch (error) {
        console.error("An error occurred during the execution:", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
//# sourceMappingURL=CheckLedgerVsSearchBalances.js.map


File: build/src/DevAdmin/services/PurchaseSecuredCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PurchaseSecuredCredexesService = PurchaseSecuredCredexesService;
async function PurchaseSecuredCredexesService(denom, number, lowValue, highValue) {
    /*
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    console.log(`Purchasing ${denom} secured credexes: ${number}`);
  
    if (number > 0) {
      const getSecuredUSDCounterparties = await ledgerSpaceSession.run(
        `
          // Step 1: Select a random audited account
          MATCH (auditedAccount:Account)<-[:CREDEX_FOUNDATION_AUDITED]-(foundation:Account)
          WITH auditedAccount, rand() AS rand
          ORDER BY rand LIMIT 1
  
          // Step 2: Collect account IDs for purchasers
          MATCH (accounts:Account)
          WHERE accounts.accountID <> auditedAccount.accountID
          WITH auditedAccount, collect(accounts.accountID) AS allaccounts
          RETURN auditedAccount.accountID AS auditedID, allaccounts[0..$number] AS accountsToPurchaseUSDsecured
        `,
        {
          number: neo4j.int(number),
        }
      );
  
      const issuerAccountID =
        getSecuredUSDCounterparties.records[0].get("auditedID");
      const accountsToPurchaseUSDsecured =
        getSecuredUSDCounterparties.records[0].get(
          "accountsToPurchaseUSDsecured"
        );
  
      const batchSize = 3;
  
      for (let i = 0; i < accountsToPurchaseUSDsecured.length; i += batchSize) {
        const batch = accountsToPurchaseUSDsecured.slice(i, i + batchSize);
  
        const offerPromises = batch.map((receiverAccountID: string) => {
          const InitialAmount = random(lowValue, highValue);
  
          const credexSpecs = {
            issuerAccountID: issuerAccountID,
            receiverAccountID: receiverAccountID,
            Denomination: denom,
            InitialAmount: InitialAmount,
            credexType: "PURCHASE",
            securedCredex: true,
          };
  
          return OfferCredexService(credexSpecs);
        });
  
        const offerCredexArray = await Promise.all(offerPromises);
  
        const acceptPromises = offerCredexArray.map((newcredex) => {
          if (typeof newcredex.credex == "boolean") {
            throw new Error("Invalid response from OfferCredexService");
          }
          if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
            return AcceptCredexService(newcredex.credex.credexID);
          } else {
            return Promise.reject(newcredex.message);
          }
        });
  
        await Promise.all(acceptPromises);
      }
    }
  
    await ledgerSpaceSession.close();
    */
}
//# sourceMappingURL=PurchaseSecuredCredexes.js.map


File: build/src/DevAdmin/services/CreateRandomFloatingCredexes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateRandomFloatingCredexesService = CreateRandomFloatingCredexesService;
const neo4j_1 = require("../../../config/neo4j");
async function getDateAndRandCounterparties() {
    var ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const getDateAndRandomCounterpartiesQuery = await ledgerSpaceSession.run(`
    MATCH (accounts1:Account)
    WITH accounts1, rand() AS rand1
    ORDER BY rand1
    WITH accounts1.accountID AS accountID_1 LIMIT 1
    MATCH (accounts2:Account)
    WHERE accounts2.accountID <> accountID_1
    WITH accountID_1, accounts2, rand() AS rand2
    ORDER BY rand2
    WITH accountID_1, accounts2.accountID AS accountID_2 LIMIT 1
    MATCH (daynode:Daynode{Active:true})
    RETURN daynode.Date AS date, accountID_1, accountID_2
  `);
    await ledgerSpaceSession.close();
    return {
        accountID_1: getDateAndRandomCounterpartiesQuery.records[0].get("accountID_1"),
        accountID_2: getDateAndRandomCounterpartiesQuery.records[0].get("accountID_2"),
        date: getDateAndRandomCounterpartiesQuery.records[0].get("date"),
    };
}
async function CreateRandomFloatingCredexesService(numNewTransactions) {
    /*
    const credexesCreated = [];
    const batchSize = 3;
    const transactionPromises = [];
  
    for (let i = 0; i < numNewTransactions; i++) {
      transactionPromises.push(
        (async () => {
          const dateAndCounterparties = await getDateAndRandCounterparties();
          const date = dateAndCounterparties.date;
          const issuerAccountID = dateAndCounterparties.accountID_1;
          const receiverAccountID = dateAndCounterparties.accountID_2;
          const InitialAmount = random(1, 100);
          const Denomination = InitialAmount < 80 ? "USD" : "ZIG";
  
          // floating credex due in 8-34 days
          const credspanDays = random(8, 34);
          const dueDate = moment(date)
            .subtract(1, "months")
            .add(credspanDays, "days")
            .format("YYYY-MM-DD");
  
          const credexSpecs = {
            issuerAccountID: issuerAccountID,
            receiverAccountID: receiverAccountID,
            Denomination: Denomination,
            InitialAmount: InitialAmount,
            credexType: "PURCHASE",
            dueDate: dueDate,
            securedCredex: false,
          };
  
          const newcredex = await OfferCredexService(credexSpecs);
          if (typeof newcredex.credex == "boolean") {
            throw new Error("Invalid response from OfferCredexService");
          }
          if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
            const credexCreatedData = await AcceptCredexService(
              newcredex.credex.credexID
            );
            return credexCreatedData;
          } else {
            return newcredex.message;
          }
        })()
      );
  
      // Process in batches of `batchSize`
      if ((i + 1) % batchSize === 0 || i === numNewTransactions - 1) {
        const batchResults = await Promise.all(transactionPromises);
        credexesCreated.push(
          ...batchResults.filter((result) => result !== undefined)
        );
        transactionPromises.length = 0; // Clear the array for the next batch
      }
    }
  
    console.log(`${numNewTransactions} new floating transactions created`);
    return credexesCreated;
    */
}
//# sourceMappingURL=CreateRandomFloatingCredexes.js.map


File: build/src/api/Account/controllers/unauthorizeForAccount.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnauthorizeForAccountController = UnauthorizeForAccountController;
const UnauthorizeForAccount_1 = require("../services/UnauthorizeForAccount");
const logger_1 = __importDefault(require("../../../../config/logger"));
/**
 * Controller for unauthorizing a member for an account
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
async function UnauthorizeForAccountController(req, res, next) {
    const requiredFields = ["memberIDtoBeUnauthorized", "accountID", "ownerID"];
    try {
        for (const field of requiredFields) {
            if (!req.body[field]) {
                res.status(400).json({ message: `${field} is required` });
                return;
            }
        }
        const { memberIDtoBeUnauthorized, accountID, ownerID } = req.body;
        // Validate memberIDtoBeUnauthorized
        if (typeof memberIDtoBeUnauthorized !== 'string' || !/^[a-f0-9-]{36}$/.test(memberIDtoBeUnauthorized)) {
            res.status(400).json({ message: "Invalid memberIDtoBeUnauthorized. Must be a valid UUID." });
            return;
        }
        // Validate accountID
        if (typeof accountID !== 'string' || !/^[a-f0-9-]{36}$/.test(accountID)) {
            res.status(400).json({ message: "Invalid accountID. Must be a valid UUID." });
            return;
        }
        // Validate ownerID
        if (typeof ownerID !== 'string' || !/^[a-f0-9-]{36}$/.test(ownerID)) {
            res.status(400).json({ message: "Invalid ownerID. Must be a valid UUID." });
            return;
        }
        logger_1.default.info("Unauthorizing member for account", { memberIDtoBeUnauthorized, accountID, ownerID });
        const responseData = await (0, UnauthorizeForAccount_1.UnauthorizeForCompanyService)(memberIDtoBeUnauthorized, accountID, ownerID);
        if (!responseData) {
            logger_1.default.warn("Failed to unauthorize member for account", { memberIDtoBeUnauthorized, accountID, ownerID });
            res.status(400).json({ message: "Failed to unauthorize member for the account" });
            return;
        }
        logger_1.default.info("Member unauthorized for account successfully", { memberIDtoBeUnauthorized, accountID, ownerID });
        res.status(200).json(responseData);
    }
    catch (error) {
        logger_1.default.error("Error in UnauthorizeForAccountController", { error, memberIDtoBeUnauthorized: req.body.memberIDtoBeUnauthorized, accountID: req.body.accountID, ownerID: req.body.ownerID });
        next(error);
    }
}
//# sourceMappingURL=unauthorizeForAccount.js.map


File: build/src/api/Account/controllers/authorizeForAccount.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizeForAccountController = AuthorizeForAccountController;
const AuthorizeForAccount_1 = require("../services/AuthorizeForAccount");
const logger_1 = __importDefault(require("../../../../config/logger"));
const validators_1 = require("../../../utils/validators");
async function AuthorizeForAccountController(req, res, next) {
    const { memberHandleToBeAuthorized, accountID, ownerID } = req.body;
    try {
        // Validate input
        if (!(0, validators_1.validateMemberHandle)(memberHandleToBeAuthorized)) {
            return res.status(400).json({ message: "Invalid memberHandleToBeAuthorized" });
        }
        if (!(0, validators_1.validateUUID)(accountID)) {
            return res.status(400).json({ message: "Invalid accountID" });
        }
        if (!(0, validators_1.validateUUID)(ownerID)) {
            return res.status(400).json({ message: "Invalid ownerID" });
        }
        logger_1.default.info("Authorizing member for account", { memberHandleToBeAuthorized, accountID, ownerID });
        const responseData = await (0, AuthorizeForAccount_1.AuthorizeForAccountService)(memberHandleToBeAuthorized, accountID, ownerID);
        if (!responseData) {
            logger_1.default.warn("Failed to authorize member for account", { memberHandleToBeAuthorized, accountID, ownerID });
            res.status(400).json({ message: "Failed to authorize member for account" });
            return;
        }
        if (responseData.message === "accounts not found") {
            logger_1.default.warn("Accounts not found during authorization", { memberHandleToBeAuthorized, accountID, ownerID });
            res.status(404).json({ message: "Accounts not found" });
            return;
        }
        if (responseData.message === "Limit of 5 authorized accounts reached. Remove an authorized account if you want to add another.") {
            logger_1.default.warn("Authorization limit reached", { memberHandleToBeAuthorized, accountID, ownerID });
            res.status(400).json({ message: responseData.message });
            return;
        }
        if (responseData.message === "You can only authorize someone to transact on behalf of your account when you are on the Entrepreneur tier or above.") {
            logger_1.default.warn("Insufficient tier for authorization", { memberHandleToBeAuthorized, accountID, ownerID });
            res.status(403).json({ message: responseData.message });
            return;
        }
        logger_1.default.info("Member authorized for account successfully", { memberHandleToBeAuthorized, accountID, ownerID });
        res.status(200).json(responseData);
    }
    catch (error) {
        logger_1.default.error("Error in AuthorizeForAccountController", { error, memberHandleToBeAuthorized: req.body.memberHandleToBeAuthorized, accountID: req.body.accountID, ownerID: req.body.ownerID });
        next(error);
    }
}
//# sourceMappingURL=authorizeForAccount.js.map


File: build/src/api/Account/controllers/updateSendOffersTo.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateSendOffersToController = UpdateSendOffersToController;
const UpdateSendOffersTo_1 = require("../services/UpdateSendOffersTo");
const logger_1 = __importDefault(require("../../../../config/logger"));
const validators_1 = require("../../../utils/validators");
async function UpdateSendOffersToController(req, res, next) {
    const { memberIDtoSendOffers, accountID, ownerID } = req.body;
    try {
        // Validate input
        if (!(0, validators_1.validateUUID)(memberIDtoSendOffers)) {
            return res.status(400).json({ message: "Invalid memberIDtoSendOffers" });
        }
        if (!(0, validators_1.validateUUID)(accountID)) {
            return res.status(400).json({ message: "Invalid accountID" });
        }
        if (!(0, validators_1.validateUUID)(ownerID)) {
            return res.status(400).json({ message: "Invalid ownerID" });
        }
        logger_1.default.info("Updating offer recipient for account", { memberIDtoSendOffers, accountID, ownerID });
        const responseData = await (0, UpdateSendOffersTo_1.UpdateSendOffersToService)(memberIDtoSendOffers, accountID, ownerID);
        if (!responseData) {
            logger_1.default.warn("Failed to update offer recipient for account", { memberIDtoSendOffers, accountID, ownerID });
            res.status(400).json({ message: "Failed to update offer recipient for account" });
            return;
        }
        logger_1.default.info("Offer recipient updated successfully for account", { memberIDtoSendOffers, accountID, ownerID });
        res.status(200).json(responseData);
    }
    catch (error) {
        logger_1.default.error("Error in UpdateSendOffersToController", { error, memberIDtoSendOffers: req.body.memberIDtoSendOffers, accountID: req.body.accountID, ownerID: req.body.ownerID });
        next(error);
    }
}
//# sourceMappingURL=updateSendOffersTo.js.map


File: build/src/api/Account/controllers/createAccount.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateAccountController = CreateAccountController;
const CreateAccount_1 = require("../services/CreateAccount");
const denominations_1 = require("../../../constants/denominations");
const accountTypes_1 = require("../../../constants/accountTypes");
const logger_1 = __importDefault(require("../../../../config/logger"));
const validators_1 = require("../../../utils/validators");
async function CreateAccountController(req, res, next) {
    const { ownerID, accountType, accountName, accountHandle, defaultDenom, DCOgiveInCXX, DCOdenom } = req.body;
    try {
        // Validate input
        if (!(0, validators_1.validateUUID)(ownerID)) {
            res.status(400).json({ message: "Invalid ownerID" });
            return;
        }
        if (!(0, accountTypes_1.checkPermittedAccountType)(accountType)) {
            res.status(400).json({ message: "Invalid accountType" });
            return;
        }
        if (!(0, validators_1.validateAccountName)(accountName)) {
            res.status(400).json({ message: "Invalid accountName" });
            return;
        }
        if (!(0, validators_1.validateAccountHandle)(accountHandle)) {
            res.status(400).json({ message: "Invalid accountHandle" });
            return;
        }
        if (!(0, denominations_1.getDenominations)({ code: defaultDenom }).length) {
            res.status(400).json({ message: "Invalid defaultDenom" });
            return;
        }
        if (DCOdenom && !(0, denominations_1.getDenominations)({ code: DCOdenom }).length) {
            res.status(400).json({ message: "Invalid DCOdenom" });
            return;
        }
        if (DCOgiveInCXX && (isNaN(DCOgiveInCXX) || DCOgiveInCXX < 0)) {
            res.status(400).json({ message: "Invalid DCOgiveInCXX" });
            return;
        }
        logger_1.default.info("Creating new account", {
            ownerID,
            accountType,
            accountName,
            accountHandle,
            defaultDenom,
            DCOdenom,
        });
        const newAccount = await (0, CreateAccount_1.CreateAccountService)(ownerID, accountType, accountName, accountHandle, defaultDenom, DCOgiveInCXX, DCOdenom);
        if (newAccount.accountID) {
            logger_1.default.info("Account created successfully", { accountID: newAccount.accountID });
            res.status(201).json({ accountID: newAccount.accountID, message: "Account created successfully" });
        }
        else {
            res.status(400).json({ message: newAccount.message || "Failed to create account" });
        }
    }
    catch (error) {
        logger_1.default.error("Error in CreateAccountController", { error });
        next(error);
    }
}
//# sourceMappingURL=createAccount.js.map


File: build/src/api/Account/controllers/getAccountByHandle.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetAccountByHandleController = GetAccountByHandleController;
const GetAccountByHandle_1 = require("../services/GetAccountByHandle");
const logger_1 = __importDefault(require("../../../../config/logger"));
/**
 * Controller for retrieving an account by its handle
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
async function GetAccountByHandleController(req, res, next) {
    const { accountHandle } = req.body;
    try {
        if (!accountHandle || typeof accountHandle !== 'string') {
            res.status(400).json({ message: "accountHandle is required and must be a string" });
            return;
        }
        // Validate accountHandle format
        if (!/^[a-z0-9._]{3,30}$/.test(accountHandle)) {
            res.status(400).json({
                message: "Invalid account handle. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters.",
            });
            return;
        }
        logger_1.default.info("Retrieving account by handle", { accountHandle });
        const accountData = await (0, GetAccountByHandle_1.GetAccountByHandleService)(accountHandle);
        if (accountData) {
            logger_1.default.info("Account retrieved successfully", { accountHandle });
            res.status(200).json({ accountData });
        }
        else {
            logger_1.default.info("Account not found", { accountHandle });
            res.status(404).json({ message: "Account not found" });
        }
    }
    catch (error) {
        logger_1.default.error("Error in GetAccountByHandleController", { error, accountHandle });
        next(error);
    }
}
//# sourceMappingURL=getAccountByHandle.js.map


File: build/src/api/Account/controllers/getAccountDashboard.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetAccountDashboardController = GetAccountDashboardController;
const GetAccountDashboard_1 = require("../services/GetAccountDashboard");
async function GetAccountDashboardController(req, res) {
    const { memberID, accountID } = req.body;
    if (!memberID || !accountID) {
        return res.status(400).json({ message: "memberID and accountID are required" });
    }
    try {
        const accountDashboard = await (0, GetAccountDashboard_1.GetAccountDashboardService)(memberID, accountID);
        if (!accountDashboard) {
            return res.status(404).json({ message: "Account dashboard not found" });
        }
        return res.status(200).json(accountDashboard);
    }
    catch (error) {
        console.error("Error getting account dashboard:", error);
        return res.status(500).json({ error: "Internal Server Error" });
    }
}
//# sourceMappingURL=getAccountDashboard.js.map


File: build/src/api/Account/controllers/updateAccount.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateAccountController = UpdateAccountController;
const UpdateAccount_1 = require("../services/UpdateAccount");
const logger_1 = __importDefault(require("../../../../config/logger"));
const denominations_1 = require("../../../constants/denominations");
const validators_1 = require("../../../utils/validators");
async function UpdateAccountController(req, res, next) {
    const { ownerID, accountID, accountName, accountHandle, defaultDenom } = req.body;
    try {
        // Validate input
        if (!(0, validators_1.validateUUID)(ownerID)) {
            return res.status(400).json({ message: "Invalid ownerID" });
        }
        if (!(0, validators_1.validateUUID)(accountID)) {
            return res.status(400).json({ message: "Invalid accountID" });
        }
        if (accountName && !(0, validators_1.validateAccountName)(accountName)) {
            return res.status(400).json({ message: "Invalid accountName" });
        }
        if (accountHandle && !(0, validators_1.validateAccountHandle)(accountHandle)) {
            return res.status(400).json({ message: "Invalid accountHandle" });
        }
        if (defaultDenom && !(0, denominations_1.getDenominations)({ code: defaultDenom }).length) {
            return res.status(400).json({ message: "Invalid defaultDenom" });
        }
        logger_1.default.info("Updating account", { ownerID, accountID, accountName, accountHandle, defaultDenom });
        const updatedAccountID = await (0, UpdateAccount_1.UpdateAccountService)(ownerID, accountID, accountName, accountHandle, defaultDenom);
        if (updatedAccountID) {
            logger_1.default.info("Account updated successfully", { updatedAccountID });
            res.status(200).json({ message: `Account updated successfully`, accountID: updatedAccountID });
        }
        else {
            logger_1.default.warn("Account not found or no update performed", { ownerID, accountID });
            res.status(404).json({ message: "Account not found or no update performed" });
        }
    }
    catch (error) {
        logger_1.default.error("Error in UpdateAccountController", { error, ownerID: req.body.ownerID, accountID: req.body.accountID });
        next(error);
    }
}
//# sourceMappingURL=updateAccount.js.map


File: build/src/api/Account/accountRoutes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AccountRoutes;
const index_1 = require("../../index");
const createAccount_1 = require("./controllers/createAccount");
const getAccountByHandle_1 = require("./controllers/getAccountByHandle");
const updateAccount_1 = require("./controllers/updateAccount");
const authorizeForAccount_1 = require("./controllers/authorizeForAccount");
const unauthorizeForAccount_1 = require("./controllers/unauthorizeForAccount");
const updateSendOffersTo_1 = require("./controllers/updateSendOffersTo");
function AccountRoutes(app, jsonParser) {
    /**
     * @swagger
     * /api/v1/createAccount:
     *   post:
     *     summary: Create a new account
     *     tags: [Accounts]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - ownerID
     *               - accountType
     *               - accountName
     *               - accountHandle
     *               - defaultDenom
     *             properties:
     *               ownerID:
     *                 type: string
     *               accountType:
     *                 type: string
     *               accountName:
     *                 type: string
     *               accountHandle:
     *                 type: string
     *               defaultDenom:
     *                 type: string
     *     responses:
     *       200:
     *         description: Account created successfully
     *       400:
     *         description: Bad request
     */
    app.post(`${index_1.apiVersionOneRoute}createAccount`, jsonParser, createAccount_1.CreateAccountController);
    /**
     * @swagger
     * /api/v1/getAccountByHandle:
     *   get:
     *     summary: Get account by handle
     *     tags: [Accounts]
     *     parameters:
     *       - in: query
     *         name: accountHandle
     *         required: true
     *         schema:
     *           type: string
     *     responses:
     *       200:
     *         description: Account retrieved successfully
     *       400:
     *         description: Bad request
     *       404:
     *         description: Account not found
     */
    app.get(`${index_1.apiVersionOneRoute}getAccountByHandle`, jsonParser, getAccountByHandle_1.GetAccountByHandleController);
    /**
     * @swagger
     * /api/v1/updateAccount:
     *   patch:
     *     summary: Update account information
     *     tags: [Accounts]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - ownerID
     *               - accountID
     *             properties:
     *               ownerID:
     *                 type: string
     *               accountID:
     *                 type: string
     *               accountName:
     *                 type: string
     *               accountHandle:
     *                 type: string
     *               defaultDenom:
     *                 type: string
     *     responses:
     *       200:
     *         description: Account updated successfully
     *       400:
     *         description: Bad request
     *       404:
     *         description: Account not found
     */
    app.patch(`${index_1.apiVersionOneRoute}updateAccount`, jsonParser, updateAccount_1.UpdateAccountController);
    /**
     * @swagger
     * /api/v1/authorizeForAccount:
     *   post:
     *     summary: Authorize a member for an account
     *     tags: [Accounts]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - memberHandleToBeAuthorized
     *               - accountID
     *               - ownerID
     *             properties:
     *               memberHandleToBeAuthorized:
     *                 type: string
     *               accountID:
     *                 type: string
     *               ownerID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Member authorized successfully
     *       400:
     *         description: Bad request
     */
    app.post(`${index_1.apiVersionOneRoute}authorizeForAccount`, jsonParser, authorizeForAccount_1.AuthorizeForAccountController);
    /**
     * @swagger
     * /api/v1/unauthorizeForAccount:
     *   post:
     *     summary: Unauthorize a member for an account
     *     tags: [Accounts]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - memberIDtoBeUnauthorized
     *               - accountID
     *               - ownerID
     *             properties:
     *               memberIDtoBeUnauthorized:
     *                 type: string
     *               accountID:
     *                 type: string
     *               ownerID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Member unauthorized successfully
     *       400:
     *         description: Bad request
     */
    app.post(`${index_1.apiVersionOneRoute}unauthorizeForAccount`, jsonParser, unauthorizeForAccount_1.UnauthorizeForAccountController);
    /**
     * @swagger
     * /api/v1/updateSendOffersTo:
     *   post:
     *     summary: Update the member to receive offers for an account
     *     tags: [Accounts]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - memberIDtoSendOffers
     *               - accountID
     *               - ownerID
     *             properties:
     *               memberIDtoSendOffers:
     *                 type: string
     *               accountID:
     *                 type: string
     *               ownerID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Send offers recipient updated successfully
     *       400:
     *         description: Bad request
     */
    app.post(`${index_1.apiVersionOneRoute}updateSendOffersTo`, jsonParser, updateSendOffersTo_1.UpdateSendOffersToController);
}
//# sourceMappingURL=accountRoutes.js.map


File: build/src/api/Account/services/UpdateAccount.js
----------------------------------------
"use strict";
/*
updates data for a account

requires object of account data to be updated
field required: accountID

fields that can be updated:
    firstname
    lastname
    companyname
    phone
    accountHandle
    DailyCredcoinOfferingGive
    DailyCredcoinOfferingDenom

if extraneous data or data not matching criteria is included it will be ignored, data
that fits criteria (if any) will still be updated, and success message will be returned

returns accountID of updated account

returns null on error
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateAccountService = UpdateAccountService;
const neo4j_1 = require("../../../../config/neo4j");
const denominations_1 = require("../../../constants/denominations");
async function UpdateAccountService(ownerID, accountID, accountName, accountHandle, defaultDenom) {
    // Validation: Check defaultDenom in denominations
    if (!(0, denominations_1.getDenominations)({ code: defaultDenom }).length) {
        const message = "defaultDenom not in denoms";
        console.log(message);
        return false;
    }
    const dataToUpdate = {
        accountName: accountName,
        accountHandle: accountHandle,
        defaultDenom: defaultDenom,
    };
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`
        MATCH
          (owner:Member { memberID: $ownerID })
          -[:OWNS]->
          (account:Account { accountID: $accountID })
        SET account += $dataToUpdate
        RETURN account.accountID AS accountID
            `, { ownerID, accountID, dataToUpdate });
        if (!result.records[0].get("accountID")) {
            return false;
        }
        return result.records[0].get("accountID");
    }
    catch (error) {
        console.error("Error updating account data:", error);
        return null;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=UpdateAccount.js.map


File: build/src/api/Account/services/GetBalances.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetBalancesService = GetBalancesService;
const neo4j_1 = require("../../../../config/neo4j");
const denomUtils_1 = require("../../../utils/denomUtils");
async function GetBalancesService(accountID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const getSecuredBalancesQuery = await ledgerSpaceSession.run(`
      MATCH (account:Account {accountID: $accountID})

      // Get all unique denominations from Credex nodes related to the account
      OPTIONAL MATCH (account)-[:OWES|OFFERED]-(securedCredex:Credex)<-[:SECURES]-()
      WITH DISTINCT securedCredex.Denomination AS denom, account

      // Aggregate incoming secured amounts for each denomination ensuring uniqueness
      OPTIONAL MATCH (account)<-[:OWES]-(inSecuredCredex:Credex {Denomination: denom})<-[:SECURES]-()
      WITH denom, account, 
          collect(DISTINCT inSecuredCredex) AS inSecuredCredexes

      // Aggregate outgoing secured amounts for each denomination ensuring uniqueness
      OPTIONAL MATCH (account)-[:OWES|OFFERED]->(outSecuredCredex:Credex {Denomination: denom})<-[:SECURES]-()
      WITH denom, 
          reduce(s = 0, n IN inSecuredCredexes | s + n.OutstandingAmount) AS sumSecuredIn, 
          collect(DISTINCT outSecuredCredex) AS outSecuredCredexes

      // Calculate the total outgoing amount
      WITH denom, sumSecuredIn, 
          reduce(s = 0, n IN outSecuredCredexes | s + n.OutstandingAmount) AS sumSecuredOut

      // Get the current day node which should have active status
      MATCH (daynode:Daynode {Active: true})

      // Calculate the net secured balance for each denomination and return the result
      RETURN denom, (sumSecuredIn - sumSecuredOut) / daynode[denom] AS netSecured
      `, { accountID });
        const securedNetBalancesByDenom = getSecuredBalancesQuery.records
            .filter((record) => {
            const amount = record.get("netSecured");
            return typeof amount === "number" && isFinite(amount) && amount !== 0;
        })
            .map((record) => {
            const denom = record.get("denom");
            const amount = record.get("netSecured");
            return `${(0, denomUtils_1.denomFormatter)(amount, denom)} ${denom}`;
        });
        const getUnsecuredBalancesAndTotalAssetsQuery = await ledgerSpaceSession.run(`
        MATCH (account:Account{accountID:$accountID})

        OPTIONAL MATCH (account)<-[:OWES]-(owesInCredexUnsecured:Credex)
        WHERE NOT (owesInCredexUnsecured)<-[:SECURES]-()
        WITH account, COLLECT(DISTINCT owesInCredexUnsecured) AS unsecuredCredexesIn

        OPTIONAL MATCH (account)-[:OWES]->(owesOutCredexUnsecured:Credex)
        WHERE NOT (owesOutCredexUnsecured)<-[:SECURES]-()
        WITH account, unsecuredCredexesIn, COLLECT(DISTINCT owesOutCredexUnsecured) AS unsecuredCredexesOut

        OPTIONAL MATCH (account)<-[:OWES]-(owesInCredexAll:Credex)
        WITH account, unsecuredCredexesIn, unsecuredCredexesOut, COLLECT(DISTINCT owesInCredexAll) AS owesInCredexesAll

        OPTIONAL MATCH (account)-[:OWES]->(owesOutCredexAll:Credex)
        WITH account, unsecuredCredexesIn, unsecuredCredexesOut, owesInCredexesAll, COLLECT(DISTINCT owesOutCredexAll) AS owesOutCredexesAll

        WITH
          account.defaultDenom AS defaultDenom,
          REDUCE(total = 0, credex IN unsecuredCredexesIn | total + credex.OutstandingAmount) AS receivablesTotalCXX,
          REDUCE(total = 0, credex IN unsecuredCredexesOut | total + credex.OutstandingAmount) AS payablesTotalCXX,
          REDUCE(total = 0, credex IN unsecuredCredexesIn | total + credex.OutstandingAmount)
            - REDUCE(total = 0, credex IN unsecuredCredexesOut | total + credex.OutstandingAmount) AS unsecuredNetCXX,
          REDUCE(total = 0, credex IN owesInCredexesAll | total + credex.OutstandingAmount)
            - REDUCE(total = 0, credex IN owesOutCredexesAll | total + credex.OutstandingAmount) AS netCredexAssetsCXX
        MATCH (daynode:Daynode{Active:true})
        RETURN
          defaultDenom,
          receivablesTotalCXX / daynode[defaultDenom] AS receivablesTotalInDefaultDenom,
          payablesTotalCXX / daynode[defaultDenom] AS payablesTotalInDefaultDenom,
          unsecuredNetCXX / daynode[defaultDenom] AS unsecuredNetInDefaultDenom,
          netCredexAssetsCXX / daynode[defaultDenom] AS netCredexAssetsInDefaultDenom
      `, { accountID });
        const unsecuredBalancesAndTotalAssets = getUnsecuredBalancesAndTotalAssetsQuery.records[0];
        const defaultDenom = unsecuredBalancesAndTotalAssets.get("defaultDenom");
        const unsecuredBalancesInDefaultDenom = {
            totalPayables: `${(0, denomUtils_1.denomFormatter)(unsecuredBalancesAndTotalAssets.get("payablesTotalInDefaultDenom"), defaultDenom)} ${defaultDenom}`,
            totalReceivables: `${(0, denomUtils_1.denomFormatter)(unsecuredBalancesAndTotalAssets.get("receivablesTotalInDefaultDenom"), defaultDenom)} ${defaultDenom}`,
            netPayRec: `${(0, denomUtils_1.denomFormatter)(unsecuredBalancesAndTotalAssets.get("unsecuredNetInDefaultDenom"), defaultDenom)} ${defaultDenom}`,
        };
        return {
            securedNetBalancesByDenom,
            unsecuredBalancesInDefaultDenom,
            netCredexAssetsInDefaultDenom: `${(0, denomUtils_1.denomFormatter)(unsecuredBalancesAndTotalAssets.get("netCredexAssetsInDefaultDenom"), defaultDenom)} ${defaultDenom}`,
        };
    }
    catch (error) {
        console.error("Error fetching balances:", error);
        throw new Error("Failed to fetch balances. Please try again later.");
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetBalances.js.map


File: build/src/api/Account/services/UpdateSendOffersTo.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateSendOffersToService = UpdateSendOffersToService;
const neo4j_1 = require("../../../../config/neo4j");
async function UpdateSendOffersToService(memberIDtoSendOffers, accountID, ownerID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`
            MATCH
                (newMemberForOffers: Member { memberID: $memberIDtoSendOffers})
                -[:AUTHORIZED_FOR]->(account:Account { accountID: $accountID})
                <-[:OWNS]-(owner:Member { memberID: $ownerID}),
                (account)-[currentAccountForOffersRel:SEND_OFFERS_TO]->(:Member)
            DELETE currentAccountForOffersRel
            CREATE (account)-[:SEND_OFFERS_TO]->(newMemberForOffers)
            RETURN true
            `, {
            memberIDtoSendOffers,
            accountID,
            ownerID,
        });
        if (!result.records.length) {
            return false;
        }
        return true;
    }
    catch (error) {
        console.error("Error updating account to receive offer notifications:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=UpdateSendOffersTo.js.map


File: build/src/api/Account/services/CreateAccount.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateAccountService = CreateAccountService;
const neo4j_1 = require("../../../../config/neo4j");
async function CreateAccountService(ownerID, accountType, accountName, accountHandle, defaultDenom, DCOgiveInCXX = null, DCOdenom = null) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    //check that account creation is permitted on membership tier
    const getMemberTier = await ledgerSpaceSession.run(`
        MATCH (member:Member{ memberID: $ownerID })
        OPTIONAL MATCH (member)-[:OWNS]->(account:Account)
        RETURN
          member.memberTier AS memberTier,
          COUNT(account) AS numAccounts
      `, { ownerID });
    const memberTier = getMemberTier.records[0].get("memberTier");
    const numAccounts = getMemberTier.records[0].get("numAccounts");
    if (memberTier <= 2 && numAccounts >= 1) {
        return {
            account: false,
            message: "You cannot create an account on the Open or Verified membership tiers.",
        };
    }
    try {
        const result = await ledgerSpaceSession.run(`
        MATCH (daynode:Daynode { Active: true })
        MATCH (owner:Member { memberID: $ownerID })
        CREATE (owner)-[:OWNS]->(account:Account {
          accountType: $accountType,
          accountName: $accountName,
          accountHandle: $accountHandle,
          defaultDenom: $defaultDenom,
          DCOgiveInCXX: $DCOgiveInCXX,
          DCOdenom: $DCOdenom,
          accountID: randomUUID(),
          queueStatus: "PENDING_ACCOUNT",
          createdAt: datetime(),
          updatedAt: datetime()
        })-[:CREATED_ON]->(daynode)
        CREATE
          (owner)-[:AUTHORIZED_FOR]->
          (account)
          -[:SEND_OFFERS_TO]->(owner)
        RETURN account.accountID AS accountID
      `, {
            ownerID,
            accountType,
            accountName,
            accountHandle,
            defaultDenom,
            DCOgiveInCXX,
            DCOdenom,
        });
        if (!result.records.length) {
            const message = "could not create account";
            console.log(message);
            return { account: false, message };
        }
        const createdAccountID = result.records[0].get("accountID");
        console.log(accountType + " account created: " + createdAccountID);
        return {
            accountID: createdAccountID,
            message: "account created",
        };
    }
    catch (error) {
        console.error("Error creating account:", error);
        if (isNeo4jError(error) &&
            error.code === "Neo.ClientError.Schema.ConstraintValidationFailed") {
            if (error.message.includes("phone")) {
                return { account: false, message: "Phone number already in use" };
            }
            if (error.message.includes("handle")) {
                return {
                    account: false,
                    message: "Sorry, that handle is already in use",
                };
            }
            return { account: false, message: "Required unique field not unique" };
        }
        return {
            account: false,
            message: "Error: " + (error instanceof Error ? error.message : "Unknown error"),
        };
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
// Type guard to check if an error is a Neo4j error
function isNeo4jError(error) {
    return (typeof error === "object" &&
        error !== null &&
        "code" in error &&
        "message" in error);
}
//# sourceMappingURL=CreateAccount.js.map


File: build/src/api/Account/services/AuthorizeForAccount.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizeForAccountService = AuthorizeForAccountService;
const neo4j_1 = require("../../../../config/neo4j");
async function AuthorizeForAccountService(memberHandleToBeAuthorized, accountID, ownerID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        // Check that account authorization is permitted on membership tier
        const getMemberTier = await ledgerSpaceSession.run(`
        MATCH (member:Member{ memberID: $ownerID })
        RETURN member.memberTier as memberTier
      `, { ownerID });
        const memberTier = getMemberTier.records[0].get("memberTier");
        if (memberTier <= 3) {
            return {
                message: "You can only authorize someone to transact on behalf of your account when you are on the Entrepreneur tier or above.",
            };
        }
        const result = await ledgerSpaceSession.run(`
        MATCH (account:Account { accountID: $accountID })
            <-[:OWNS]-(owner:Member { memberID: $ownerID })
        MATCH (memberToAuthorize:Member { memberHandle: $memberHandleToBeAuthorized })
        MATCH (:Member)-[currentAuthForRel:AUTHORIZED_FOR]->(account)
        WITH count (currentAuthForRel) AS numAuthorized, memberToAuthorize, account
        CALL apoc.do.when(
          numAuthorized >= 5,
          'RETURN "limitReached" AS message',
          'MERGE (memberToAuthorize)-[:AUTHORIZED_FOR]->(account)
            RETURN
              "accountAuthorized" AS message,
              account.accountID AS accountID,
              memberToAuthorize.memberID AS memberIDtoAuthorize',
          {
            numAuthorized: numAuthorized,
            memberToAuthorize: memberToAuthorize,
            account: account
          }
        )
        YIELD value
        RETURN
          value.message AS message,
          value.accountID AS accountID,
          value.memberIDtoAuthorize AS memberIDtoAuthorize
      `, {
            memberHandleToBeAuthorized,
            accountID,
            ownerID,
        });
        if (!result.records.length) {
            return {
                message: "accounts not found",
            };
        }
        const record = result.records[0];
        if (record.get("message") == "limitReached") {
            return {
                message: "Limit of 5 authorized accounts reached. Remove an authorized account if you want to add another.",
            };
        }
        if (record.get("message") == "accountAuthorized") {
            console.log(`account ${record.get("memberIDtoAuthorize")} authorized to transact for ${record.get("accountID")}`);
            return {
                message: "account authorized",
                accountID: record.get("accountID"),
                memberIdAuthorized: record.get("memberIDtoAuthorized"),
            };
        }
        else {
            console.log("could not authorize account");
            return false;
        }
    }
    catch (error) {
        console.error("Error authorizing account:", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=AuthorizeForAccount.js.map


File: build/src/api/Account/services/UnauthorizeForAccount.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnauthorizeForCompanyService = UnauthorizeForCompanyService;
const neo4j_1 = require("../../../../config/neo4j");
async function UnauthorizeForCompanyService(memberIDtoBeUnauthorized, accountID, ownerID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`
            MATCH
                (memberToUnauthorize:Member { memberID: $memberIDtoBeUnauthorized })
                -[authRel:AUTHORIZED_FOR]->(account:Account { accountID: $accountID })
                <-[:OWNS]-(owner:Member { memberID: $ownerID })
            DELETE authRel
            RETURN
                account.accountID AS accountID,
                memberToUnauthorize.accountID AS memberToUnauthorize
        `, {
            memberIDtoBeUnauthorized,
            accountID,
            ownerID,
        });
        if (!result.records.length) {
            console.log("could not unauthorize account");
            return false;
        }
        const record = result.records[0];
        console.log(`account ${record.get("memberToUnauthorize")} unauthorized to transact for ${record.get("accountID")}`);
        return true;
    }
    catch (error) {
        console.error("Error unauthorizing account:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=UnauthorizeForAccount.js.map


File: build/src/api/Account/services/GetAccountByHandle.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetAccountByHandleService = GetAccountByHandleService;
const neo4j_1 = require("../../../../config/neo4j");
async function GetAccountByHandleService(accountHandle) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    if (!accountHandle) {
        console.log("accountHandle is required");
        return null;
    }
    try {
        const result = await ledgerSpaceSession.run(`
            MATCH (account:Account { accountHandle: $accountHandle })
            RETURN
              account.accountID AS accountID,
              account.accountName AS accountName
        `, { accountHandle });
        if (!result.records.length) {
            console.log("account not found");
            return null;
        }
        const accountID = result.records[0].get("accountID");
        const accountName = result.records[0].get("accountName");
        return {
            accountID: accountID,
            accountName: accountName,
        };
    }
    catch (error) {
        console.error("Error fetching account data:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetAccountByHandle.js.map


File: build/src/api/Account/services/GetAccountDashboard.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetAccountDashboardService = GetAccountDashboardService;
const neo4j_1 = require("../../../../config/neo4j");
const GetBalances_1 = require("./GetBalances");
const GetPendingOffersIn_1 = require("../../Credex/services/GetPendingOffersIn");
const GetPendingOffersOut_1 = require("../../Credex/services/GetPendingOffersOut");
async function GetAccountDashboardService(memberID, accountID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`
    MATCH
      (account:Account { accountID: $accountID })
      <-[:AUTHORIZED_FOR]-
      (member:Member { memberID: $memberID})
    MATCH
      (account)<-[:AUTHORIZED_FOR]-(allAuthMembers)
    OPTIONAL MATCH
      (account)<-[owns:OWNS]-(member)
    OPTIONAL MATCH
      (account)-[:SEND_OFFERS_TO]->(sendOffersTo:Member)
    RETURN
      account.accountID AS accountID,
      account.accountType AS accountType,
      account.accountName AS accountName,
      account.accountHandle AS accountHandle,
      account.defaultDenom AS defaultDenom,
      sendOffersTo.firstname AS sendOffersToFirstname,
      sendOffersTo.lastname AS sendOffersToLastname,
      sendOffersTo.memberID AS sendOffersToMemberID,
      owns IS NOT NULL AS isOwnedAccount,
      allAuthMembers.firstname AS authMemberFirstname,
      allAuthMembers.lastname AS authMemberLastname,
      allAuthMembers.memberID AS authMemberID
  `, { memberID, accountID });
        if (!result.records.length) {
            console.log("account not found");
            return null;
        }
        const accountData = {
            accountID: result.records[0].get("accountID"),
            accountName: result.records[0].get("accountName"),
            accountHandle: result.records[0].get("accountHandle"),
            defaultDenom: result.records[0].get("defaultDenom"),
            isOwnedAccount: result.records[0].get("isOwnedAccount"),
            sendOffersToFirstname: "",
            sendOffersToLastname: "",
            sendOffersToMemberID: "",
            authFor: [],
            balanceData: [],
            pendingInData: [],
            pendingOutData: [],
        };
        if (accountData.isOwnedAccount) {
            (accountData.sendOffersToFirstname = result.records[0].get("sendOffersToFirstname")),
                (accountData.sendOffersToLastname = result.records[0].get("sendOffersToLastname")),
                (accountData.sendOffersToMemberID = result.records[0].get("sendOffersToMemberID")),
                result.records.forEach((record) => {
                    accountData.authFor.push({
                        memberID: record.get("authMemberID"),
                        firstname: record.get("authMemberFirstname"),
                        lastname: record.get("authMemberLastname"),
                    });
                });
        }
        else {
            accountData.authFor = [];
        }
        accountData.balanceData = await (0, GetBalances_1.GetBalancesService)(accountData.accountID);
        accountData.pendingInData = await (0, GetPendingOffersIn_1.GetPendingOffersInService)(accountData.accountID);
        accountData.pendingOutData = await (0, GetPendingOffersOut_1.GetPendingOffersOutService)(accountData.accountID);
        return accountData;
    }
    catch (error) {
        console.error("Error fetching account data:", error);
        return null;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetAccountDashboard.js.map


File: build/src/api/Avatar/controllers/cancelRecurring.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeclineRecurringController = DeclineRecurringController;
const CancelRecurring_1 = require("../services/CancelRecurring");
const getAccountDashboard_1 = require("../../Account/controllers/getAccountDashboard");
async function DeclineRecurringController(req, res) {
    const fieldsRequired = ["signerID", "cancelerAccountID", "avatarID"];
    for (const field of fieldsRequired) {
        if (!req.body[field]) {
            return res
                .status(400)
                .json({ message: `${field} is required` })
                .send();
        }
    }
    try {
        const cancelRecurringData = await (0, CancelRecurring_1.CancelRecurringService)(req.body.signerID, req.body.cancelerAccountID, req.body.avatarID);
        if (!cancelRecurringData) {
            return res.status(400).json(cancelRecurringData);
        }
        const dashboardReq = {
            body: {
                memberID: req.body.signerID,
                accountID: req.body.cancelerAccountID
            }
        };
        const dashboardRes = {
            status: (code) => ({
                json: (data) => data
            })
        };
        const dashboardData = await (0, getAccountDashboard_1.GetAccountDashboardController)(dashboardReq, dashboardRes);
        res.json({
            cancelRecurringData: cancelRecurringData,
            dashboardData: dashboardData,
        });
    }
    catch (err) {
        console.error("Error in DeclineRecurringController:", err);
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=cancelRecurring.js.map


File: build/src/api/Avatar/controllers/acceptRecurring.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcceptRecurringController = AcceptRecurringController;
const AcceptRecurring_1 = require("../services/AcceptRecurring");
const GetAccountDashboard_1 = require("../../Account/services/GetAccountDashboard");
/**
 * AcceptRecurringController
 *
 * This controller handles the acceptance of recurring transactions.
 * It validates the required fields, calls the AcceptRecurringService,
 * and returns the result along with updated dashboard data.
 *
 * @param req - Express request object
 * @param res - Express response object
 */
async function AcceptRecurringController(req, res) {
    try {
        // Validate required fields
        const fieldsRequired = ["avatarID", "signerID"];
        for (const field of fieldsRequired) {
            if (!req.body[field]) {
                return res.status(400).json({ error: `${field} is required` });
            }
        }
        // Call AcceptRecurringService to process the acceptance
        const acceptRecurringData = await (0, AcceptRecurring_1.AcceptRecurringService)({
            avatarID: req.body.avatarID,
            signerID: req.body.signerID
        });
        // Check if the service call was successful
        if (typeof acceptRecurringData.recurring === "boolean") {
            return res.status(400).json({ error: acceptRecurringData.message });
        }
        // Fetch dashboard data
        const dashboardData = await (0, GetAccountDashboard_1.GetAccountDashboardService)(req.body.signerID, acceptRecurringData.recurring.acceptorAccountID);
        if (!dashboardData) {
            return res.status(404).json({ error: "Failed to fetch dashboard data" });
        }
        // Return the acceptance data and dashboard data
        return res.status(200).json({
            acceptRecurringData: acceptRecurringData,
            dashboardData: dashboardData,
        });
    }
    catch (err) {
        console.error("Error in AcceptRecurringController:", err);
        return res.status(500).json({ error: "Internal server error" });
    }
}
//# sourceMappingURL=acceptRecurring.js.map


File: build/src/api/Avatar/controllers/requestRecurring.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestRecurringController = RequestRecurringController;
const RequestRecurring_1 = require("../services/RequestRecurring");
const GetAccountDashboard_1 = require("../../Account/services/GetAccountDashboard");
const denominations_1 = require("../../../constants/denominations");
/**
 * RequestRecurringController
 *
 * This controller handles the creation of recurring payment requests.
 * It validates the input, calls the RequestRecurringService,
 * and returns the result along with updated dashboard data.
 *
 * @param req - Express request object
 * @param res - Express response object
 */
async function RequestRecurringController(req, res) {
    try {
        // Validate required fields
        const fieldsRequired = [
            "signerMemberID",
            "requestorAccountID",
            "counterpartyAccountID",
            "InitialAmount",
            "Denomination",
            "nextPayDate",
            "daysBetweenPays",
        ];
        for (const field of fieldsRequired) {
            if (!req.body[field]) {
                return res.status(400).json({ error: `${field} is required` });
            }
        }
        // Check denomination validity
        if (!(0, denominations_1.getDenominations)({ code: req.body.Denomination }).length) {
            return res.status(400).json({ error: "Denomination not permitted" });
        }
        // Validate optional parameters
        if (req.body.securedCredex !== undefined && typeof req.body.securedCredex !== 'boolean') {
            return res.status(400).json({ error: "securedCredex must be a boolean" });
        }
        if (req.body.credspan !== undefined) {
            const credspan = Number(req.body.credspan);
            if (isNaN(credspan) || credspan < 7 || credspan > 35) {
                return res.status(400).json({ error: "credspan must be a number between 7 and 35" });
            }
        }
        if (req.body.remainingPays !== undefined) {
            const remainingPays = Number(req.body.remainingPays);
            if (isNaN(remainingPays) || remainingPays < 0) {
                return res.status(400).json({ error: "remainingPays must be a positive number" });
            }
        }
        // Check securedCredex and credspan relationship
        if (req.body.securedCredex === true && req.body.credspan !== undefined) {
            return res.status(400).json({ error: "credspan must be null when securedCredex is true" });
        }
        if (req.body.securedCredex !== true && req.body.credspan === undefined) {
            return res.status(400).json({ error: "credspan must be provided when securedCredex is not true" });
        }
        const createRecurringData = await (0, RequestRecurring_1.RequestRecurringService)(req.body);
        if (!createRecurringData) {
            return res.status(400).json({ error: "Failed to create recurring payment" });
        }
        const dashboardData = await (0, GetAccountDashboard_1.GetAccountDashboardService)(req.body.signerMemberID, req.body.requestorAccountID);
        if (!dashboardData) {
            return res.status(404).json({ error: "Failed to fetch dashboard data" });
        }
        return res.status(200).json({
            avatarMemberID: createRecurringData,
            dashboardData: dashboardData,
        });
    }
    catch (err) {
        console.error("Error in RequestRecurringController:", err);
        return res.status(500).json({ error: "Internal server error" });
    }
}
//# sourceMappingURL=requestRecurring.js.map


File: build/src/api/Avatar/recurringRoutes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RecurringRoutes;
const index_1 = require("../../index");
const requestRecurring_1 = require("./controllers/requestRecurring");
const acceptRecurring_1 = require("./controllers/acceptRecurring");
const cancelRecurring_1 = require("./controllers/cancelRecurring");
function RecurringRoutes(app, jsonParser) {
    /**
     * @swagger
     * /api/v1/requestRecurring:
     *   post:
     *     summary: Request a recurring payment
     *     tags: [Recurring]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - signerMemberID
     *               - requestorAccountID
     *               - counterpartyAccountID
     *               - InitialAmount
     *               - Denomination
     *               - nextPayDate
     *               - daysBetweenPays
     *             properties:
     *               signerMemberID:
     *                 type: string
     *               requestorAccountID:
     *                 type: string
     *               counterpartyAccountID:
     *                 type: string
     *               InitialAmount:
     *                 type: number
     *               Denomination:
     *                 type: string
     *               nextPayDate:
     *                 type: string
     *                 format: date
     *               daysBetweenPays:
     *                 type: integer
     *               securedCredex:
     *                 type: boolean
     *               credspan:
     *                 type: integer
     *               remainingPays:
     *                 type: integer
     *     responses:
     *       200:
     *         description: Recurring payment requested successfully
     *       400:
     *         description: Bad request
     */
    app.post(`${index_1.apiVersionOneRoute}requestRecurring`, jsonParser, requestRecurring_1.RequestRecurringController);
    /**
     * @swagger
     * /api/v1/acceptRecurring:
     *   put:
     *     summary: Accept a recurring payment request
     *     tags: [Recurring]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - avatarID
     *               - signerID
     *             properties:
     *               avatarID:
     *                 type: string
     *               signerID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Recurring payment accepted successfully
     *       400:
     *         description: Bad request
     */
    app.put(`${index_1.apiVersionOneRoute}acceptRecurring`, jsonParser, acceptRecurring_1.AcceptRecurringController);
    /**
     * @swagger
     * /api/v1/cancelRecurring:
     *   put:
     *     summary: Cancel a recurring payment
     *     tags: [Recurring]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - signerID
     *               - cancelerAccountID
     *               - avatarID
     *             properties:
     *               signerID:
     *                 type: string
     *               cancelerAccountID:
     *                 type: string
     *               avatarID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Recurring payment cancelled successfully
     *       400:
     *         description: Bad request
     */
    app.put(`${index_1.apiVersionOneRoute}cancelRecurring`, jsonParser, cancelRecurring_1.DeclineRecurringController);
}
//# sourceMappingURL=recurringRoutes.js.map


File: build/src/api/Avatar/services/CancelRecurring.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CancelRecurringService = CancelRecurringService;
const neo4j_1 = require("../../../../config/neo4j");
async function CancelRecurringService(signerID, cancelerAccountID, avatarID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        // Validate and update the Recurring node
        const cancelRecurringQuery = await ledgerSpaceSession.run(`
      MATCH
        (signer:Member { memberID: $signerID })-[:AUTHORIZED_FOR]->
        (cancelingAccount:Account { accountID: $cancelerAccountID })-[rel1:ACTIVE|REQUESTS]-
        (recurring:Avatar { memberID: $avatarID})-[rel2:ACTIVE|REQUESTS]-
        (counterparty:Account)
      MATCH
        (cancelingAccount)<-[authRel1:AUTHORIZED_FOR]-
        (recurring)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH cancelingAccount, recurring, counterparty, rel1, rel2, authRel1, authRel2
      CALL apoc.create.relationship(cancelingAccount, 'CANCELED', {}, recurring) YIELD rel as canceledRel1
      CALL apoc.create.relationship(recurring, 'CANCELED', {}, counterparty) YIELD rel as canceledRel2
      DELETE rel1, rel2, authRel1, authRel2
      RETURN recurring.memberID AS deactivatedAvatarID
      `, {
            signerID,
            cancelerAccountID,
            avatarID,
        });
        if (cancelRecurringQuery.records.length === 0) {
            return "Recurring template not found or not authorized to cancel";
        }
        const deactivatedAvatarID = cancelRecurringQuery.records[0].get("deactivatedAvatarID");
        return deactivatedAvatarID;
    }
    catch (error) {
        return error;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=CancelRecurring.js.map


File: build/src/api/Avatar/services/AcceptRecurring.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcceptRecurringService = AcceptRecurringService;
const neo4j_1 = require("../../../../config/neo4j");
/**
 * AcceptRecurringService
 *
 * This service handles the acceptance of a recurring transaction.
 * It updates the database to reflect the acceptance of the recurring avatar.
 *
 * @param params - An object containing avatarID and signerID
 * @returns An object containing the result of the acceptance operation
 */
async function AcceptRecurringService(params) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const { avatarID, signerID } = params;
        // Execute Cypher query to validate and update the Recurring avatar
        const acceptRecurringQuery = await ledgerSpaceSession.run(`
      MATCH
        (signer:Member { memberID: $signerID })-[:AUTHORIZED_FOR]->
        (acceptor:Account)-[rel1:REQUESTS]->
        (recurring:Avatar { memberID: $avatarID })-[rel2:REQUESTS]->
        (requestor:Account)
      CREATE (signer)-[:SIGNED]->(recurring)
      CREATE (acceptor)<-[:AUTHORIZED_FOR]-(recurring)
      CREATE (acceptor)-[:ACTIVE]->(recurring)-[:ACTIVE]->(requestor)
      DELETE rel1, rel2
      RETURN
        recurring.memberID AS avatarID,
        acceptor.accountID AS acceptorAccountID,
        signer.memberID AS signerID
      `, { avatarID, signerID });
        // Check if the query returned any records
        if (acceptRecurringQuery.records.length === 0) {
            console.log(`No records found or recurring transaction no longer pending for avatarID: ${avatarID}`);
            return {
                recurring: false,
                message: `No records found or recurring transaction no longer pending for avatarID: ${avatarID}`,
            };
        }
        // TODO: Implement notification for recurring acceptance
        // Extract relevant data from the query result
        const record = acceptRecurringQuery.records[0];
        const acceptedRecurringID = record.get("avatarID");
        const acceptorAccountID = record.get("acceptorAccountID");
        const acceptorSignerID = record.get("signerID");
        console.log(`Recurring request accepted for avatarID: ${acceptedRecurringID}`);
        // Return the result of the acceptance operation
        return {
            recurring: {
                acceptedRecurringID,
                acceptorAccountID,
                acceptorSignerID,
            },
            message: "Recurring template created",
        };
    }
    catch (error) {
        // Handle any errors that occur during the process
        console.error("Error accepting recurring template:", error);
        return {
            recurring: false,
            message: `Error accepting recurring template: ${error}`,
        };
    }
    finally {
        // Ensure the database session is closed
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=AcceptRecurring.js.map


File: build/src/api/Avatar/services/RequestRecurring.js
----------------------------------------
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestRecurringService = RequestRecurringService;
const neo4j_1 = require("../../../../config/neo4j");
const neo4j = __importStar(require("neo4j-driver"));
async function RequestRecurringService(params) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        let cypher = `
      MATCH
        (requestor:Account {accountID: $requestorAccountID})<-[:AUTHORIZED_FOR]-
        (signer:Member|Avatar { memberID: $signerMemberID })
      MATCH (counterparty:Account {accountID: $counterpartyAccountID})
      MATCH (daynode:Daynode { Active: true })
      CREATE (recurring:Avatar)
      SET
        recurring.avatarType = "RECURRING",
        recurring.memberID = randomUUID(),
        recurring.Denomination = $Denomination,
        recurring.InitialAmount = $InitialAmount,
        recurring.nextPayDate = date($nextPayDate),
        recurring.daysBetweenPays = $daysBetweenPays,
        recurring.createdAt = datetime(),
        recurring.memberTier = 3
    `;
        if (params.securedCredex !== undefined) {
            cypher += `SET recurring.securedCredex = $securedCredex `;
        }
        if (params.credspan !== undefined) {
            cypher += `SET recurring.credspan = $credspan `;
        }
        if (params.remainingPays !== undefined) {
            cypher += `SET recurring.remainingPays = $remainingPays `;
        }
        cypher += `
      CREATE (requestor)<-[:REQUESTS]-(recurring)<-[:REQUESTS]-(counterparty)
      CREATE (requestor)<-[:REQUESTED]-(recurring)<-[:REQUESTED]-(counterparty)
      CREATE (requestor)<-[:AUTHORIZED_FOR]-(recurring)
      CREATE (signer)-[:SIGNED]--(recurring)
      CREATE (recurring)-[:CREATED_ON]--(daynode)
      RETURN
        recurring.memberID AS avatarID
    `;
        const neo4jParams = {
            ...params,
            daysBetweenPays: neo4j.int(params.daysBetweenPays),
            credspan: params.credspan ? neo4j.int(params.credspan) : undefined,
            remainingPays: params.remainingPays ? neo4j.int(params.remainingPays) : undefined
        };
        const createRecurringQuery = await ledgerSpaceSession.run(cypher, neo4jParams);
        return createRecurringQuery.records[0]?.get("avatarID") || null;
    }
    catch (error) {
        console.error("Error creating recurring avatar:", error);
        return null;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=RequestRecurring.js.map


File: build/src/api/Credex/controllers/getCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetCredexController = GetCredexController;
const GetCredex_1 = require("../services/GetCredex");
async function GetCredexController(req, res) {
    const fieldsRequired = ["credexID", "accountID"];
    for (const field of fieldsRequired) {
        if (!req.body[field]) {
            return res
                .status(400)
                .json({ message: `${field} is required` })
                .send();
        }
    }
    try {
        const responseData = await (0, GetCredex_1.GetCredexService)(req.body.credexID, req.body.accountID);
        res.json(responseData);
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=getCredex.js.map


File: build/src/api/Credex/controllers/cancelCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CancelCredexController = CancelCredexController;
const CancelCredex_1 = require("../services/CancelCredex");
/**
 * CancelCredexController
 *
 * This controller handles the cancellation of Credex offers.
 * It validates the required fields, calls the CancelCredexService,
 * and returns the result.
 *
 * @param req - Express request object
 * @param res - Express response object
 */
async function CancelCredexController(req, res) {
    try {
        // Validate required fields
        if (!req.body.credexID) {
            return res.status(400).json({ error: "credexID is required" });
        }
        const responseData = await (0, CancelCredex_1.CancelCredexService)(req.body.credexID);
        if (!responseData) {
            return res.status(404).json({ error: "Credex not found or already processed" });
        }
        return res.status(200).json({ message: "Credex cancelled successfully", credexID: responseData });
    }
    catch (err) {
        console.error("Error in CancelCredexController:", err);
        return res.status(500).json({ error: "Internal server error" });
    }
}
//# sourceMappingURL=cancelCredex.js.map


File: build/src/api/Credex/controllers/acceptCredexBulk.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcceptCredexBulkController = AcceptCredexBulkController;
const AcceptCredex_1 = require("../services/AcceptCredex");
const getAccountDashboard_1 = require("../../Account/controllers/getAccountDashboard");
async function AcceptCredexBulkController(req, res) {
    const fieldsRequired = ["credexIDs", "signerID"];
    for (const field of fieldsRequired) {
        if (!req.body[field]) {
            return res
                .status(400)
                .json({ message: `${field} is required` })
                .send();
        }
    }
    if (!Array.isArray(req.body.credexIDs) ||
        !req.body.credexIDs.every((id) => typeof id === "string")) {
        return res
            .status(400)
            .json({ message: "Array of credexIDs to accept is required" });
    }
    try {
        const acceptCredexData = await Promise.all(req.body.credexIDs.map(async (credexID) => {
            const data = await (0, AcceptCredex_1.AcceptCredexService)(credexID, req.body.signerID);
            if (data) {
                return data;
            }
            return null;
        }));
        // Filter out any null values
        const validCredexData = acceptCredexData.filter((item) => item !== null);
        if (validCredexData.length > 0) {
            // Assuming that memberID and acceptorAccountID are the same for all returned objects
            const { memberID, acceptorAccountID } = validCredexData[0];
            const dashboardReq = {
                body: {
                    memberID,
                    accountID: acceptorAccountID
                }
            };
            const dashboardRes = {
                status: (code) => ({
                    json: (data) => data
                })
            };
            const dashboardData = await (0, getAccountDashboard_1.GetAccountDashboardController)(dashboardReq, dashboardRes);
            res.json({
                acceptCredexData: validCredexData,
                dashboardData: dashboardData,
            });
        }
        else {
            // Handle the case when there are no valid data returned from AcceptCredexService
            res
                .status(400)
                .json({ error: "No valid data returned from AcceptCredexService" });
        }
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=acceptCredexBulk.js.map


File: build/src/api/Credex/controllers/declineCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeclineCredexController = DeclineCredexController;
const DeclineCredex_1 = require("../services/DeclineCredex");
async function DeclineCredexController(req, res) {
    const fieldsRequired = ["credexID"];
    for (const field of fieldsRequired) {
        if (!req.body[field]) {
            return res
                .status(400)
                .json({ message: `${field} is required` })
                .send();
        }
    }
    try {
        const responseData = await (0, DeclineCredex_1.DeclineCredexService)(req.body.credexID);
        res.json(responseData);
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
}
//# sourceMappingURL=declineCredex.js.map


File: build/src/api/Credex/controllers/acceptCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcceptCredexController = AcceptCredexController;
const AcceptCredex_1 = require("../services/AcceptCredex");
const GetAccountDashboard_1 = require("../../Account/services/GetAccountDashboard");
/**
 * AcceptCredexController
 *
 * This controller handles the acceptance of Credex offers.
 * It validates the required fields, calls the AcceptCredexService,
 * and returns the result along with updated dashboard data.
 *
 * @param req - Express request object
 * @param res - Express response object
 */
async function AcceptCredexController(req, res) {
    try {
        // Validate required fields
        const fieldsRequired = ["credexID", "signerID"];
        for (const field of fieldsRequired) {
            if (!req.body[field]) {
                return res.status(400).json({ error: `${field} is required` });
            }
        }
        const acceptCredexData = await (0, AcceptCredex_1.AcceptCredexService)(req.body.credexID, req.body.signerID);
        if (!acceptCredexData) {
            return res.status(400).json({ error: "Failed to accept Credex" });
        }
        const dashboardData = await (0, GetAccountDashboard_1.GetAccountDashboardService)(req.body.signerID, acceptCredexData.acceptorAccountID);
        if (!dashboardData) {
            return res.status(404).json({ error: "Failed to fetch dashboard data" });
        }
        return res.status(200).json({
            acceptCredexData: acceptCredexData,
            dashboardData: dashboardData,
        });
    }
    catch (err) {
        console.error("Error in AcceptCredexController:", err);
        return res.status(500).json({ error: "Internal server error" });
    }
}
//# sourceMappingURL=acceptCredex.js.map


File: build/src/api/Credex/controllers/getLedger.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetLedgerController = GetLedgerController;
const GetLedger_1 = require("../services/GetLedger");
async function GetLedgerController(req, res) {
    try {
        // Validate required fields
        if (!req.body.accountID) {
            return res.status(400).json({ error: "accountID is required" });
        }
        // Validate and set default values for optional fields
        const numRows = req.body.numRows ? parseInt(req.body.numRows) : 10;
        const startRow = req.body.startRow ? parseInt(req.body.startRow) : 0;
        if (isNaN(numRows) || isNaN(startRow) || numRows < 1 || startRow < 0) {
            return res.status(400).json({ error: "Invalid numRows or startRow" });
        }
        const responseData = await (0, GetLedger_1.GetLedgerService)(req.body.accountID, numRows, startRow);
        res.json(responseData);
    }
    catch (err) {
        console.error("Error in GetLedgerController:", err);
        res.status(500).json({ error: "Internal server error" });
    }
}
//# sourceMappingURL=getLedger.js.map


File: build/src/api/Credex/controllers/offerCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfferCredexController = OfferCredexController;
const OfferCredex_1 = require("../services/OfferCredex");
const GetAccountDashboard_1 = require("../../Account/services/GetAccountDashboard");
const denominations_1 = require("../../../constants/denominations");
const credspan_1 = require("../../../constants/credspan");
const credexTypes_1 = require("../../../constants/credexTypes");
const securedCredexAuthForTier_1 = require("../../Member/controllers/securedCredexAuthForTier");
const neo4j_1 = require("../../../../config/neo4j");
/**
 * OfferCredexController
 *
 * This controller handles the creation of new Credex offers.
 * It validates the required fields, performs additional validations,
 * calls the OfferCredexService, and returns the result along with updated dashboard data.
 *
 * @param req - Express request object
 * @param res - Express response object
 */
async function OfferCredexController(req, res) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        // Validate required fields
        const fieldsRequired = [
            "memberID",
            "issuerAccountID",
            "receiverAccountID",
            "Denomination",
            "InitialAmount",
            "credexType",
            "OFFERSorREQUESTS",
        ];
        for (const field of fieldsRequired) {
            if (!req.body[field]) {
                return res.status(400).json({ error: `${field} is required` });
            }
        }
        const { memberID, issuerAccountID, receiverAccountID, Denomination, InitialAmount, credexType, OFFERSorREQUESTS, securedCredex = false, dueDate = "", } = req.body;
        // Check if issuerAccountID and receiverAccountID are the same
        if (issuerAccountID === receiverAccountID) {
            return res.status(400).json({ error: "Issuer and receiver cannot be the same account" });
        }
        // Validate InitialAmount is a number
        if (typeof InitialAmount !== "number") {
            return res.status(400).json({ error: "InitialAmount must be a number" });
        }
        // Check denomination validity
        if (!(0, denominations_1.getDenominations)({ code: Denomination }).length) {
            return res.status(400).json({ error: "Invalid denomination" });
        }
        // Check credex type validity
        if (!(0, credexTypes_1.checkPermittedCredexType)(credexType)) {
            return res.status(400).json({ error: "Invalid credex type" });
        }
        // Validate OFFERSorREQUESTS
        if (OFFERSorREQUESTS !== "OFFERS" && OFFERSorREQUESTS !== "REQUESTS") {
            return res.status(400).json({ error: "Invalid OFFER/REQUEST value" });
        }
        // Check due date for unsecured credex
        if (!securedCredex) {
            if (!dueDate) {
                return res.status(400).json({ error: "Unsecured credex must have a due date" });
            }
            const dueDateOK = await (0, credspan_1.checkDueDate)(dueDate);
            if (!dueDateOK) {
                return res.status(400).json({
                    error: `Due date must be permitted date, in format YYYY-MM-DD. First permitted due date is 1 week from today. Last permitted due date is ${credspan_1.credspan / 7} weeks from today.`
                });
            }
        }
        else if (dueDate) {
            return res.status(400).json({ error: "Secured credex cannot have a due date" });
        }
        // Check secured credex limits based on membership tier
        if (securedCredex) {
            const getMemberTier = await ledgerSpaceSession.run(`
          MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
          RETURN member.memberTier as memberTier
        `, { issuerAccountID });
            const memberTier = getMemberTier.records[0].get("memberTier");
            const tierAuth = await (0, securedCredexAuthForTier_1.SecuredCredexAuthForTierController)(issuerAccountID, memberTier, InitialAmount, Denomination);
            if (!tierAuth.isAuthorized) {
                return res.status(400).json({ error: tierAuth.message });
            }
        }
        // Check if unsecured credex is permitted on membership tier
        if (!securedCredex) {
            const getMemberTier = await ledgerSpaceSession.run(`
          MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
          RETURN member.memberTier as memberTier
        `, { issuerAccountID });
            const memberTier = getMemberTier.records[0].get("memberTier");
            if (memberTier == 1) {
                return res.status(400).json({ error: "Members on the Open Tier cannot issue unsecured credexes" });
            }
        }
        // Call OfferCredexService to create the Credex offer
        const offerCredexData = await (0, OfferCredex_1.OfferCredexService)(req.body);
        if (!offerCredexData || typeof offerCredexData.credex === 'boolean') {
            return res.status(400).json({ error: offerCredexData.message || "Failed to create Credex offer" });
        }
        // Fetch updated dashboard data
        const dashboardData = await (0, GetAccountDashboard_1.GetAccountDashboardService)(memberID, issuerAccountID);
        if (!dashboardData) {
            return res.status(404).json({ error: "Failed to fetch dashboard data" });
        }
        // Return the offer data and updated dashboard data
        return res.status(200).json({
            offerCredexData: offerCredexData,
            dashboardData: dashboardData,
        });
    }
    catch (err) {
        console.error("Error in OfferCredexController:", err);
        return res.status(500).json({ error: "Internal server error" });
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=offerCredex.js.map


File: build/src/api/Credex/credexRoutes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CredexRoutes;
const index_1 = require("../../index");
const offerCredex_1 = require("./controllers/offerCredex");
const acceptCredex_1 = require("./controllers/acceptCredex");
const acceptCredexBulk_1 = require("./controllers/acceptCredexBulk");
const declineCredex_1 = require("./controllers/declineCredex");
const cancelCredex_1 = require("./controllers/cancelCredex");
const getCredex_1 = require("./controllers/getCredex");
const getLedger_1 = require("./controllers/getLedger");
function CredexRoutes(app, jsonParser) {
    /**
     * @swagger
     * /api/v1/offerCredex:
     *   post:
     *     summary: Offer a new Credex
     *     tags: [Credex]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - memberID
     *               - issuerAccountID
     *               - receiverAccountID
     *               - Denomination
     *               - InitialAmount
     *             properties:
     *               memberID:
     *                 type: string
     *               issuerAccountID:
     *                 type: string
     *               receiverAccountID:
     *                 type: string
     *               Denomination:
     *                 type: string
     *               InitialAmount:
     *                 type: number
     *               credexType:
     *                 type: string
     *               securedCredex:
     *                 type: boolean
     *               dueDate:
     *                 type: string
     *                 format: date
     *     responses:
     *       200:
     *         description: Credex offered successfully
     *       400:
     *         description: Bad request
     */
    app.post(`${index_1.apiVersionOneRoute}offerCredex`, jsonParser, offerCredex_1.OfferCredexController);
    /**
     * @swagger
     * /api/v1/acceptCredex:
     *   put:
     *     summary: Accept a Credex offer
     *     tags: [Credex]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - credexID
     *               - signerID
     *             properties:
     *               credexID:
     *                 type: string
     *               signerID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Credex accepted successfully
     *       400:
     *         description: Bad request
     */
    app.put(`${index_1.apiVersionOneRoute}acceptCredex`, jsonParser, acceptCredex_1.AcceptCredexController);
    /**
     * @swagger
     * /api/v1/acceptCredexBulk:
     *   put:
     *     summary: Accept multiple Credex offers in bulk
     *     tags: [Credex]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - credexIDs
     *               - signerID
     *             properties:
     *               credexIDs:
     *                 type: array
     *                 items:
     *                   type: string
     *               signerID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Credexes accepted successfully
     *       400:
     *         description: Bad request
     */
    app.put(`${index_1.apiVersionOneRoute}acceptCredexBulk`, jsonParser, acceptCredexBulk_1.AcceptCredexBulkController);
    /**
     * @swagger
     * /api/v1/declineCredex:
     *   put:
     *     summary: Decline a Credex offer
     *     tags: [Credex]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - credexID
     *             properties:
     *               credexID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Credex declined successfully
     *       400:
     *         description: Bad request
     */
    app.put(`${index_1.apiVersionOneRoute}declineCredex`, jsonParser, declineCredex_1.DeclineCredexController);
    /**
     * @swagger
     * /api/v1/cancelCredex:
     *   put:
     *     summary: Cancel a Credex offer
     *     tags: [Credex]
     *     requestBody:
     *       required: true
     *       content:
     *         application/json:
     *           schema:
     *             type: object
     *             required:
     *               - credexID
     *             properties:
     *               credexID:
     *                 type: string
     *     responses:
     *       200:
     *         description: Credex cancelled successfully
     *       400:
     *         description: Bad request
     */
    app.put(`${index_1.apiVersionOneRoute}cancelCredex`, jsonParser, cancelCredex_1.CancelCredexController);
    /**
     * @swagger
     * /api/v1/getCredex:
     *   get:
     *     summary: Get Credex details
     *     tags: [Credex]
     *     parameters:
     *       - in: query
     *         name: credexID
     *         required: true
     *         schema:
     *           type: string
     *       - in: query
     *         name: accountID
     *         required: true
     *         schema:
     *           type: string
     *     responses:
     *       200:
     *         description: Credex details retrieved successfully
     *       400:
     *         description: Bad request
     *       404:
     *         description: Credex not found
     */
    app.get(`${index_1.apiVersionOneRoute}getCredex`, jsonParser, getCredex_1.GetCredexController);
    /**
     * @swagger
     * /api/v1/getLedger:
     *   get:
     *     summary: Get account ledger
     *     tags: [Credex]
     *     parameters:
     *       - in: query
     *         name: accountID
     *         required: true
     *         schema:
     *           type: string
     *       - in: query
     *         name: numRows
     *         schema:
     *           type: integer
     *       - in: query
     *         name: startRow
     *         schema:
     *           type: integer
     *     responses:
     *       200:
     *         description: Ledger retrieved successfully
     *       400:
     *         description: Bad request
     */
    app.get(`${index_1.apiVersionOneRoute}getLedger`, jsonParser, getLedger_1.GetLedgerController);
}
//# sourceMappingURL=credexRoutes.js.map


File: build/src/api/Credex/services/GetLedger.js
----------------------------------------
"use strict";
/*

returns details to display a ledger list of transactions

requires:
  accountID

requires (with defaults if not included)
  numRows (number of transactions to return, default is 10)
  startRow (number of row to start at, for pagination, default is first row)

returns for each credex:
  credexID
  formattedInitialAmount (string eg 8,546.32 USD)
  counterpartyDisplayname

returns empty array if no credexes

returns error message if numRows or startRows can't be coerced into numbers
returns empty array if accountID not valid

*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetLedgerService = GetLedgerService;
const neo4j = __importStar(require("neo4j-driver"));
const neo4j_1 = require("../../../../config/neo4j");
const denomUtils_1 = require("../../../utils/denomUtils");
async function GetLedgerService(accountID, numRows = 10, startRow = 0) {
    numRows = Math.round(Number(numRows));
    startRow = Math.round(Number(startRow));
    if (Number.isNaN(numRows) || Number.isNaN(startRow)) {
        return "numRows and startRows must be numbers";
    }
    try {
        const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
        const result = await ledgerSpaceSession.run(`
        OPTIONAL MATCH
            (account:Account{accountID:$accountID})-[transactionType:OWES|CLEARED]-(credex:Credex)-[:OWES|CLEARED]-(counterparty:Account)
        OPTIONAL MATCH (credex)<-[:SECURES]-(securer:Account)
        RETURN
            credex.credexID AS credexID,
            credex.InitialAmount/credex.CXXmultiplier AS InitialAmount,
            credex.Denomination AS Denomination,
            (startNode(transactionType) = account) as debit,
            counterparty.accountName AS counterpartyAccountName
            ORDER BY credex.acceptedAt
            SKIP $startRow
            LIMIT $numRows
    `, {
            accountID: accountID,
            numRows: neo4j.int(numRows),
            startRow: neo4j.int(startRow),
        });
        await ledgerSpaceSession.close();
        if (!result.records[0].get("credexID")) {
            return {};
        }
        const credexes = result.records.map((record) => {
            const credexID = record.get("credexID");
            const InitialAmount = record.get("debit")
                ? -parseFloat(record.get("InitialAmount"))
                : record.get("InitialAmount");
            const Denomination = record.get("Denomination");
            const counterpartyAccountName = record.get("counterpartyAccountName");
            const formattedInitialAmount = (0, denomUtils_1.denomFormatter)(InitialAmount, Denomination) + " " + Denomination;
            return {
                credexID,
                formattedInitialAmount,
                counterpartyAccountName,
            };
        });
        return credexes;
    }
    catch (error) {
        console.error("Error in GetLedgerService:", error);
        throw error;
    }
}
//# sourceMappingURL=GetLedger.js.map


File: build/src/api/Credex/services/AcceptCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcceptCredexService = AcceptCredexService;
const neo4j_1 = require("../../../../config/neo4j");
/**
 * AcceptCredexService
 *
 * This service handles the acceptance of a Credex offer.
 * It updates the Credex status from OFFERS to OWES and signs the acceptance.
 *
 * @param credexID - The ID of the Credex to be accepted
 * @param signerID - The ID of the Member or Avatar signing the acceptance
 * @returns An object with the accepted Credex details or null if the operation fails
 * @throws Error if there's an issue with the database operation
 */
async function AcceptCredexService(credexID, signerID) {
    if (!credexID || !signerID) {
        console.error("AcceptCredexService: credexID and signerID are required");
        return null;
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.executeWrite(async (tx) => {
            const query = `
        MATCH
          (issuer:Account)-[rel1:OFFERS]->
          (acceptedCredex:Credex {credexID: $credexID})-[rel2:OFFERS]->
          (acceptor:Account)<-[:AUTHORIZED_FOR]-
          (signer:Member|Avatar { memberID: $signerID })
        DELETE rel1, rel2
        CREATE (issuer)-[:OWES]->(acceptedCredex)-[:OWES]->(acceptor)
        CREATE (acceptedCredex)<-[:SIGNED]-(signer)
        SET acceptedCredex.acceptedAt = datetime()
        RETURN
          acceptedCredex.credexID AS credexID,
          acceptor.accountID AS acceptorAccountID,
          signer.memberID AS signerID
      `;
            const queryResult = await tx.run(query, { credexID, signerID });
            if (queryResult.records.length === 0) {
                console.warn(`No records found or credex no longer pending for credexID: ${credexID}`);
                return null;
            }
            const record = queryResult.records[0];
            return {
                acceptedCredexID: record.get('credexID'),
                acceptorAccountID: record.get('acceptorAccountID'),
                acceptorSignerID: record.get('signerID')
            };
        });
        if (result) {
            console.log(`Offer accepted for credexID: ${result.acceptedCredexID}`);
            // TODO: Implement credex accepted notification here
        }
        return result;
    }
    catch (error) {
        console.error(`Error accepting credex for credexID ${credexID}:`, error);
        throw new Error(`Failed to accept Credex: ${error.message}`);
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=AcceptCredex.js.map


File: build/src/api/Credex/services/OfferCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfferCredexService = OfferCredexService;
const CreateCredex_1 = require("./CreateCredex");
const neo4j_1 = require("../../../../config/neo4j");
/**
 * OfferCredexService
 *
 * This service handles the creation of a new Credex offer.
 * It uses the CreateCredexService to create the Credex and then
 * signs the offer and prepares it for notification.
 *
 * @param credexData - An object containing the data for the new Credex
 * @returns The result of the Credex offer creation
 */
async function OfferCredexService(credexData) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        // Set default values for the Credex
        credexData.OFFERSorREQUESTS = "OFFERS";
        credexData.credexType = credexData.credexType || "PURCHASE";
        // Create the new Credex
        const newCredex = await (0, CreateCredex_1.CreateCredexService)(credexData);
        if (typeof newCredex.credex === "boolean" || !newCredex.credex?.credexID) {
            throw new Error("Failed to create Credex");
        }
        // Sign the Credex and prepare for notification
        const signResult = await signCredex(ledgerSpaceSession, newCredex.credex.credexID, credexData.memberID);
        if (!signResult) {
            console.warn("Failed to sign Credex, but Credex was created successfully");
        }
        // TODO: Implement offer notification here
        console.log(newCredex.message);
        return newCredex;
    }
    catch (error) {
        console.error("Error offering credex:", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
async function signCredex(session, credexID, signingMemberID) {
    try {
        const signQuery = await session.run(`
      MATCH
        (credex:Credex { credexID: $credexID })<-[:OFFERS]-
        (Account)<-[:AUTHORIZED_FOR]-
        (signer:Member|Avatar { memberID: $signingMemberID })
      CREATE (credex)<-[:SIGNED]-(signer)
      RETURN signer.memberID AS signerID
      `, { credexID, signingMemberID });
        return signQuery.records.length > 0;
    }
    catch (error) {
        console.error("Error signing Credex:", error);
        return false;
    }
}
//# sourceMappingURL=OfferCredex.js.map


File: build/src/api/Credex/services/DeclineCredex.js
----------------------------------------
"use strict";
/*
marks a credex as declined by changing the relationships
from OFFERS or REQUESTS to DECLINED

required inputs:
  credexID

on success returns credexID

will return false if:
  credexID not found
  credex does not have OFFERS or REQUESTS relationships (credex already accepted/declined/cancelled)
    
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeclineCredexService = DeclineCredexService;
const neo4j_1 = require("../../../../config/neo4j");
async function DeclineCredexService(credexID) {
    try {
        const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
        const result = await ledgerSpaceSession.run(`
        MATCH (issuer:Account)-[rel1:OFFERS|REQUESTS]->(credex:Credex{credexID:$credexID})-[rel2:OFFERS|REQUESTS]->(acceptor:Account)
        DELETE rel1, rel2
        CREATE (issuer)-[:DECLINED]->(credex)-[:DECLINED]->(acceptor)
        WITH credex
        SET
            credex.declinedAt = Datetime(),
            credex.OutstandingAmount = 0,
            credex.queueStatus = "PROCESSED"
        RETURN credex.credexID AS credexID
    `, { credexID });
        await ledgerSpaceSession.close();
        if (result.records.length === 0) {
            console.log(`No records found or credex no longer pending for credexID: ${credexID}`);
            return false;
        }
        const declinedCredexID = result.records[0].get("credexID");
        console.log(`Offer declined for credexID: ${declinedCredexID}`);
        return declinedCredexID;
    }
    catch (error) {
        console.log(error);
    }
}
//# sourceMappingURL=DeclineCredex.js.map


File: build/src/api/Credex/services/GetCredex.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetCredexService = GetCredexService;
const neo4j_1 = require("../../../../config/neo4j");
const denomUtils_1 = require("../../../utils/denomUtils");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
async function GetCredexService(credexID, accountID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`
        MATCH
        (account:Account {accountID: $accountID})-[transactionType:OWES|CLEARED|REQUESTS|OFFERS|DECLINED|CANCELLED]-(credex:Credex {credexID: $credexID})-[:OWES|CLEARED|REQUESTS|OFFERS|DECLINED|CANCELLED]-(counterparty:Account)
        OPTIONAL MATCH (credex)<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH (credex)-[credloopRel:CREDLOOP]-(clearedAgainstCredex:Credex)-[:OWES|CLEARED]-(account), (clearedAgainstCredex)-[:OWES|CLEARED]-(clearedAgainstCounterparty:Account)
        RETURN
        credex.credexID AS credexID,
        type(transactionType) AS transactionType,
        (startNode(transactionType) = account) AS debit,
        counterparty.accountName AS counterpartyAccountName,
        securer.accountID AS securerID,
        securer.accountName AS securerName,
        credex.Denomination AS Denomination,
        credex.InitialAmount / credex.CXXmultiplier AS InitialAmount,
        credex.OutstandingAmount / credex.CXXmultiplier AS OutstandingAmount,
        credex.RedeemedAmount / credex.CXXmultiplier AS RedeemedAmount,
        credex.DefaultedAmount / credex.CXXmultiplier AS DefaultedAmount,
        credex.WrittenOffAmount / credex.CXXmultiplier AS WrittenOffAmount,
        credex.acceptedAt AS acceptedAt,
        credex.declinedAt AS declinedAt,
        credex.cancelledAt AS cancelledAt,
        credex.dueDate AS dueDate,
        clearedAgainstCredex.credexID AS clearedAgainstCredexID,
        credloopRel.AmountRedeemed / credloopRel.CXXmultiplier AS clearedAmount,
        clearedAgainstCredex.InitialAmount / clearedAgainstCredex.CXXmultiplier AS clearedAgainstCredexInitialAmount,
        clearedAgainstCredex.Denomination AS clearedAgainstCredexDenomination,
        clearedAgainstCounterparty.accountName AS clearedAgainstCounterpartyAccountName
      `, { credexID, accountID });
        if (result.records.length === 0) {
            throw new Error("No records found");
        }
        const record = result.records[0];
        const debit = record.get("debit");
        const amounts = [
            "InitialAmount",
            "OutstandingAmount",
            "RedeemedAmount",
            "DefaultedAmount",
            "WrittenOffAmount",
        ].reduce((acc, amount) => {
            const value = parseFloat(record.get(amount));
            acc[amount] = debit ? -value : value;
            return acc;
        }, {
            InitialAmount: 0,
            OutstandingAmount: 0,
            RedeemedAmount: 0,
            DefaultedAmount: 0,
            WrittenOffAmount: 0,
        });
        const Denomination = record.get("Denomination");
        const formattedAmounts = Object.entries(amounts).reduce((acc, [key, value]) => {
            acc[`formatted${key}`] = `${(0, denomUtils_1.denomFormatter)(value, Denomination)} ${Denomination}`;
            return acc;
        }, {});
        const acceptedAt = (0, moment_timezone_1.default)(record.get("acceptedAt"))
            .subtract(1, "month")
            .format("YYYY-MM-DD");
        const declinedAt = (0, moment_timezone_1.default)(record.get("declinedAt"))
            .subtract(1, "month")
            .format("YYYY-MM-DD");
        const cancelledAt = (0, moment_timezone_1.default)(record.get("cancelledAt"))
            .subtract(1, "month")
            .format("YYYY-MM-DD");
        const dueDate = (0, moment_timezone_1.default)(record.get("dueDate"))
            .subtract(1, "month")
            .format("YYYY-MM-DD");
        const counterpartyAccountName = record.get("counterpartyAccountName");
        const credexData = {
            credexID: record.get("credexID"),
            transactionType: record.get("transactionType"),
            debit,
            counterpartyAccountName,
            securerID: record.get("securerID"),
            securerName: record.get("securerName"),
            Denomination,
            acceptedAt: acceptedAt,
            declinedAt: declinedAt,
            cancelledAt: cancelledAt,
            dueDate: dueDate,
            ...formattedAmounts,
        };
        const clearedAgainstData = result.records
            .filter((record) => record.get("clearedAgainstCredexID"))
            .map((record) => {
            const clearedAmount = record.get("clearedAmount");
            const clearedAgainstCredexInitialAmount = parseFloat(record.get("clearedAgainstCredexInitialAmount"));
            const signumClearedAgainstCredexInitialAmount = debit
                ? clearedAgainstCredexInitialAmount
                : -clearedAgainstCredexInitialAmount;
            const clearedAgainstCredexDenomination = record.get("clearedAgainstCredexDenomination");
            const clearedAgainstCounterpartyAccountName = record.get("clearedAgainstCounterpartyAccountName");
            return {
                clearedAgainstCredexID: record.get("clearedAgainstCredexID"),
                formattedClearedAmount: `${(0, denomUtils_1.denomFormatter)(clearedAmount, clearedAgainstCredexDenomination)} ${clearedAgainstCredexDenomination}`,
                formattedClearedAgainstCredexInitialAmount: `${(0, denomUtils_1.denomFormatter)(signumClearedAgainstCredexInitialAmount, clearedAgainstCredexDenomination)} ${clearedAgainstCredexDenomination}`,
                clearedAgainstCounterpartyAccountName,
            };
        });
        return { credexData, clearedAgainstData };
    }
    catch (error) {
        console.error("Error in GetCredexService:", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetCredex.js.map


File: build/src/api/Credex/services/CreateCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateCredexService = CreateCredexService;
const neo4j_1 = require("../../../../config/neo4j");
const denomUtils_1 = require("../../../utils/denomUtils");
const GetSecuredAuthorization_1 = require("./GetSecuredAuthorization");
async function CreateCredexService(credexData) {
    const { issuerAccountID, receiverAccountID, InitialAmount, Denomination, credexType, OFFERSorREQUESTS, securedCredex = false, dueDate = "", } = credexData;
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    let OFFEREDorREQUESTED = OFFERSorREQUESTS === "OFFERS" ? "OFFERED" : "REQUESTED";
    try {
        // Get securable data for secured credex
        let secureableData = { securerID: "", securableAmountInDenom: 0 };
        if (securedCredex) {
            secureableData = await (0, GetSecuredAuthorization_1.GetSecuredAuthorizationService)(issuerAccountID, Denomination);
            if (secureableData.securableAmountInDenom < InitialAmount) {
                return {
                    credex: false,
                    message: `Error: Your secured credex for ${(0, denomUtils_1.denomFormatter)(InitialAmount, Denomination)} ${Denomination} cannot be issued because your maximum securable ${Denomination} balance is ${(0, denomUtils_1.denomFormatter)(secureableData.securableAmountInDenom, Denomination)} ${Denomination}`,
                };
            }
        }
        // Create the credex
        const createCredexQuery = await ledgerSpaceSession.run(`
        MATCH (daynode:Daynode {Active: true})
        MATCH (issuer:Account {accountID: $issuerAccountID})
        MATCH (receiver:Account {accountID: $receiverAccountID})
        CREATE (newCredex:Credex)
        SET
          newCredex.credexID = randomUUID(),
          newCredex.Denomination = $Denomination,
          newCredex.CXXmultiplier = daynode[$Denomination],
          newCredex.InitialAmount = $InitialAmount * daynode[$Denomination],
          newCredex.OutstandingAmount = $InitialAmount * daynode[$Denomination],
          newCredex.RedeemedAmount = 0,
          newCredex.DefaultedAmount = 0,
          newCredex.WrittenOffAmount = 0,
          newCredex.credexType = $credexType,
          newCredex.createdAt = datetime(),
          newCredex.queueStatus = "PENDING_CREDEX"
        MERGE (newCredex)-[:CREATED_ON]->(daynode)
        MERGE (issuer)-[:${OFFERSorREQUESTS}]->(newCredex)-[:${OFFERSorREQUESTS}]->(receiver)
        MERGE (issuer)-[:${OFFEREDorREQUESTED}]->(newCredex)-[:${OFFEREDorREQUESTED}]->(receiver)
        RETURN
          newCredex.credexID AS credexID,
          receiver.accountName AS receiverAccountName
      `, {
            issuerAccountID,
            receiverAccountID,
            InitialAmount,
            Denomination,
            credexType,
        });
        const credexID = createCredexQuery.records[0].get("credexID");
        // Add dueDate for unsecured credex
        if (!securedCredex) {
            const addDueDateQuery = await ledgerSpaceSession.run(`
          MATCH (newCredex:Credex {credexID: $credexID})
          SET newCredex.dueDate = date($dueDate)
          RETURN newCredex.dueDate AS dueDate
        `, {
                credexID,
                dueDate,
            });
            if (addDueDateQuery.records.length === 0) {
                return { credex: false, message: "error creating credex" };
            }
        }
        // Add secured relationships for secured credex
        if (securedCredex && secureableData.securerID) {
            await ledgerSpaceSession.run(`
          MATCH (newCredex:Credex {credexID: $credexID})
          MATCH (securingAccount: Account {accountID: $securingAccountID})
          MERGE (securingAccount)-[:SECURES]->(newCredex)
        `, {
                credexID,
                securingAccountID: secureableData.securerID,
            });
        }
        const newCredex = {
            credexID: createCredexQuery.records[0].get("credexID"),
            formattedInitialAmount: (0, denomUtils_1.denomFormatter)(InitialAmount, Denomination),
            counterpartyAccountName: createCredexQuery.records[0].get("receiverAccountName"),
            secured: securedCredex,
            dueDate: dueDate,
        };
        return {
            credex: newCredex,
            message: "Credex created: " + newCredex.credexID,
        };
    }
    catch (error) {
        return { credex: false, message: "Error creating credex: " + error };
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=CreateCredex.js.map


File: build/src/api/Credex/services/CancelCredex.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CancelCredexService = CancelCredexService;
const neo4j_1 = require("../../../../config/neo4j");
/**
 * CancelCredexService
 *
 * This service handles the cancellation of a Credex offer or request.
 * It changes the relationships from OFFERS or REQUESTS to CANCELLED.
 *
 * @param credexID - The ID of the Credex to be cancelled
 * @returns The ID of the cancelled Credex or null if the operation fails
 * @throws Error if there's an issue with the database operation
 */
async function CancelCredexService(credexID) {
    if (!credexID) {
        console.error("CancelCredexService: credexID is required");
        return null;
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.executeWrite(async (tx) => {
            const query = `
        MATCH (issuer:Account)-[rel1:OFFERS|REQUESTS]->(credex:Credex {credexID: $credexID})-[rel2:OFFERS|REQUESTS]->(acceptor:Account)
        WHERE credex.queueStatus <> "PROCESSED"
        DELETE rel1, rel2
        CREATE (issuer)-[:CANCELLED]->(credex)-[:CANCELLED]->(acceptor)
        SET
          credex.cancelledAt = datetime(),
          credex.OutstandingAmount = 0,
          credex.queueStatus = "PROCESSED"
        RETURN credex.credexID AS credexID
      `;
            const queryResult = await tx.run(query, { credexID });
            if (queryResult.records.length === 0) {
                console.warn(`No records found or credex no longer pending for credexID: ${credexID}`);
                return null;
            }
            return queryResult.records[0].get("credexID");
        });
        if (result) {
            console.log(`Credex cancelled successfully: ${result}`);
        }
        return result;
    }
    catch (error) {
        console.error(`Error cancelling credex for credexID ${credexID}:`, error);
        throw new Error(`Failed to cancel Credex: ${error.message}`);
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=CancelCredex.js.map


File: build/src/api/Credex/services/GetPendingOffersOut.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetPendingOffersOutService = GetPendingOffersOutService;
const neo4j_1 = require("../../../../config/neo4j");
const denomUtils_1 = require("../../../utils/denomUtils");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
async function GetPendingOffersOutService(accountID) {
    try {
        const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
        const result = await ledgerSpaceSession.run(`
        OPTIONAL MATCH
          (account:Account{accountID:$accountID})-[:OFFERS]->(offersOutCredex:Credex)-[:OFFERS]->(counterparty:Account)
        OPTIONAL MATCH
          (offersOutCredex)<-[:SECURES]-(securer:Account)
        RETURN
          offersOutCredex.InitialAmount / offersOutCredex.CXXmultiplier AS InitialAmount,
          offersOutCredex.credexID AS credexID,
          offersOutCredex.Denomination AS Denomination,
          offersOutCredex.dueDate AS dueDate,
          counterparty.accountName AS counterpartyAccountName,
          securer IS NOT NULL as secured
      `, { accountID });
        await ledgerSpaceSession.close();
        if (!result.records[0].get("credexID")) {
            return {};
        }
        const offeredCredexData = [];
        for (const record of result.records) {
            const formattedInitialAmount = (0, denomUtils_1.denomFormatter)(parseFloat("-" + record.get("InitialAmount")), record.get("Denomination")) +
                " " +
                record.get("Denomination");
            const thisOfferedCredex = {
                credexID: record.get("credexID"),
                formattedInitialAmount: formattedInitialAmount,
                counterpartyAccountName: record.get("counterpartyAccountName"),
            };
            if (record.get("dueDate")) {
                thisOfferedCredex.dueDate = (0, moment_timezone_1.default)(record.get("dueDate"))
                    .subtract(1, "months") //because moment uses Jan = 0 and neo4j uses Jan = 1
                    .format("YYYY-MM-DD");
            }
            if (record.get("secured")) {
                thisOfferedCredex.secured = record.get("secured");
            }
            offeredCredexData.push(thisOfferedCredex);
        }
        return offeredCredexData;
    }
    catch (error) {
        console.error("Error in GetPendingOffersOutService:", error);
        throw error;
    }
}
//# sourceMappingURL=GetPendingOffersOut.js.map


File: build/src/api/Credex/services/GetSecuredAuthorization.js
----------------------------------------
"use strict";
/*
returns information on a account's secured balance

required inputs:
  issuerAccountID,
  Denomination,

returns:
  securerID (null if no secured balances available or error)
  securableAmountInDenom (0 if no secured balances or error, infinity if CREDEX_FOUNDATION_AUDITED)
    
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetSecuredAuthorizationService = GetSecuredAuthorizationService;
const neo4j_1 = require("../../../../config/neo4j");
async function GetSecuredAuthorizationService(issuerAccountID, Denomination) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    // Check if issuer is CREDEX_FOUNDATION_AUDITED
    const isFoundationAuditedQuery = await ledgerSpaceSession.run(`
      OPTIONAL MATCH
        (issuer:Account { accountID: $issuerAccountID })
        <-[:CREDEX_FOUNDATION_AUDITED]-
        (credexFoundation:Account { accountType: "CREDEX_FOUNDATION" })
      RETURN issuer IS NOT NULL AS isAudited
    `, { issuerAccountID });
    const record = isFoundationAuditedQuery.records[0];
    const isAudited = record ? record.get("isAudited") : false;
    // If the issuer is CREDEX_FOUNDATION_AUDITED, authorize for unlimited secured credex issuance
    if (isAudited) {
        await ledgerSpaceSession.close();
        return {
            securerID: issuerAccountID,
            securableAmountInDenom: Infinity,
        };
    }
    // If issuer is not CREDEX_FOUNDATION_AUDITED, verify the available secured balance in denom
    const getSecurableDataQuery = await ledgerSpaceSession.run(`
      MATCH (account:Account {accountID: $accountID})
      OPTIONAL MATCH (account)-[transactionType:OWES|OFFERS]-(credex:Credex)<-[:SECURES]-(securer:Account)
      WHERE credex.Denomination = $Denomination
      WITH
        securer.accountID AS securingAccountID,
        SUM(CASE WHEN endNode(transactionType) = account THEN credex.OutstandingAmount ELSE 0 END) -
        SUM(CASE WHEN startNode(transactionType) = account THEN credex.OutstandingAmount ELSE 0 END)
        AS netSecurablePerSecurerCXX
      MATCH (daynode:Daynode {Active: true})
      RETURN
        securingAccountID,
        netSecurablePerSecurerCXX / daynode[$Denomination] AS netSecurableInDenom
        ORDER BY netSecurableInDenom DESC
        LIMIT 1
    `, {
        accountID: issuerAccountID,
        Denomination: Denomination,
    });
    await ledgerSpaceSession.close();
    const securableRecord = getSecurableDataQuery.records[0];
    if (!securableRecord || securableRecord.length === 0) {
        return {
            securerID: null,
            securableAmountInDenom: 0,
        };
    }
    console.log({
        securerID: securableRecord.get("securingAccountID"),
        securableAmountInDenom: securableRecord.get("netSecurableInDenom"),
    });
    return {
        securerID: securableRecord.get("securingAccountID"),
        securableAmountInDenom: securableRecord.get("netSecurableInDenom"),
    };
}
//# sourceMappingURL=GetSecuredAuthorization.js.map


File: build/src/api/Credex/services/GetPendingOffersIn.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetPendingOffersInService = GetPendingOffersInService;
const neo4j_1 = require("../../../../config/neo4j");
const denomUtils_1 = require("../../../utils/denomUtils");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
async function GetPendingOffersInService(accountID) {
    try {
        const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
        const result = await ledgerSpaceSession.run(`
        OPTIONAL MATCH
          (account:Account{accountID:$accountID})<-[:OFFERS]-(offersInCredex:Credex)<-[:OFFERS]-(counterparty:Account)
        OPTIONAL MATCH
          (offersInCredex)<-[:SECURES]-(securer:Account)
        RETURN
          offersInCredex.InitialAmount / offersInCredex.CXXmultiplier AS InitialAmount,
          offersInCredex.credexID AS credexID,
          offersInCredex.Denomination AS Denomination,
          offersInCredex.dueDate AS dueDate,
          counterparty.accountName AS counterpartyAccountName,
          securer IS NOT NULL as secured
      `, { accountID });
        await ledgerSpaceSession.close();
        if (!result.records[0].get("credexID")) {
            return {};
        }
        const offeredCredexData = [];
        for (const record of result.records) {
            const formattedInitialAmount = (0, denomUtils_1.denomFormatter)(record.get("InitialAmount"), record.get("Denomination")) +
                " " +
                record.get("Denomination");
            const thisOfferedCredex = {
                credexID: record.get("credexID"),
                formattedInitialAmount: formattedInitialAmount,
                counterpartyAccountName: record.get("counterpartyAccountName"),
            };
            if (record.get("dueDate")) {
                thisOfferedCredex.dueDate = (0, moment_timezone_1.default)(record.get("dueDate"))
                    .subtract(1, "months") //because moment uses Jan = 0 and neo4j uses Jan = 1
                    .format("YYYY-MM-DD");
            }
            if (record.get("secured")) {
                thisOfferedCredex.secured = record.get("secured");
            }
            offeredCredexData.push(thisOfferedCredex);
        }
        return offeredCredexData;
    }
    catch (error) {
        console.error("Error in GetPendingOffersInService:", error);
        throw error;
    }
}
//# sourceMappingURL=GetPendingOffersIn.js.map


File: build/src/api/Member/controllers/getMemberByHandle.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMemberByHandleController = GetMemberByHandleController;
const GetMemberByHandle_1 = require("../services/GetMemberByHandle");
const logger_1 = __importDefault(require("../../../../config/logger"));
const validators_1 = require("../../../utils/validators");
async function GetMemberByHandleController(req, res, next) {
    const { memberHandle } = req.body;
    try {
        if (!memberHandle || typeof memberHandle !== 'string') {
            res.status(400).json({ message: "memberHandle is required and must be a string" });
            return;
        }
        if (!(0, validators_1.validateMemberHandle)(memberHandle)) {
            res.status(400).json({
                message: "Invalid member handle. Only lowercase letters, numbers, periods, and underscores are allowed. Length must be between 3 and 30 characters.",
            });
            return;
        }
        logger_1.default.info("Retrieving member by handle", { memberHandle });
        const memberData = await (0, GetMemberByHandle_1.GetMemberByHandleService)(memberHandle);
        if (memberData) {
            logger_1.default.info("Member retrieved successfully", { memberHandle });
            res.status(200).json({ memberData });
        }
        else {
            logger_1.default.info("Member not found", { memberHandle });
            res.status(404).json({ message: "Member not found" });
        }
    }
    catch (error) {
        logger_1.default.error("Error in GetMemberByHandleController", { error, memberHandle });
        next(error);
    }
}
//# sourceMappingURL=getMemberByHandle.js.map


File: build/src/api/Member/controllers/onboardMember.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnboardMemberController = OnboardMemberController;
exports.onboardMemberExpressHandler = onboardMemberExpressHandler;
const OnboardMember_1 = require("../services/OnboardMember");
const GetMemberDashboardByPhone_1 = require("../services/GetMemberDashboardByPhone");
const logger_1 = __importDefault(require("../../../../config/logger"));
const validators_1 = require("../../../utils/validators");
function validateInput(firstname, lastname, phone) {
    if (!firstname || !lastname || !phone) {
        return "firstname, lastname, and phone are required";
    }
    if (typeof firstname !== "string" ||
        typeof lastname !== "string" ||
        typeof phone !== "string") {
        return "firstname, lastname, and phone must be strings";
    }
    if (!(0, validators_1.validateAccountName)(firstname) || !(0, validators_1.validateAccountName)(lastname)) {
        return "First name and last name must be between 3 and 50 characters";
    }
    // Phone number validation (with optional '+' prefix)
    const phoneRegex = /^\+?[1-9]\d{1,14}$/;
    if (!phoneRegex.test(phone)) {
        return "Invalid phone number format. It should be a valid international phone number.";
    }
    return null;
}
async function OnboardMemberController(firstname, lastname, phone) {
    const validationError = validateInput(firstname, lastname, phone);
    if (validationError) {
        logger_1.default.warn("Invalid input for onboarding member", { firstname, lastname, phone, error: validationError });
        return { error: validationError };
    }
    try {
        logger_1.default.info("Onboarding new member", { firstname, lastname, phone });
        const onboardedMember = await (0, OnboardMember_1.OnboardMemberService)(firstname, lastname, phone);
        if (!onboardedMember.onboardedMemberID) {
            logger_1.default.warn("Failed to onboard member", { firstname, lastname, phone, error: onboardedMember.message });
            return { error: onboardedMember.message || "Failed to onboard member" };
        }
        logger_1.default.info("Member onboarded successfully", { memberID: onboardedMember.onboardedMemberID });
        const memberDashboard = await (0, GetMemberDashboardByPhone_1.GetMemberDashboardByPhoneService)(phone);
        if (!memberDashboard) {
            logger_1.default.warn("Could not retrieve member dashboard after onboarding", { phone });
            return { error: "Could not retrieve member dashboard" };
        }
        logger_1.default.info("Member dashboard retrieved successfully", { memberID: onboardedMember.onboardedMemberID });
        return { memberDashboard };
    }
    catch (error) {
        logger_1.default.error("Error in OnboardMemberController", { error, firstname, lastname, phone });
        return { error: "Internal Server Error" };
    }
}
async function onboardMemberExpressHandler(req, res, next) {
    const { firstname, lastname, phone } = req.body;
    try {
        const result = await OnboardMemberController(firstname, lastname, phone);
        if ("error" in result) {
            res.status(400).json({ message: result.error });
        }
        else {
            res.status(201).json(result);
        }
    }
    catch (error) {
        logger_1.default.error("Error in onboardMemberExpressHandler", { error, firstname, lastname, phone });
        next(error);
    }
}
//# sourceMappingURL=onboardMember.js.map


File: build/src/api/Member/controllers/securedCredexAuthForTier.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecuredCredexAuthForTierController = SecuredCredexAuthForTierController;
exports.securedCredexAuthForTierExpressHandler = securedCredexAuthForTierExpressHandler;
const SecuredCredexAuthForTier_1 = require("../services/SecuredCredexAuthForTier");
const logger_1 = __importDefault(require("../../../../config/logger"));
const denominations_1 = require("../../../constants/denominations");
/**
 * Controller for authorizing secured credex for a member's tier
 * @param memberID - ID of the member
 * @param tier - Member's tier
 * @param Amount - Amount for authorization
 * @param Denomination - Denomination for authorization
 * @returns Object containing authorization status and message
 */
async function SecuredCredexAuthForTierController(memberID, tier, Amount, Denomination) {
    try {
        // Input validation
        if (!memberID || typeof memberID !== 'string') {
            return { isAuthorized: false, message: "Invalid memberID" };
        }
        if (!Number.isInteger(tier) || tier < 1) {
            return { isAuthorized: false, message: "Invalid tier" };
        }
        if (typeof Amount !== 'number' || Amount <= 0) {
            return { isAuthorized: false, message: "Invalid Amount" };
        }
        if (!Denomination || typeof Denomination !== 'string' || !(0, denominations_1.getDenominations)({ code: Denomination }).length) {
            return { isAuthorized: false, message: "Invalid Denomination" };
        }
        logger_1.default.info("Authorizing secured credex for tier", { memberID, tier, Amount, Denomination });
        const result = await (0, SecuredCredexAuthForTier_1.SecuredCredexAuthForTier)(memberID, Amount, Denomination);
        if (typeof result === 'string') {
            logger_1.default.warn("Secured credex authorization failed", { memberID, tier, Amount, Denomination, message: result });
            return { isAuthorized: false, message: result };
        }
        else {
            logger_1.default.info("Secured credex authorization successful", { memberID, tier, Amount, Denomination });
            return { isAuthorized: true, message: "Authorization successful" };
        }
    }
    catch (error) {
        logger_1.default.error("Error in SecuredCredexAuthForTierController", { error, memberID, tier, Amount, Denomination });
        return { isAuthorized: false, message: "Internal Server Error" };
    }
}
/**
 * Express middleware wrapper for secured credex authorization
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
async function securedCredexAuthForTierExpressHandler(req, res, next) {
    const { memberID, tier, Amount, Denomination } = req.body;
    try {
        const result = await SecuredCredexAuthForTierController(memberID, tier, Amount, Denomination);
        if (result.isAuthorized) {
            res.status(200).json(result);
        }
        else {
            res.status(400).json(result);
        }
    }
    catch (error) {
        logger_1.default.error("Error in securedCredexAuthForTierExpressHandler", { error, memberID, tier, Amount, Denomination });
        next(error);
    }
}
//# sourceMappingURL=securedCredexAuthForTier.js.map


File: build/src/api/Member/controllers/updateMemberTier.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateMemberTierController = UpdateMemberTierController;
exports.updateMemberTierExpressHandler = updateMemberTierExpressHandler;
const UpdateMemberTier_1 = require("../services/UpdateMemberTier");
const logger_1 = __importDefault(require("../../../../config/logger"));
/**
 * Controller for updating a member's tier
 * @param memberID - ID of the member
 * @param tier - New tier for the member
 * @returns Object containing success status and message
 */
async function UpdateMemberTierController(memberID, tier) {
    try {
        // Input validation
        if (!memberID || typeof memberID !== 'string') {
            return { success: false, message: "Invalid memberID" };
        }
        if (!Number.isInteger(tier) || tier < 1) {
            return { success: false, message: "Invalid tier. Must be a positive integer." };
        }
        logger_1.default.info("Updating member tier", { memberID, tier });
        const result = await (0, UpdateMemberTier_1.UpdateMemberTierService)(memberID, tier);
        if (result) {
            logger_1.default.info("Member tier updated successfully", { memberID, tier });
            return { success: true, message: "Member tier updated successfully" };
        }
        else {
            logger_1.default.warn("Failed to update member tier", { memberID, tier });
            return { success: false, message: "Failed to update member tier" };
        }
    }
    catch (error) {
        logger_1.default.error("Error in UpdateMemberTierController", { error, memberID, tier });
        return { success: false, message: "Internal Server Error" };
    }
}
/**
 * Express middleware wrapper for updating a member's tier
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
async function updateMemberTierExpressHandler(req, res, next) {
    const { memberID, tier } = req.body;
    try {
        if (!memberID || typeof memberID !== 'string') {
            res.status(400).json({ message: "Invalid memberID. Must be a string." });
            return;
        }
        if (!Number.isInteger(tier) || tier < 1) {
            res.status(400).json({ message: "Invalid tier. Must be a positive integer." });
            return;
        }
        const result = await UpdateMemberTierController(memberID, tier);
        if (result.success) {
            res.status(200).json({ message: result.message });
        }
        else {
            res.status(400).json({ message: result.message });
        }
    }
    catch (error) {
        logger_1.default.error("Error in updateMemberTierExpressHandler", { error, memberID, tier });
        next(error);
    }
}
//# sourceMappingURL=updateMemberTier.js.map


File: build/src/api/Member/controllers/getMemberDashboardByPhone.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMemberDashboardByPhoneController = GetMemberDashboardByPhoneController;
const GetMemberDashboardByPhone_1 = require("../services/GetMemberDashboardByPhone");
const getAccountDashboard_1 = require("../../Account/controllers/getAccountDashboard");
const logger_1 = __importDefault(require("../../../../config/logger"));
/**
 * Controller for retrieving a member's dashboard by phone number
 * @param req - Express request object
 * @param res - Express response object
 * @param next - Express next function
 */
async function GetMemberDashboardByPhoneController(req, res, next) {
    const { phone } = req.body;
    try {
        if (!phone || typeof phone !== 'string') {
            res.status(400).json({ message: "phone is required and must be a string" });
            return;
        }
        // Validate phone number format (simple regex for demonstration, adjust as needed)
        if (!/^\+?[1-9]\d{1,14}$/.test(phone)) {
            res.status(400).json({
                message: "Invalid phone number format. Please provide a valid international phone number.",
            });
            return;
        }
        logger_1.default.info("Retrieving member dashboard by phone", { phone });
        const memberDashboard = await (0, GetMemberDashboardByPhone_1.GetMemberDashboardByPhoneService)(phone);
        if (!memberDashboard) {
            logger_1.default.warn("Could not retrieve member dashboard", { phone });
            res.status(404).json({ message: "Could not retrieve member dashboard" });
            return;
        }
        const accountDashboards = await Promise.all(memberDashboard.accountIDS.map(async (accountId) => {
            const accountReq = {
                body: {
                    memberID: memberDashboard.memberID,
                    accountID: accountId
                }
            };
            const accountRes = {
                status: (code) => ({
                    json: (data) => data
                })
            };
            return (0, getAccountDashboard_1.GetAccountDashboardController)(accountReq, accountRes);
        }));
        logger_1.default.info("Member dashboard retrieved successfully", { phone, memberID: memberDashboard.memberID });
        res.status(200).json({ memberDashboard, accountDashboards });
    }
    catch (error) {
        logger_1.default.error("Error in GetMemberDashboardByPhoneController", { error, phone });
        next(error);
    }
}
//# sourceMappingURL=getMemberDashboardByPhone.js.map


File: build/src/api/Member/services/OnboardMember.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnboardMemberService = OnboardMemberService;
const neo4j_1 = require("../../../../config/neo4j");
const denominations_1 = require("../../../constants/denominations");
async function OnboardMemberService(firstname, lastname, phone) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const defaultDenom = "USD";
    try {
        // Validation: Check defaultDenom in denominations
        if (!(0, denominations_1.getDenominations)({ code: defaultDenom }).length) {
            const message = "defaultDenom not in denoms";
            console.log(message);
            return { onboardedMemberID: false, message: message };
        }
        const result = await ledgerSpaceSession.run(`
        MATCH (daynode:Daynode { Active: true })
        CREATE (member:Member{
          firstname: $firstname,
          lastname: $lastname,
          memberHandle: $phone,
          defaultDenom: $defaultDenom,
          phone: $phone,
          memberID: randomUUID(),
          memberTier: 1,
          createdAt: datetime(),
          updatedAt: datetime()
        })-[:CREATED_ON]->(daynode)
        RETURN
          member.memberID AS memberID
      `, {
            firstname,
            lastname,
            defaultDenom,
            phone,
        });
        if (!result.records.length) {
            const message = "could not onboard member";
            console.log(message);
            return { onboardedMemberID: false, message: message };
        }
        const memberID = result.records[0].get("memberID");
        console.log("member onboarded: " + memberID);
        return {
            onboardedMemberID: memberID,
            message: "member onboarded",
        };
    }
    catch (error) {
        console.error("Error onboarding member:", error);
        // Type guard to narrow the type of error
        if (isNeo4jError(error) &&
            error.code === "Neo.ClientError.Schema.ConstraintValidationFailed") {
            if (error.message.includes("phone")) {
                return {
                    onboardedMemberID: false,
                    message: "Phone number already in use",
                };
            }
            if (error.message.includes("memberHandle")) {
                return {
                    onboardedMemberID: false,
                    message: "Member handle already in use",
                };
            }
            return {
                onboardedMemberID: false,
                message: "Required unique field not unique",
            };
        }
        return {
            onboardedMemberID: false,
            message: "Error: " + (error instanceof Error ? error.message : "Unknown error"),
        };
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
// Type guard to check if an error is a Neo4j error
function isNeo4jError(error) {
    return (typeof error === "object" &&
        error !== null &&
        "code" in error &&
        "message" in error);
}
//# sourceMappingURL=OnboardMember.js.map


File: build/src/api/Member/services/GetMemberByHandle.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMemberByHandleService = GetMemberByHandleService;
const neo4j_1 = require("../../../../config/neo4j");
async function GetMemberByHandleService(memberHandle) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    if (!memberHandle) {
        console.log("memberHandle is required");
        return null;
    }
    try {
        const result = await ledgerSpaceSession.run(`
            MATCH (member:Member { memberHandle: $memberHandle })
            RETURN
              member.memberID AS memberID,
              member.firstname AS firstname,
              member.lastname AS lastname
        `, { memberHandle });
        if (!result.records.length) {
            console.log("member not found");
            return null;
        }
        const memberID = result.records[0].get("memberID");
        const firstname = result.records[0].get("firstname");
        const lastname = result.records[0].get("lastname");
        return {
            memberID: memberID,
            memberName: firstname + " " + lastname,
        };
    }
    catch (error) {
        console.error("Error fetching member data:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetMemberByHandle.js.map


File: build/src/api/Member/services/UpdateMemberTier.js
----------------------------------------
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateMemberTierService = UpdateMemberTierService;
const neo4j_1 = require("../../../../config/neo4j");
const neo4j = __importStar(require("neo4j-driver"));
async function UpdateMemberTierService(memberIDtoUpdate, newTier) {
    if (newTier < 1 || newTier > 5) {
        return {
            message: "New member tier is not a valid value",
        };
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`
        MATCH (member:Member { memberID: $memberIDtoUpdate })
        SET member.memberTier = $newTier
        RETURN
          member.memberID AS memberIDupdated
      `, {
            memberIDtoUpdate,
            newTier: neo4j.int(newTier),
        });
        if (!result.records.length) {
            return false;
        }
        const record = result.records[0];
        if (record.get("memberIDupdated")) {
            console.log("Member tier for " + memberIDtoUpdate + " set to " + newTier);
            return true;
        }
        else {
            console.log("could not authorize account");
            return false;
        }
    }
    catch (error) {
        console.error("Error updating member tier: ", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=UpdateMemberTier.js.map


File: build/src/api/Member/services/GetMemberDashboardByPhone.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMemberDashboardByPhoneService = GetMemberDashboardByPhoneService;
const neo4j_1 = require("../../../../config/neo4j");
const denomUtils_1 = require("../../../utils/denomUtils");
async function GetMemberDashboardByPhoneService(phone) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode { Active: true })
      MATCH (member:Member { phone: $phone })
      OPTIONAL MATCH (member)-[:OWNS]->(account:Account)
      OPTIONAL MATCH (account)-[:OWES|OFFERS]->(credex:Credex)-[:CREATED_ON]->(daynode)
      WITH
        member, daynode,
        COLLECT(account.accountID) AS accountIDs,
        SUM(credex.InitialAmount) AS totalIssuedTodayCXX
      RETURN
        member.memberID AS memberID,
        member.firstname AS firstname,
        member.lastname AS lastname,
        member.memberHandle AS memberHandle,
        member.defaultDenom AS defaultDenom,
        member.memberTier AS memberTier,
        totalIssuedTodayCXX/daynode["USD"] AS totalIssuedTodayUSD,
        accountIDs AS accountIDS
      `, { phone });
        if (!result.records.length) {
            console.log("member not found by phone");
            return false;
        }
        const memberTier = result.records[0].get("memberTier").low;
        const totalIssuedTodayUSD = result.records[0].get("totalIssuedTodayUSD");
        console.log(totalIssuedTodayUSD);
        let remainingAvailableUSD = Infinity;
        if (memberTier == 1) {
            remainingAvailableUSD = parseFloat((0, denomUtils_1.denomFormatter)(10 - totalIssuedTodayUSD, "USD"));
        }
        if (memberTier == 2) {
            remainingAvailableUSD = parseFloat((0, denomUtils_1.denomFormatter)(100 - totalIssuedTodayUSD, "USD"));
        }
        return {
            memberID: result.records[0].get("memberID"),
            firstname: result.records[0].get("firstname"),
            lastname: result.records[0].get("lastname"),
            memberHandle: result.records[0].get("memberHandle"),
            defaultDenom: result.records[0].get("defaultDenom"),
            memberTier: memberTier,
            remainingAvailableUSD: remainingAvailableUSD,
            accountIDS: result.records[0].get("accountIDS"),
        };
    }
    catch (error) {
        console.error("Error fetching account data:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetMemberDashboardByPhone.js.map


File: build/src/api/Member/services/SecuredCredexAuthForTier.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecuredCredexAuthForTier = SecuredCredexAuthForTier;
const neo4j_1 = require("../../../../config/neo4j");
const denomUtils_1 = require("../../../utils/denomUtils");
async function SecuredCredexAuthForTier(issuerAccountID, amount, denom) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const queryResult = await ledgerSpaceSession.run(`
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        WITH member, member.memberTier AS memberTier

        // If memberTier > 2, return true immediately as "result"
        WHERE memberTier > 2
        RETURN true AS result

        UNION

        // If memberTier <= 2, proceed with the larger search query and return calculated values in an object as "result"
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        WITH member, member.memberTier AS memberTier, account
        WHERE memberTier <= 2
        MATCH (daynode:Daynode { Active: true })
        OPTIONAL MATCH (member)-[:OWNS]->(allAccounts:Account)
        OPTIONAL MATCH
          (allAccounts)-[:OWES|OFFERS]->(credex:Credex)<-[:SECURES]-(Account),
          (credex)-[:CREATED_ON]->(daynode)
        WITH
          daynode.USD AS daynodeUSD,
          SUM(credex.InitialAmount) AS dayTotalCXX,
          $amount * daynode[$denom] AS credexAmountCXX,
          memberTier
        RETURN
          {
            dayTotalUSD: dayTotalCXX / daynodeUSD,
            credexAmountUSD: credexAmountCXX / daynodeUSD,
            memberTier: memberTier
          } AS result
    `, { issuerAccountID, amount, denom });
        if (queryResult.records.length === 0) {
            return "query error";
        }
        if (queryResult.records[0].get("result") == true) {
            return true;
        }
        const memberTier = queryResult.records[0].get("result").memberTier;
        const dayTotalUSD = queryResult.records[0].get("result").dayTotalUSD;
        const credexAmountUSD = queryResult.records[0].get("result").credexAmountUSD;
        var amountAvailableUSD = 0;
        if (memberTier == 1) {
            amountAvailableUSD = 10 - dayTotalUSD;
        }
        if (memberTier == 2) {
            amountAvailableUSD = 100 - dayTotalUSD;
        }
        if (amountAvailableUSD >= credexAmountUSD) {
            return true;
        }
        else {
            return ("You are only able to issue " +
                (0, denomUtils_1.denomFormatter)(amountAvailableUSD, "USD") +
                " USD until tomorrow. Limits renew at midnight UTC.");
        }
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=SecuredCredexAuthForTier.js.map


File: build/src/api/Member/memberRoutes.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const getMemberByHandle_1 = require("./controllers/getMemberByHandle");
const getMemberDashboardByPhone_1 = require("./controllers/getMemberDashboardByPhone");
const updateMemberTier_1 = require("./controllers/updateMemberTier");
const onboardMember_1 = require("./controllers/onboardMember");
const router = express_1.default.Router();
/**
 * @openapi
 * /member/getMemberByHandle:
 *   post:
 *     tags:
 *       - Member
 *     summary: Get member by handle
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - memberHandle
 *             properties:
 *               memberHandle:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/getMemberByHandle", getMemberByHandle_1.GetMemberByHandleController);
/**
 * @openapi
 * /member/getMemberDashboardByPhone:
 *   post:
 *     tags:
 *       - Member
 *     summary: Get member dashboard by phone
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - phone
 *             properties:
 *               phone:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/getMemberDashboardByPhone", getMemberDashboardByPhone_1.GetMemberDashboardByPhoneController);
/**
 * @openapi
 * /member/onboardMember:
 *   post:
 *     tags:
 *       - Member
 *     summary: Onboard a new member
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - firstname
 *               - lastname
 *               - phone
 *             properties:
 *               firstname:
 *                 type: string
 *               lastname:
 *                 type: string
 *               phone:
 *                 type: string
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/onboardMember", onboardMember_1.onboardMemberExpressHandler);
/**
 * @openapi
 * /member/updateMemberTier:
 *   post:
 *     tags:
 *       - Member
 *     summary: Update member tier
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - memberID
 *               - tier
 *             properties:
 *               memberID:
 *                 type: string
 *               tier:
 *                 type: number
 *     responses:
 *       200:
 *         description: Successful response
 *       400:
 *         description: Bad request
 */
router.post("/updateMemberTier", updateMemberTier_1.updateMemberTierExpressHandler);
exports.default = router;
//# sourceMappingURL=memberRoutes.js.map


File: build/src/api/AdminDashboard/controllers/CredexController.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCredexDetails = getCredexDetails;
const GetCredexService_1 = __importDefault(require("../services/GetCredexService"));
async function getCredexDetails(req, res) {
    console.log("getCredexDetails controller hit");
    const { credexID } = req.query;
    if (!credexID) {
        return res.status(400).json({
            message: 'The credexID is required'
        });
    }
    try {
        const result = await (0, GetCredexService_1.default)(credexID);
        return res.status(200).json(result);
    }
    catch (error) {
        console.error('Error in getCredexDetails controller:', error);
        return res.status(500).json({
            message: 'Error fetching credex details',
            error: error.message
        });
    }
}
//# sourceMappingURL=CredexController.js.map


File: build/src/api/AdminDashboard/controllers/MemberController.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMemberDetails = getMemberDetails;
exports.updateMemberTier = updateMemberTier;
const GetMemberService_1 = __importDefault(require("../services/GetMemberService"));
const UpdateMemberTierService_1 = __importDefault(require("../services/UpdateMemberTierService"));
async function getMemberDetails(req, res) {
    const { memberHandle } = req.query;
    if (!memberHandle) {
        return res.status(400).json({
            message: 'The memberHandle is required'
        });
    }
    try {
        const result = await (0, GetMemberService_1.default)(memberHandle);
        return res.status(200).json(result);
    }
    catch (error) {
        console.error('Error in getMemberDetails controller:', error);
        return res.status(500).json({
            message: 'Error fetching member details',
            error: error.message
        });
    }
}
async function updateMemberTier(req, res) {
    const { memberHandle, newTier } = req.body;
    if (!memberHandle || !newTier) {
        return res.status(400).json({
            message: 'The memberHandle and newTier are required'
        });
    }
    try {
        const result = await (0, UpdateMemberTierService_1.default)(memberHandle, newTier);
        return res.status(200).json(result);
    }
    catch (error) {
        console.error('Error in updateMemberTier controller:', error);
        return res.status(500).json({
            message: 'Error updating member tier',
            error: error.message
        });
    }
}
/*
export async function updateMemberStatus(req: Request, res: Response) {
  const { memberHandle, newStatus } = req.body;

  if (!memberHandle || !newStatus) {
    return res.status(400).json({
      message: 'The memberHandle and newStatus are required'
    });
  }

  try {
    const result = await UpdateMemberStatusService(memberHandle, newStatus);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in updateMemberStatus controller:', error);
    return res.status(500).json({
      message: 'Error updating member status',
      error: (error as Error).message
    });
  }
}


export async function logMemberInteraction(req: Request, res: Response) {
  const { memberHandle, interactionType, interactionDetails } = req.body;

  if (!memberHandle || !interactionType || !interactionDetails) {
    return res.status(400).json({
      message: 'The memberHandle, interactionType, and interactionDetails are required'
    });
  }

  try {
    const result = await LogMemberInteractionService(memberHandle, interactionType, interactionDetails);
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error in logMemberInteraction controller:', error);
    return res.status(500).json({
      message: 'Error logging member interaction',
      error: (error as Error).message
    });
  }
}
  */
//# sourceMappingURL=MemberController.js.map


File: build/src/api/AdminDashboard/controllers/AccountController.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccountDetails = getAccountDetails;
exports.getReceivedCredexOffers = getReceivedCredexOffers;
exports.getSentCredexOffers = getSentCredexOffers;
const GetAccountService_1 = __importDefault(require("../services/GetAccountService"));
const GetAccountReceivedCredexOffers_1 = __importDefault(require("../services/GetAccountReceivedCredexOffers"));
const GetAccountSentCredexOffers_1 = __importDefault(require("../services/GetAccountSentCredexOffers"));
async function getAccountDetails(req, res) {
    const { accountID, accountHandle } = req.query;
    if (!accountHandle && !accountID) {
        return res.status(400).json({
            message: 'The AccountID or accountHandle is required'
        });
    }
    try {
        const result = await (0, GetAccountService_1.default)(accountHandle, accountID);
        return res.status(200).json(result);
    }
    catch (error) {
        console.error('Error in getAccountDetails controller:', error);
        return res.status(500).json({
            message: 'Error fetching account details',
            error: error.message
        });
    }
}
async function getReceivedCredexOffers(req, res) {
    const { accountHandle, accountID } = req.query;
    if (!accountHandle && !accountID) {
        return res.status(400).json({
            message: 'The AccountID or accountHandle is required'
        });
    }
    try {
        const result = await (0, GetAccountReceivedCredexOffers_1.default)(accountHandle, accountID);
        return res.status(200).json(result);
    }
    catch (error) {
        console.error('Error in getReceivedCredexOffers controller:', error);
        return res.status(500).json({
            message: 'Error fetching received credex offers',
            error: error.message
        });
    }
}
async function getSentCredexOffers(req, res) {
    const { accountID, accountHandle } = req.query;
    if (!accountHandle) {
        return res.status(400).json({
            message: 'The AccountID or accountHandle is required'
        });
    }
    try {
        const result = await (0, GetAccountSentCredexOffers_1.default)(accountHandle, accountID);
        return res.status(200).json(result);
    }
    catch (error) {
        console.error('Error in getSentCredexOffers controller:', error);
        return res.status(500).json({
            message: 'Error fetching sent credex offers',
            error: error.message
        });
    }
}
//# sourceMappingURL=AccountController.js.map


File: build/src/api/AdminDashboard/adminDashboardRoutes.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AdminDashboardRoutes;
const index_1 = require("../../index");
const CredexController_1 = require("./controllers/CredexController");
const MemberController_1 = require("./controllers/MemberController");
const AccountController_1 = require("./controllers/AccountController");
/*
function logRoute(req: express.Request, res: express.Response, next: express.NextFunction) {
  console.log("getCredexDetails route hit");
  next();
}
*/
function AdminDashboardRoutes(app, jsonParser) {
    app.get(`${index_1.apiVersionOneRoute}getCredexDetails`, 
    //logRoute,
    jsonParser, CredexController_1.getCredexDetails);
    app.get(`${index_1.apiVersionOneRoute}getMemberDetails`, jsonParser, MemberController_1.getMemberDetails);
    app.patch(`${index_1.apiVersionOneRoute}updateMemberTier`, jsonParser, MemberController_1.updateMemberTier);
    app.get(`${index_1.apiVersionOneRoute}getAccountDetails`, jsonParser, AccountController_1.getAccountDetails);
    app.get(`${index_1.apiVersionOneRoute}getReceivedCredexOffers`, jsonParser, AccountController_1.getReceivedCredexOffers);
    app.get(`${index_1.apiVersionOneRoute}getSentCredexOffers`, jsonParser, AccountController_1.getSentCredexOffers);
    /*
    app.get(`${apiVersionOneRoute}getAccountActivityLog`,
      jsonParser,
      authMiddleware,
      getAccountActivityLog
    );
    */
    /*
    app.put(`${apiVersionOneRoute}updateMemberStatus`,
      jsonParser,
      authMiddleware,
      updateMemberStatus
    );
    */
}
//# sourceMappingURL=adminDashboardRoutes.js.map


File: build/src/api/AdminDashboard/middleware/errorHandler.js
----------------------------------------
"use strict";
//# sourceMappingURL=errorHandler.js.map


File: build/src/api/AdminDashboard/middleware/requestLogger.js
----------------------------------------
"use strict";
//# sourceMappingURL=requestLogger.js.map


File: build/src/api/AdminDashboard/middleware/validateRequest.js
----------------------------------------
"use strict";
//# sourceMappingURL=validateRequest.js.map


File: build/src/api/AdminDashboard/middleware/authMiddleware.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authMiddleware = authMiddleware;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const secretKey = process.env.JWT_SECRET_KEY || 'your-secret-key';
function authMiddleware(req, res, next) {
    const token = req.headers['authorization'];
    if (!token) {
        return res.status(401).json({ error: 'Unauthorized' });
    }
    try {
        const decoded = jsonwebtoken_1.default.verify(token, secretKey);
        req.user = decoded;
        next();
    }
    catch (err) {
        return res.status(401).json({ error: 'Invalid token' });
    }
}
//# sourceMappingURL=authMiddleware.js.map


File: build/src/api/AdminDashboard/services/GetAccountService.js
----------------------------------------
"use strict";
/*
  ToDo:
    - Add the accountID to the query
    
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GetAccount;
/*
 Query an account using the accountID or accountHandle to get all information associated with the account
*/
const neo4j_1 = require("../../../../config/neo4j");
async function GetAccount(accountHandle, accountID) {
    if (!accountHandle && !accountID) {
        return {
            message: 'The AccountID or accountHandle is required'
        };
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
    const parameters = accountHandle ? { accountHandle } : { accountID };
    try {
        const query = `MATCH (account:Account {${accountMatchCondition}})<-[:OWNS]-(member:Member)
    WITH account, member
    OPTIONAL MATCH (account)-[:OWES]->(owedCredex)-[:OWES]->(owedAccount)
    WITH member, account, COLLECT(owedCredex.credexID) AS owedCredexes, COLLECT(owedAccount.accountID) AS owedAccounts
    RETURN
      member.memberID AS accountOwnerID,
      member.memberHandle AS accountOwnerHandle,
      member.memberTier AS accountOwnerTier,
      account.accountID AS accountID,
      account.accountName AS accountName,
      account.accountHandle AS accountHandle,
      account.accountType AS accountType,
      account.createdAt AS accountCreatedAt,
      account.updatedAt AS accountUpdatedAt,
      COUNT(owedCredexes) AS numberOfCredexOwed,
      owedCredexes,
      owedAccounts

    `;
        const accountResult = await ledgerSpaceSession.run(query, parameters);
        const account = accountResult.records.map((record) => {
            return {
                accountOwnerID: record.get("accountOwnerID"),
                accountOwnerHandle: record.get("accountOwnerHandle"),
                accountOwnerTier: record.get("accountOwnerTier"),
                accountID: record.get("accountID"),
                accountName: record.get("accountName"),
                accountHandle: record.get("accountHandle"),
                accountType: record.get("accountType"),
                accountCreatedAt: record.get("accountCreatedAt"),
                accountUpdatedAt: record.get("accountUpdatedAt"),
                numberOfCredexOwed: record.get("numberOfCredexOwed"),
                owedCredexes: record.get("owedCredexes"),
                owedAccounts: record.get("owedAccounts")
            };
        });
        if (!account.length) {
            return {
                message: 'Account not found'
            };
        }
        return {
            message: 'Account fetched successfully',
            data: account
        };
    }
    catch (error) {
        return {
            message: 'Error fetching account',
            error: error
        };
    }
}
//# sourceMappingURL=GetAccountService.js.map


File: build/src/api/AdminDashboard/services/GetAccountReceivedCredexOffers.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GetAccountReceivedCredexOffers;
const neo4j_1 = require("../../../../config/neo4j");
async function GetAccountReceivedCredexOffers(accountHandle, accountID) {
    if (!accountHandle && !accountID) {
        return {
            message: 'Either accountHandle or accountID is required'
        };
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
    const parameters = accountHandle ? { accountHandle } : { accountID };
    try {
        const query = `
      MATCH (account:Account {${accountMatchCondition}})<-[:OFFERED]-(receivedCredexOffer)<-[:OFFERED]-(sendingAccount)
      RETURN
        receivedCredexOffer.credexID AS receivedCredexOfferID,
        receivedCredexOffer.credexType AS receivedCredexOfferType,
        receivedCredexOffer.Denomination AS receivedCredexOfferDenomination,
        receivedCredexOffer.InitialAmount AS receivedCredexOfferInitialAmount,
        receivedCredexOffer.OutstandingAmount AS receivedCredexOfferOutstandingAmount,
        receivedCredexOffer.DefaultedAmount AS receivedCredexOfferDefaultedAmount,
        receivedCredexOffer.RedeemedAmount AS receivedCredexOfferRedeemedAmount,
        receivedCredexOffer.queueStatus AS receivedCredexOfferQueueStatus,
        receivedCredexOffer.CXXmultiplier AS receivedCredexOfferCXXmultiplier,
        receivedCredexOffer.WrittenOffAmount AS receivedCredexOfferWrittenOffAmount,
        receivedCredexOffer.dueDate AS receivedCredexOfferDueDate,
        receivedCredexOffer.createdAt AS receivedCredexOfferCreatedAt,
        sendingAccount.accountID AS sendingAccountID,
        sendingAccount.defaultDenom AS sendingAccountDefaultDenom,
        sendingAccount.accountHandle AS sendingAccountHandle
    `;
        const accountReceivedCredexOffersResult = await ledgerSpaceSession.run(query, parameters);
        const accountReceivedCredexOffers = accountReceivedCredexOffersResult.records.map((record) => ({
            receivedCredexOfferID: record.get("receivedCredexOfferID"),
            receivedCredexOfferType: record.get("receivedCredexOfferType"),
            receivedCredexOfferDenomination: record.get("receivedCredexOfferDenomination"),
            receivedCredexOfferInitialAmount: record.get("receivedCredexOfferInitialAmount"),
            receivedCredexOfferOutstandingAmount: record.get("receivedCredexOfferOutstandingAmount"),
            receivedCredexOfferDefaultedAmount: record.get("receivedCredexOfferDefaultedAmount"),
            receivedCredexOfferRedeemedAmount: record.get("receivedCredexOfferRedeemedAmount"),
            receivedCredexOfferQueueStatus: record.get("receivedCredexOfferQueueStatus"),
            receivedCredexOfferCXXmultiplier: record.get("receivedCredexOfferCXXmultiplier"),
            receivedCredexOfferWrittenOffAmount: record.get("receivedCredexOfferWrittenOffAmount"),
            receivedCredexOfferDueDate: record.get("receivedCredexOfferDueDate"),
            receivedCredexOfferCreatedAt: record.get("receivedCredexOfferCreatedAt"),
            sendingAccountID: record.get("sendingAccountID"),
            sendingAccountDefaultDenom: record.get("sendingAccountDefaultDenom"),
            sendingAccountHandle: record.get("sendingAccountHandle")
        }));
        if (!accountReceivedCredexOffers.length) {
            return {
                message: 'Account received credex offers not found'
            };
        }
        return {
            message: 'Account received credex offers fetched successfully',
            data: {
                accountReceivedCredexOffers
            }
        };
    }
    catch (error) {
        console.error('Error fetching account received credex offers:', error);
        return {
            message: 'Error fetching account received credex offers',
            error: error
        };
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetAccountReceivedCredexOffers.js.map


File: build/src/api/AdminDashboard/services/GetMemberService.js
----------------------------------------
"use strict";
/*
 Query a member using memberHandle

*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GetMemberService;
const neo4j_1 = require("../../../../config/neo4j");
async function GetMemberService(memberHandle) {
    if (!memberHandle) {
        return {
            message: 'The memberHandle is required'
        };
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`Match (member:Member)
          WHERE member.memberHandle = $memberHandle
          WITH member
          MATCH (member)-[:OWNS]->(account:Account)
            Return
              member.memberID AS memberID,
              member.memberHandle AS memmberHandle,
              member.firstname AS firstname,
              member.lastname AS lastname,
              member.phone AS phone, 
              member.memberTier AS memberTier,
              count(account) AS numberOfAccounts,
              member.defaultDenom AS defaultDenom,
              member.updatedAt AS updatedAt,        
              member.createdAt AS createdAt
      `, { memberHandle });
        const records = result.records.map((record) => {
            return {
                memberID: record.get("memberID"),
                memberHandle: record.get("memmberHandle"),
                firstname: record.get("firstname"),
                lastname: record.get("lastname"),
                phone: record.get("phone"),
                memberTier: record.get("memberTier"),
                defaultDenom: record.get("defaultDenom"),
                updatedAt: record.get("updatedAt"),
                createdAt: record.get("createdAt"),
            };
        });
        if (!records.length) {
            return {
                message: 'User not found',
            };
        }
        return {
            message: 'User fetched successfully',
            data: records
        };
    }
    catch (error) {
        console.error('Error fetching user:', error);
        return {
            message: 'Error fetching user',
            error: error,
        };
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetMemberService.js.map


File: build/src/api/AdminDashboard/services/UpdateMemberTierService.js
----------------------------------------
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = UpdateMemberTierService;
/*
Update a members tier using the memberHandle or memberID
*/
const neo4j_1 = require("../../../../config/neo4j");
async function UpdateMemberTierService(memberHandle, newTier) {
    if (!memberHandle || !newTier) {
        return {
            message: 'The memberHandle and memberTier are required'
        };
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const result = await ledgerSpaceSession.run(`MATCH (member:Member {memberHandle: $memberHandle})
       SET member.memberTier = $newTier 
       RETURN member.memberID AS memberID, member.memberHandle AS memberHandle, member.memberTier AS memberTier`, { memberHandle, newTier });
        const member = result.records.map((record) => {
            return {
                memberID: record.get("memberID"),
                memberHandle: record.get("memberHandle"),
                memberTier: record.get("memberTier")
            };
        });
        return {
            message: 'Member tier updated successfully',
            data: member
        };
    }
    catch (error) {
        return {
            message: `Error updating member tier ${memberHandle}, ${newTier}`,
            error: error
        };
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=UpdateMemberTierService.js.map


File: build/src/api/AdminDashboard/services/GetCredexService.js
----------------------------------------
"use strict";
/*
GetCredexService:
- Retrieve details of a credex using the credexID
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GetCredexService;
const neo4j_1 = require("../../../../config/neo4j");
async function GetCredexService(credexID) {
    if (!credexID) {
        return {
            message: 'CredexID is required'
        };
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const credexResult = await ledgerSpaceSession.run(`MATCH (credex:Credex {credexID:$credexID})<-[:OFFERED]-(sendingAccount:Account)
        WITH credex, sendingAccount
        MATCH (credex)-[:OFFERED]-> (receivingAccount:Account)
        RETURN 
          credex.credexID AS credexID,
          credex.credexType AS credexType,
          credex.Denomination AS credexDenomination,
          credex.InitialAmount AS credexInitialAmount,
          credex.OutstandingAmount AS credexOutstandingAmount,
          credex.CXXmultiplier AS credexCXXmultiplier,
          credex.WrittenOffAmount AS credexWrittenOffAmount,
          credex.DefaultedAmount AS credexDefaultedAmount,
          credex.RedeemedAmount AS credexRedeemedAmount,
          credex.queueStatus AS credexQueueStatus,
          credex.acceptedAt AS credexAcceptedAt,
          credex.createdAt AS credexCreatedAt,
          sendingAccount.accountID AS sendingAccountID,
          sendingAccount.accountName AS sendingAccountName,
          sendingAccount.accountHandle AS sendingAccountHandle,
          sendingAccount.accountType AS sendingAccountType,
          receivingAccount.accountID AS receivingAccountID,
          receivingAccount.accountName AS receivingAccountName,
          receivingAccount.accountHandle AS receivingAccountHandle,
          receivingAccount.accountType AS receivingAccountType`, { credexID });
        const credex = credexResult.records.map((record) => {
            return {
                credexID: record.get("credexID"),
                credexType: record.get("credexType"),
                credexDenomination: record.get("credexDenomination"),
                credexInitialAmount: record.get("credexInitialAmount"),
                credexOutstandingAmount: record.get("credexOutstandingAmount"),
                credexCXXmultiplier: record.get("credexCXXmultiplier"),
                credexWrittenOffAmount: record.get("credexWrittenOffAmount"),
                credexDefaultedAmount: record.get("credexDefaultedAmount"),
                credexRedeemedAmount: record.get("credexRedeemedAmount"),
                credexQueueStatus: record.get("credexQueueStatus"),
                credexAcceptedAt: record.get("credexAcceptedAt"),
                credexCreatedAt: record.get("credexCreatedAt"),
                sendingAccountID: record.get("sendingAccountID"),
                sendingAccountName: record.get("sendingAccountName"),
                sendingAccountHandle: record.get("sendingAccountHandle"),
                sendingAccountType: record.get("sendingAccountType"),
                receivingAccountID: record.get("receivingAccountID"),
                receivingAccountName: record.get("receivingAccountName"),
                receivingAccountHandle: record.get("receivingAccountHandle"),
                receivingAccountType: record.get("receivingAccountType")
            };
        });
        if (!credex.length) {
            return {
                message: 'Credex not found'
            };
        }
        return {
            message: 'Credex retrieved successfully',
            data: {
                credex
            }
        };
    }
    catch (error) {
        console.error(error);
        return {
            message: 'Error retrieving credex',
            error: error
        };
    }
}
//# sourceMappingURL=GetCredexService.js.map


File: build/src/api/AdminDashboard/services/GetMemberAccountsOwnerByMemberSevice.js
----------------------------------------
"use strict";
/*
Query to a member to get acounts ownde by use using memberID
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GetMemberAccountsOwnerByMemberSevice;
const neo4j_1 = require("../../../../config/neo4j");
async function GetMemberAccountsOwnerByMemberSevice(memberID) {
    if (!memberID) {
        return {
            message: 'The memberID is required'
        };
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        const accountsOwnedByMemberResult = await ledgerSpaceSession.run(`MATCH (member:Member {memberID:$memberID})-[:OWNS] ->(account:Account)
        RETURN
          account.accountID AS accountID,
          account.accountHandle AS accountHandle,
          account.accountName AS accountName,
          account.defaultDenom AS defaultDenom,
          account.accountType AS accountType,
          account.queueStatus AS queueStatus,
          account.createdAt AS createdAt,
          account.updatedAt AS updatedAt
      `, { memberID });
        const accountsOwnedByMember = accountsOwnedByMemberResult.records.map((record) => {
            return {
                accountID: record.get("accountID"),
                accountHandle: record.get("accountHandle"),
                accountName: record.get("accountName"),
                defaultDenom: record.get("defaultDenom"),
                accountType: record.get("accountType"),
                queueStatus: record.get("queueStatus"),
                createdAt: record.get("createdAt"),
                updatedAt: record.get("updatedAt")
            };
        });
        if (!accountsOwnedByMember.length) {
            return {
                message: 'Accounts owned by member not found'
            };
        }
        return {
            message: 'Accounts owned by member fetched successfully',
            data: accountsOwnedByMember,
        };
    }
    catch (error) {
        console.error('Error fetching accounts owned by member:', error);
        return {
            message: 'Error fetching accounts owned by member',
            error: error
        };
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetMemberAccountsOwnerByMemberSevice.js.map


File: build/src/api/AdminDashboard/services/GetAccountSentCredexOffers.js
----------------------------------------
"use strict";
/*
  ToDo:
    - Add the accountID to the query
    
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GetAccountService;
/*
 Query an account to get all sent credex offers
*/
const neo4j_1 = require("../../../../config/neo4j");
async function GetAccountService(accountHandle, accountID) {
    if (!accountHandle) {
        return {
            message: 'The AccountID or accountHandle is required'
        };
    }
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    // Get all outgoing credex offers from the account using the accountID or accountHandle to get the account and then get the receivingNode which can be a member or an account
    const accountMatchCondition = accountHandle ? "accountHandle:$accountHandle" : "accountID: $accountID";
    const parameters = accountHandle ? { accountHandle } : { accountID };
    try {
        const query = `MATCH (account:Account {${accountMatchCondition}})-[:OFFERED]->(offeredCredex)-[:OFFERED]->(receivingAccount) 
        RETURN
        offeredCredex.credexID AS offeredCredexID,
        offeredCredex.credexType AS offeredCredexType,
        offeredCredex.Denomination AS offeredCredexDenomination,
        offeredCredex.InitialAmount AS offeredCredexInitialAmount,
        offeredCredex.OutstandingAmount AS offeredCredexOutstandingAmount,
        offeredCredex.DefaultedAmount AS offeredCredexDefaultedAmount,
        offeredCredex.RedeemedAmount AS offeredCredexRedeemedAmount,
        offeredCredex.queueStatus AS offeredCredexQueueStatus,
        offeredCredex.CXXmultiplier AS offeredCredexCXXmultiplier,
        offeredCredex.WrittenOffAmount AS offeredCredexWrittenOffAmount,
        offeredCredex.dueDate AS offeredCredexDueDate,
        offeredCredex.createdAt AS offeredCredexCreatedAt,
        receivingAccount.accountID AS receivingAccountID,
        receivingAccount.defaultDenom AS receivingAccountDefaultDenom,
        receivingAccount.accountHandle AS receivingAccountHandle

      `;
        const accountOfferedCredexResult = await ledgerSpaceSession.run(query, parameters);
        const accountOfferedCredex = accountOfferedCredexResult.records.map((record) => {
            return {
                offeredCredexID: record.get("offeredCredexID"),
                offeredCredexType: record.get("offeredCredexType"),
                offeredCredexDenomination: record.get("offeredCredexDenomination"),
                offeredCredexInitialAmount: record.get("offeredCredexInitialAmount"),
                offeredCredexOutstandingAmount: record.get("offeredCredexOutstandingAmount"),
                offeredCredexDefaultedAmount: record.get("offeredCredexDefaultedAmount"),
                offeredCredexRedeemedAmount: record.get("offeredCredexRedeemedAmount"),
                offeredCredexQueueStatus: record.get("offeredCredexQueueStatus"),
                offeredCredexCXXmultiplier: record.get("offeredCredexCXXmultiplier"),
                offeredCredexWrittenOffAmount: record.get("offeredCredexWrittenOffAmount"),
                offeredCredexDueDate: record.get("offeredCredexDueDate"),
                offeredCredexCreatedAt: record.get("offeredCredexCreatedAt"),
                receivingAccountID: record.get("receivingAccountID"),
                receivingAccountDefaultDenom: record.get("receivingAccountDefaultDenom"),
                receivingAccountHandle: record.get("receivingAccountHandle"),
            };
        });
        if (!accountOfferedCredex.length) {
            return {
                message: 'Account sent credex offers not found'
            };
        }
        return {
            message: 'Account credex offers fetched successfully',
            data: {
                accountOfferedCredex,
            }
        };
    }
    catch (error) {
        console.error('Error fetching account:', error);
        return {
            message: 'Error fetching account',
            error: error,
        };
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=GetAccountSentCredexOffers.js.map


File: build/src/core-cron/cronJobs.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = startCronJobs;
const node_cron_1 = __importDefault(require("node-cron"));
const DailyCredcoinOffering_1 = require("./DCO/DailyCredcoinOffering");
const MinuteTransactionQueue_1 = require("./MTQ/MinuteTransactionQueue");
function startCronJobs() {
    // Running DailyCredcoinOffering every day at midnight UTC
    node_cron_1.default.schedule("0 0 * * *", async () => {
        try {
            await (0, DailyCredcoinOffering_1.DailyCredcoinOffering)();
        }
        catch (error) {
            console.error("Error running DailyCredcoinOffering:", error);
        }
    }, {
        timezone: "UTC",
    });
    // Running MinuteTransactionQueue every minute
    node_cron_1.default.schedule("* * * * *", async () => {
        try {
            await (0, MinuteTransactionQueue_1.MinuteTransactionQueue)();
        }
        catch (error) {
            console.error("Error running MinuteTransactionQueue:", error);
        }
    });
}
//# sourceMappingURL=cronJobs.js.map


File: build/src/core-cron/DCO/DCOavatars.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DCOavatars = DCOavatars;
const neo4j_1 = require("../../../config/neo4j");
const OfferCredex_1 = require("../../api/Credex/services/OfferCredex");
const AcceptCredex_1 = require("../../api/Credex/services/AcceptCredex");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
/**
 * DCOavatars function
 * This function is run as a cronjob every 24 hours to process recurring avatars.
 * It identifies active recurring avatars, creates credexes, and updates there status.
 */
async function DCOavatars() {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        console.log("Checking for activated recurring avatars...");
        // Query to get active recurring avatars that are due for processing
        const GetActiveRecurringAvatars = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      MATCH
        (issuer:Account)-[rel1:ACTIVE]->
        (avatar:Avatar { avatarType: "RECURRING", nextPayDate: daynode.Date})-[rel2:ACTIVE]->
        (acceptor:Account)
      MATCH
        (issuer)<-[authRel1:AUTHORIZED_FOR]-
        (avatar)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2
      
      // Reduce remainingPays by 1 if it exists
      SET avatar.remainingPays = 
        CASE
          WHEN avatar.remainingPays IS NOT NULL THEN avatar.remainingPays - 1
          ELSE null
        END
      
      // Calculate the new nextPayDate
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2,
           CASE
             WHEN avatar.remainingPays IS NULL OR avatar.remainingPays > 0 
             THEN date(avatar.nextPayDate) + duration({days: avatar.daysBetweenPays})
             ELSE null
           END AS newNextPayDate
      
      // Update nextPayDate
      SET avatar.nextPayDate = newNextPayDate
      
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2, newNextPayDate
      
      // Check if the avatar should be marked as completed
      OPTIONAL MATCH (issuer)-[completed1:COMPLETED]->(avatar)-[completed2:COMPLETED]->(acceptor)
      FOREACH(ignoreMe IN CASE WHEN newNextPayDate IS NULL AND completed1 IS NULL
               THEN [1] ELSE [] END |
        DELETE rel1, rel2
        SET
          authRel1.markedToDelete = true,
          authRel2.markedToDelete = true
        CREATE (issuer)-[:COMPLETED]->(avatar)-[:COMPLETED]->(acceptor)
      )
      
      RETURN
        avatar {
          .*,
          remainingPays: avatar.remainingPays,
          nextPayDate: avatar.nextPayDate
        } AS avatar,
        issuer.accountID AS issuerAccountID,
        acceptor.accountID AS acceptorAccountID,
        daynode.Date AS Date    
    `);
        // Process each active recurring avatar
        for (const record of GetActiveRecurringAvatars.records) {
            const avatar = record.get("avatar");
            const issuerAccountID = record.get("issuerAccountID");
            const acceptorAccountID = record.get("acceptorAccountID");
            try {
                // Prepare data for creating a new credex
                const offerData = {
                    memberID: avatar.memberID,
                    issuerAccountID: issuerAccountID,
                    receiverAccountID: acceptorAccountID,
                    Denomination: avatar.Denomination,
                    InitialAmount: avatar.InitialAmount,
                    credexType: "PURCHASE",
                    OFFERSorREQUESTS: "OFFERS",
                };
                // Handle secured and unsecured credexes differently
                if (avatar.securedCredex) {
                    offerData.securedCredex = true;
                }
                else {
                    // Calculate dueDate for unsecured credexes using the avatar's credspan
                    avatar.dueDate = (0, moment_timezone_1.default)(record.get("Date"))
                        .add(parseInt(avatar.credspan), "days")
                        .subtract(parseInt("1"), "month")
                        .format("YYYY-MM-DD");
                    offerData.dueDate = avatar.dueDate;
                }
                // Create a new credex offer
                const offerResult = await (0, OfferCredex_1.OfferCredexService)(offerData);
                // If offer is successful, automatically accept it
                if (offerResult &&
                    typeof offerResult.credex === "object" &&
                    offerResult.credex.credexID) {
                    const acceptResult = await (0, AcceptCredex_1.AcceptCredexService)(offerResult.credex.credexID, avatar.memberID);
                    if (acceptResult) {
                        console.log(`Successfully created credex for recurring avatar: ${avatar.memberID}. Remaining pays: ${avatar.remainingPays}, Next pay date: ${avatar.nextPayDate}`);
                    }
                    else {
                        throw new Error(`Failed to accept credex for avatar: ${avatar.memberID}`);
                    }
                }
                else {
                    throw new Error(`Failed to create offer for avatar: ${avatar.memberID}`);
                }
                const deleteAvatarAuths = await ledgerSpaceSession.run(`
          MATCH ()-[rel:AUTHORIZED_FOR {markedToDelete: true}]->()
          DELETE rel
          `);
            }
            catch (error) {
                console.error(`Error processing avatar ${avatar.memberID}:`, error);
                // TODO: Implement member notification about the failure
                console.log(`Placeholder: Notify member ${avatar.memberID} about the failure in processing their recurring avatar.`);
            }
        }
    }
    catch (error) {
        console.error("Error in DCOavatars:", error);
    }
    finally {
        await ledgerSpaceSession.close();
    }
}
//# sourceMappingURL=DCOavatars.js.map


File: build/src/core-cron/DCO/DailyCredcoinOffering.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DailyCredcoinOffering = DailyCredcoinOffering;
const neo4j_1 = require("../../../config/neo4j");
const DBinitialization_1 = require("./DBinitialization");
const DCOexecute_1 = require("./DCOexecute");
const DCOavatars_1 = require("./DCOavatars");
const logger_1 = __importDefault(require("../../../config/logger"));
/**
 * Executes the Daily Credcoin Offering (DCO) process.
 * This function checks for an active daynode, initializes the database if necessary,
 * and runs the DCO execution and avatar update processes.
 *
 * @returns {Promise<boolean>} Returns true if the DCO process completes successfully, false otherwise.
 */
async function DailyCredcoinOffering() {
    console.log("Starting Daily Credcoin Offering process");
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    try {
        // Check for active daynode
        const daynodeExists = await checkActiveDaynode(ledgerSpaceSession);
        if (!daynodeExists) {
            console.log("No active daynode found. Initializing database...");
            await (0, DBinitialization_1.DBinitialization)();
            console.log("Database initialization complete");
        }
        await (0, DCOexecute_1.DCOexecute)();
        await (0, DCOavatars_1.DCOavatars)();
        return true;
    }
    catch (error) {
        logger_1.default.error("Error in DailyCredcoinOffering", error);
        return false;
    }
    finally {
        await resetDCORunningFlag(ledgerSpaceSession);
        await ledgerSpaceSession.close();
    }
}
/**
 * Checks if an active daynode exists in the database.
 *
 * @param {Neo4jSession} session - The Neo4j session to use for the query.
 * @returns {Promise<boolean>} Returns true if an active daynode exists, false otherwise.
 */
async function checkActiveDaynode(session) {
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN daynode IS NOT NULL AS activeDaynodeExists
  `);
    return result.records[0].get("activeDaynodeExists");
}
/**
 * Resets the DCOrunningNow flag on the active daynode.
 *
 * @param {Neo4jSession} session - The Neo4j session to use for the query.
 */
async function resetDCORunningFlag(session) {
    console.log("Resetting DCOrunningNow flag");
    await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    SET daynode.DCOrunningNow = false
  `);
}
//# sourceMappingURL=DailyCredcoinOffering.js.map


File: build/src/core-cron/DCO/DBbackup.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNeo4jBackup = void 0;
const neo4j_1 = require("../../../config/neo4j");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const exportDatabase = async (driver, databaseName, previousDate, append) => {
    const session = driver.session();
    try {
        const fileName = `${previousDate}_${databaseName}${append}.json`;
        const filePath = path_1.default.join(__dirname, "DCOsnapshots", fileName);
        const result = await session.run(`
      CALL apoc.export.json.all(null, {stream:true, useTypes:true})
    `);
        const records = result.records;
        let jsonData = "";
        records.forEach((record) => {
            jsonData += record.get(0);
        });
        fs_1.default.writeFileSync(filePath, jsonData);
        console.log(`Backup for ${databaseName} created successfully: ${filePath}`);
    }
    catch (error) {
        console.error(`Error creating backup for ${databaseName}:`, error);
        throw error;
    }
    finally {
        await session.close();
    }
};
const createNeo4jBackup = async (previousDate, append) => {
    try {
        await exportDatabase(neo4j_1.ledgerSpaceDriver, "ledgerSpace_dev", previousDate, append);
        await exportDatabase(neo4j_1.searchSpaceDriver, "searchSpace_dev", previousDate, append);
        console.log("Both databases backed up successfully.");
    }
    catch (error) {
        console.error("Error creating backups:", error);
        throw error;
    }
};
exports.createNeo4jBackup = createNeo4jBackup;
//# sourceMappingURL=DBbackup.js.map


File: build/src/core-cron/DCO/DCOsnapshots/placeholder.js
----------------------------------------
"use strict";
//placeholder
//# sourceMappingURL=placeholder.js.map


File: build/src/core-cron/DCO/DCOexecute.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DCOexecute = DCOexecute;
const axios_1 = __importDefault(require("axios"));
const lodash_1 = __importDefault(require("lodash"));
const neo4j_1 = require("../../../config/neo4j");
const denominations_1 = require("../../constants/denominations");
const GetSecuredAuthorization_1 = require("../../api/Credex/services/GetSecuredAuthorization");
const OfferCredex_1 = require("../../api/Credex/services/OfferCredex");
const AcceptCredex_1 = require("../../api/Credex/services/AcceptCredex");
const fetchZigRate_1 = require("./fetchZigRate");
const DBbackup_1 = require("./DBbackup");
const logger_1 = __importDefault(require("../../../config/logger"));
/**
 * Executes the Daily Credcoin Offering (DCO) process.
 * This function handles the daily operations of the Credcoin system,
 * including rate updates, participant validation, and transaction processing.
 */
async function DCOexecute() {
    console.log("Starting DCOexecute");
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    try {
        await waitForMTQCompletion(ledgerSpaceSession);
        const { previousDate, nextDate } = await setDCORunningFlag(ledgerSpaceSession);
        await (0, DBbackup_1.createNeo4jBackup)(previousDate, "_end");
        await handleDefaultingCredexes(ledgerSpaceSession);
        await expirePendingOffers(ledgerSpaceSession);
        const USDbaseRates = await fetchCurrencyRates(nextDate);
        const { newCXXrates, CXXprior_CXXcurrent, DCOinCXX, DCOinXAU, numberConfirmedParticipants, } = await processDCOParticipants(ledgerSpaceSession, USDbaseRates);
        await createNewDaynode(ledgerSpaceSession, newCXXrates, nextDate, CXXprior_CXXcurrent);
        await updateCredexBalances(ledgerSpaceSession, searchSpaceSession, newCXXrates, CXXprior_CXXcurrent);
        const { foundationID, foundationXOid } = await getFoundationData(ledgerSpaceSession);
        await processDCOTransactions(ledgerSpaceSession, foundationID, foundationXOid, DCOinCXX, numberConfirmedParticipants);
        await (0, DBbackup_1.createNeo4jBackup)(nextDate, "_start");
        console.log(`DCOexecute completed for ${nextDate}`);
        return true;
    }
    catch (error) {
        logger_1.default.error("Error during DCOexecute", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
async function waitForMTQCompletion(session) {
    console.log("Waiting for MTQ completion");
    let MTQflag = true;
    while (MTQflag) {
        const result = await session.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.MTQrunningNow AS MTQflag
    `);
        MTQflag = result.records[0]?.get("MTQflag");
        if (MTQflag) {
            console.log("MTQ running. Waiting 5 seconds...");
            await new Promise((resolve) => setTimeout(resolve, 5000));
        }
    }
    console.log("MTQ not running. Proceeding...");
}
async function setDCORunningFlag(session) {
    console.log("Setting DCOrunningNow flag");
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    SET daynode.DCOrunningNow = true
    RETURN
      daynode.Date AS previousDate,
      daynode.Date + Duration({days: 1}) AS nextDate
  `);
    const previousDate = result.records[0].get("previousDate");
    const nextDate = result.records[0].get("nextDate");
    console.log(`Expiring day: ${previousDate}`);
    return { previousDate, nextDate };
}
async function handleDefaultingCredexes(session) {
    console.log("Processing defaulting unsecured credexes");
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    OPTIONAL MATCH (account1:Account)-[rel1:OWES]->(defaulting:Credex)-[rel2:OWES]->(account2:Account)
    WHERE defaulting.dueDate <= daynode.Date AND defaulting.DefaultedAmount <= 0
    SET defaulting.DefaultedAmount = defaulting.OutstandingAmount
    WITH defaulting, daynode
    UNWIND defaulting AS defaultingCredex
    CREATE (defaultingCredex)-[:DEFAULTED_ON]->(daynode)
    RETURN count(defaulting) AS numberDefaulted
  `);
    const numberDefaulted = result.records[0]?.get("numberDefaulted") || 0;
    console.log(`Defaults: ${numberDefaulted}`);
}
async function expirePendingOffers(session) {
    console.log("Expiring pending offers/requests");
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: TRUE})
    OPTIONAL MATCH (:Account)-[rel1:OFFERS|REQUESTS]->(expiringPending:Credex)-[rel2:OFFERS|REQUESTS]->(:Account),
    (expiringPending)-[:CREATED_ON]->(createdDaynode:Daynode)
    WHERE createdDaynode.Date + Duration({days: 1}) < daynode.Date
    DELETE rel1, rel2
    RETURN count(expiringPending) AS numberExpiringPending
  `);
    const numberExpiringPending = result.records[0]?.get("numberExpiringPending") || 0;
    console.log(`Expired pending offers/requests: ${numberExpiringPending}`);
}
async function fetchCurrencyRates(nextDate) {
    console.log("Fetching currency rates");
    const symbols = (0, denominations_1.getDenominations)({
        sourceForRate: "OpenExchangeRates",
        formatAsList: true,
    });
    const { data: { rates: USDbaseRates }, } = await axios_1.default.get(`https://openexchangerates.org/api/historical/${nextDate}.json`, { params: { app_id: process.env.OPEN_EXCHANGE_RATES_API, symbols } });
    const ZIGrates = await (0, fetchZigRate_1.fetchZigRate)();
    USDbaseRates.ZIG = ZIGrates.length > 0 ? parseFloat(ZIGrates[1].avg) : NaN;
    validateRates(USDbaseRates);
    return USDbaseRates;
}
function validateRates(rates) {
    const allDenoms = (0, denominations_1.getDenominations)({});
    const denomsToCheck = allDenoms.filter((denom) => denom.code !== "CXX");
    const allValid = denomsToCheck.every((denom) => rates.hasOwnProperty(denom.code) &&
        typeof rates[denom.code] === "number" &&
        !isNaN(rates[denom.code]));
    if (!allValid) {
        throw new Error("Invalid or missing currency rates");
    }
}
async function processDCOParticipants(session, USDbaseRates) {
    console.log("Processing DCO participants");
    const denomsInXAU = lodash_1.default.mapValues(USDbaseRates, (value) => value / USDbaseRates.XAU);
    const result = await session.run(`
    MATCH (daynode:Daynode{Active:true})
    MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
    WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
    RETURN
      DCOparticpantsDeclared.accountID AS accountID,
      DCOmember.memberID AS DCOmemberID,
      DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
      DCOparticpantsDeclared.DCOgiveInCXX / daynode[DCOparticpantsDeclared.DCOdenom] AS DCOgiveInDenom,
      DCOparticpantsDeclared.DCOdenom AS DCOdenom
  `);
    const declaredParticipants = result.records;
    console.log(`Declared participants: ${declaredParticipants.length}`);
    let DCOinCXX = 0;
    let DCOinXAU = 0;
    const confirmedParticipants = [];
    for (const participant of declaredParticipants) {
        const { accountID, DCOmemberID, DCOdenom, DCOgiveInCXX, DCOgiveInDenom } = participant.toObject();
        const { securableAmountInDenom } = await (0, GetSecuredAuthorization_1.GetSecuredAuthorizationService)(accountID, DCOdenom);
        if (DCOgiveInDenom <= securableAmountInDenom) {
            confirmedParticipants.push({
                accountID,
                DCOmemberID,
                DCOdenom,
                DCOgiveInCXX,
                DCOgiveInDenom,
            });
            DCOinCXX += DCOgiveInCXX;
            DCOinXAU += DCOgiveInDenom / denomsInXAU[DCOdenom];
        }
    }
    const numberConfirmedParticipants = confirmedParticipants.length;
    const nextCXXinXAU = DCOinXAU / numberConfirmedParticipants;
    const CXXprior_CXXcurrent = DCOinCXX / numberConfirmedParticipants;
    console.log(`Confirmed participants: ${numberConfirmedParticipants}`);
    console.log(`DCO in CXX: ${DCOinCXX}`);
    console.log(`DCO in XAU: ${DCOinXAU}`);
    console.log(`Next CXX in XAU: ${nextCXXinXAU}`);
    const newCXXrates = lodash_1.default.mapValues(denomsInXAU, (value) => 1 / nextCXXinXAU / value);
    newCXXrates.CXX = 1;
    logger_1.default.info("DCO Rates", {
        USDinXAU: denomsInXAU.XAU,
        CXXinXAU: newCXXrates.CXX,
        CXXprior_CXXcurrent,
    });
    return {
        newCXXrates,
        CXXprior_CXXcurrent,
        DCOinCXX,
        DCOinXAU,
        numberConfirmedParticipants,
        confirmedParticipants,
    };
}
async function createNewDaynode(session, newCXXrates, nextDate, CXXprior_CXXcurrent) {
    console.log("Creating new daynode");
    await session.run(`
    MATCH (expiringDaynode:Daynode {Active: TRUE})
    CREATE (expiringDaynode)-[:NEXT_DAY]->(nextDaynode:Daynode)
    SET expiringDaynode.Active = false,
        expiringDaynode.DCOrunningNow = false,
        nextDaynode = $newCXXrates,
        nextDaynode.CXXprior_CXXcurrent = $CXXprior_CXXcurrent,
        nextDaynode.Date = date($nextDate),
        nextDaynode.Active = true,
        nextDaynode.DCOrunningNow = true
  `, { newCXXrates, nextDate, CXXprior_CXXcurrent });
}
async function updateCredexBalances(ledgerSession, searchSession, newCXXrates, CXXprior_CXXcurrent) {
    console.log("Updating credex and asset balances");
    // Update ledger space
    await ledgerSession.run(`
    MATCH (newDaynode:Daynode {Active: TRUE})

    // Update CXX credexes
    MATCH (credcoinCredex:Credex)
    WHERE credcoinCredex.Denomination = "CXX"
    SET 
      credcoinCredex.InitialAmount = credcoinCredex.InitialAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.OutstandingAmount = credcoinCredex.OutstandingAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.RedeemedAmount = credcoinCredex.RedeemedAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.DefaultedAmount = credcoinCredex.DefaultedAmount / newDaynode.CXXprior_CXXcurrent,
      credcoinCredex.WrittenOffAmount = credcoinCredex.WrittenOffAmount / newDaynode.CXXprior_CXXcurrent

    // Update currency credexes
    MATCH (currencyCredex:Credex)
    WHERE currencyCredex.Denomination <> "CXX"
    SET
      currencyCredex.InitialAmount = (currencyCredex.InitialAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.OutstandingAmount = (currencyCredex.OutstandingAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.RedeemedAmount = (currencyCredex.RedeemedAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.DefaultedAmount = (currencyCredex.DefaultedAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.WrittenOffAmount = (currencyCredex.WrittenOffAmount / currencyCredex.CXXmultiplier) * newDaynode[currencyCredex.Denomination],
      currencyCredex.CXXmultiplier = newDaynode[currencyCredex.Denomination]

    // Update CXX :REDEEMED relationships
    MATCH ()-[CXXredeemed:REDEEMED]-()
    WHERE CXXredeemed.Denomination = "CXX"
    SET
      CXXredeemed.AmountRedeemed = CXXredeemed.AmountRedeemed / newDaynode.CXXprior_CXXcurrent,
      CXXredeemed.AmountOutstandingNow = CXXredeemed.AmountOutstandingNow / newDaynode.CXXprior_CXXcurrent

    // Update currency :REDEEMED relationships
    MATCH ()-[currencyRedeemed:REDEEMED]-()
    WHERE currencyRedeemed.Denomination <> "CXX"
    SET
      currencyRedeemed.AmountOutstandingNow = (currencyRedeemed.AmountOutstandingNow / currencyRedeemed.CXXmultiplier) * newDaynode[currencyRedeemed.Denomination],
      currencyRedeemed.AmountRedeemed = (currencyRedeemed.AmountRedeemed / currencyRedeemed.CXXmultiplier) * newDaynode[currencyRedeemed.Denomination],
      currencyRedeemed.CXXmultiplier = newDaynode[currencyRedeemed.Denomination]

    // Update CXX :CREDLOOP relationships
    MATCH ()-[CXXcredloop:CREDLOOP]-()
    WHERE CXXcredloop.Denomination = "CXX"
    SET
      CXXcredloop.AmountRedeemed = CXXcredloop.AmountRedeemed / newDaynode.CXXprior_CXXcurrent,
      CXXcredloop.AmountOutstandingNow = CXXcredloop.AmountOutstandingNow / newDaynode.CXXprior_CXXcurrent

    // Update currency :CREDLOOP relationships
    MATCH ()-[currencyCredloop:CREDLOOP]-()
    WHERE currencyCredloop.Denomination <> "CXX"
    SET
      currencyCredloop.AmountOutstandingNow = (currencyCredloop.AmountOutstandingNow / currencyCredloop.CXXmultiplier) * newDaynode[currencyCredloop.Denomination],
      currencyCredloop.AmountRedeemed = (currencyCredloop.AmountRedeemed / currencyCredloop.CXXmultiplier) * newDaynode[currencyCredloop.Denomination],
      currencyCredloop.CXXmultiplier = newDaynode[currencyCredloop.Denomination]

    // Update loop anchors (always CXX)
    MATCH (loopAnchors:LoopAnchor)
    SET
      loopAnchors.LoopedAmount = loopAnchors.LoopedAmount / newDaynode.CXXprior_CXXcurrent
  `);
    // Update search space
    await searchSession.run(`
    MATCH (credex:Credex)
    WHERE credex.Denomination = "CXX"
    SET credex.outstandingAmount = credex.outstandingAmount / $CXXprior_CXXcurrent
  `, { CXXprior_CXXcurrent });
    await searchSession.run(`
    MATCH (credex:Credex)
    WHERE credex.Denomination <> "CXX"
    WITH credex, $newCXXrates AS rates
    SET credex.outstandingAmount = (credex.outstandingAmount / credex.CXXmultiplier) * coalesce(rates[credex.Denomination], 1),
        credex.CXXmultiplier = coalesce(rates[credex.Denomination], 1)
  `, { newCXXrates });
}
async function getFoundationData(session) {
    const result = await session.run(`
    MATCH (credexFoundation:Account {accountType: "CREDEX_FOUNDATION"})<-[:OWNS]-(foundationXO:Member)
    RETURN credexFoundation.accountID AS foundationID, foundationXO.memberID AS foundationXOid
  `);
    return {
        foundationID: result.records[0].get("foundationID"),
        foundationXOid: result.records[0].get("foundationXOid"),
    };
}
async function processDCOTransactions(session, foundationID, foundationXOid, DCOinCXX, numberConfirmedParticipants) {
    console.log("Processing DCO transactions");
    const confirmedParticipants = (await session.run(`
    MATCH (daynode:Daynode{Active:true})
    MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
    WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
    RETURN
      DCOparticpantsDeclared.accountID AS accountID,
      DCOmember.memberID AS DCOmemberID,
      DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
      DCOparticpantsDeclared.DCOgiveInCXX / daynode[DCOparticpantsDeclared.DCOdenom] AS DCOgiveInDenom,
      DCOparticpantsDeclared.DCOdenom AS DCOdenom
  `)).records.map((record) => record.toObject());
    // Process DCO give transactions
    await Promise.all(confirmedParticipants.map(async (participant) => {
        const dataForDCOgive = {
            memberID: participant.DCOmemberID,
            issuerAccountID: participant.accountID,
            receiverAccountID: foundationID,
            Denomination: participant.DCOdenom,
            InitialAmount: participant.DCOgiveInDenom,
            credexType: "DCO_GIVE",
            securedCredex: true,
        };
        const DCOgiveCredex = await (0, OfferCredex_1.OfferCredexService)(dataForDCOgive);
        if (typeof DCOgiveCredex.credex === "boolean" ||
            !DCOgiveCredex.credex?.credexID) {
            throw new Error("Invalid response from OfferCredexService for DCO give");
        }
        await (0, AcceptCredex_1.AcceptCredexService)(DCOgiveCredex.credex.credexID, foundationXOid);
    }));
    // Process DCO receive transactions
    await Promise.all(confirmedParticipants.map(async (participant) => {
        const dataForDCOreceive = {
            memberID: foundationXOid,
            issuerAccountID: foundationID,
            receiverAccountID: participant.accountID,
            Denomination: "CXX",
            InitialAmount: DCOinCXX / numberConfirmedParticipants,
            credexType: "DCO_RECEIVE",
            securedCredex: true,
        };
        const DCOreceiveCredex = await (0, OfferCredex_1.OfferCredexService)(dataForDCOreceive);
        if (typeof DCOreceiveCredex.credex === "boolean" ||
            !DCOreceiveCredex.credex?.credexID) {
            throw new Error("Invalid response from OfferCredexService for DCO receive");
        }
        await (0, AcceptCredex_1.AcceptCredexService)(DCOreceiveCredex.credex.credexID, foundationXOid);
    }));
}
//# sourceMappingURL=DCOexecute.js.map


File: build/src/core-cron/DCO/fetchZigRate.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchZigRate = fetchZigRate;
const axios_1 = __importDefault(require("axios"));
const cheerio_1 = __importDefault(require("cheerio"));
const https = require("https");
const url = "https://www.rbz.co.zw/index.php";
const httpsAgent = new https.Agent({
    rejectUnauthorized: false, // To Ignore SSL errors in dev
});
async function fetchZigRate() {
    try {
        const { data } = await axios_1.default.get(url, { httpsAgent });
        const parsedHtml = cheerio_1.default.load(data);
        const rates = [];
        parsedHtml("#baTab1 table tbody tr").each((index, element) => {
            const currency = parsedHtml(element)
                .find("td")
                .eq(0)
                .text()
                .trim();
            const bid = parsedHtml(element).find("td").eq(1).text().trim();
            const ask = parsedHtml(element).find("td").eq(2).text().trim();
            const avg = parsedHtml(element).find("td").eq(3).text().trim();
            if (currency && bid && ask && avg) {
                rates.push({ currency, bid, ask, avg });
            }
        });
        //console.log(rates);
        return rates;
    }
    catch (error) {
        console.error("Error fetching exchange rates:", error);
        return [];
    }
}
//# sourceMappingURL=fetchZigRate.js.map


File: build/src/core-cron/DCO/DBinitialization.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBinitialization = DBinitialization;
const neo4j_1 = require("../../../config/neo4j");
const denominations_1 = require("../../constants/denominations");
const onboardMember_1 = require("../../api/Member/controllers/onboardMember");
const updateMemberTier_1 = require("../../api/Member/controllers/updateMemberTier");
const CreateAccount_1 = require("../../api/Account/services/CreateAccount");
const OfferCredex_1 = require("../../api/Credex/services/OfferCredex");
const AcceptCredex_1 = require("../../api/Credex/services/AcceptCredex");
const fetchZigRate_1 = require("./fetchZigRate");
const axios_1 = __importDefault(require("axios"));
const lodash_1 = __importDefault(require("lodash"));
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const logger_1 = __importDefault(require("../../../config/logger"));
/**
 * Initializes the database for the Daily Credcoin Offering (DCO) process.
 * This function sets up necessary constraints, creates initial accounts,
 * and establishes the starting state for the DCO.
 */
async function DBinitialization() {
    console.log("Starting DBinitialization");
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    try {
        await setupDatabaseConstraints(ledgerSpaceSession, searchSpaceSession);
        const dayZero = establishDayZero();
        const dayZeroCXXrates = await fetchAndProcessRates(dayZero);
        await createDayZeroDaynode(ledgerSpaceSession, dayZero, dayZeroCXXrates);
        await createInitialAccounts(ledgerSpaceSession);
    }
    catch (error) {
        logger_1.default.error("Error during DBinitialization", error);
        throw error;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
/**
 * Sets up necessary database constraints and indexes.
 */
async function setupDatabaseConstraints(ledgerSpaceSession, searchSpaceSession) {
    console.log("Creating database constraints and indexes...");
    // Remove any current db constraints
    await ledgerSpaceSession.run("CALL apoc.schema.assert({}, {})");
    await searchSpaceSession.run("CALL apoc.schema.assert({}, {})");
    // Set new constraints
    const constraints = [
        "CREATE CONSTRAINT daynodeDate_unique IF NOT EXISTS FOR (daynode:Daynode) REQUIRE daynode.Date IS UNIQUE",
        "CREATE CONSTRAINT memberID_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.memberID IS UNIQUE",
        "CREATE CONSTRAINT memberHandle_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.memberHandle IS UNIQUE",
        "CREATE CONSTRAINT memberPhone_unique IF NOT EXISTS FOR (member:Member) REQUIRE member.phone IS UNIQUE",
        "CREATE CONSTRAINT accountID_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountID IS UNIQUE",
        "CREATE CONSTRAINT accountHandle_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountHandle IS UNIQUE",
    ];
    for (const constraint of constraints) {
        await ledgerSpaceSession.run(constraint);
    }
    await searchSpaceSession.run("CREATE CONSTRAINT accountID_unique IF NOT EXISTS FOR (account:Account) REQUIRE account.accountID IS UNIQUE");
    await searchSpaceSession.run("CREATE CONSTRAINT credexID_unique IF NOT EXISTS FOR (credex:Credex) REQUIRE credex.credexID IS UNIQUE");
}
/**
 * Establishes the day zero date.
 */
function establishDayZero() {
    console.log("Establishing day zero");
    const dayZero = process.env.DEPLOYMENT === "dev"
        ? "2021-01-01"
        : moment_timezone_1.default.utc().subtract(1, "days").format("YYYY-MM-DD");
    console.log("Day zero:", dayZero);
    return dayZero;
}
/**
 * Fetches and processes currency rates for day zero.
 */
async function fetchAndProcessRates(dayZero) {
    console.log("Loading currencies and current rates...");
    const symbols = (0, denominations_1.getDenominations)({
        sourceForRate: "OpenExchangeRates",
        formatAsList: true,
    });
    const baseUrl = `https://openexchangerates.org/api/historical/${dayZero}.json?app_id=${process.env.OPEN_EXCHANGE_RATES_API}&symbols=${symbols}`;
    const { data: { rates: USDbaseRates }, } = await axios_1.default.get(baseUrl);
    USDbaseRates.ZIG = (await (0, fetchZigRate_1.fetchZigRate)())[1].avg;
    const OneCXXinCXXdenom = 1;
    const CXXdenom = "CAD";
    console.log(OneCXXinCXXdenom + " CXX = 1 " + CXXdenom);
    const XAUbaseRates = lodash_1.default.mapValues(USDbaseRates, (value) => value / USDbaseRates.XAU);
    const dayZeroCXXrates = lodash_1.default.mapValues(XAUbaseRates, (value) => (1 / value) * OneCXXinCXXdenom * XAUbaseRates[CXXdenom]);
    dayZeroCXXrates.CXX = 1;
    console.log("Day zero CXX rates:", dayZeroCXXrates);
    return dayZeroCXXrates;
}
/**
 * Creates the day zero daynode in the database.
 */
async function createDayZeroDaynode(session, dayZero, dayZeroCXXrates) {
    console.log("Creating day zero daynode...");
    await session.run(`
    CREATE (daynode:Daynode)
    SET daynode = $dayZeroCXXrates,
        daynode.Date = date($dayZero),
        daynode.Active = TRUE,
        daynode.DCOrunningNow = TRUE
  `, { dayZeroCXXrates, dayZero });
}
/**
 * Creates initial accounts and relationships for the DCO process.
 */
async function createInitialAccounts(session) {
    console.log("Creating initialization accounts and relationships...");
    const rdubs = await createRdubsAccount();
    const credexFoundationID = await createCredexFoundation(rdubs.onboardedMemberID);
    const greatSunID = await createGreatSun(rdubs.onboardedMemberID);
    const vimbisoPayID = await createVimbisoPay(rdubs.onboardedMemberID);
    await createInitialRelationships(session, credexFoundationID, greatSunID, vimbisoPayID);
    await createInitialCredex(rdubs.onboardedMemberID, greatSunID, rdubs.personalAccountID);
}
async function createRdubsAccount() {
    const result = await (0, onboardMember_1.OnboardMemberController)("Ryan", "Watson", "263778177125");
    if ("error" in result) {
        throw new Error(`Failed to create rdubs account: ${result.error}`);
    }
    const onboardedMemberID = result.memberDashboard.memberID;
    const updateTierResult = await (0, updateMemberTier_1.UpdateMemberTierController)(onboardedMemberID, 5);
    if (!updateTierResult.success) {
        throw new Error(`Failed to update member tier: ${updateTierResult.message}`);
    }
    const rdubsPersonalAccount = await (0, CreateAccount_1.CreateAccountService)(onboardedMemberID, "PERSONAL_CONSUMPTION", "Ryan Watson Personal", "263778177125", "USD", 1, "CAD");
    return {
        onboardedMemberID,
        personalAccountID: rdubsPersonalAccount.accountID,
    };
}
async function createCredexFoundation(memberID) {
    const credexFoundation = await (0, CreateAccount_1.CreateAccountService)(memberID, "CREDEX_FOUNDATION", "Credex Foundation", "credexfoundation", "CXX");
    if (typeof credexFoundation.account === "boolean" ||
        !credexFoundation.accountID) {
        throw new Error("Failed to create Credex Foundation account");
    }
    return credexFoundation.accountID;
}
async function createGreatSun(memberID) {
    const greatSun = await (0, CreateAccount_1.CreateAccountService)(memberID, "BUSINESS", "Great Sun Financial", "greatsunfinancial", "CAD");
    if (!greatSun || !greatSun.accountID) {
        throw new Error("Failed to create Great Sun account");
    }
    return greatSun.accountID;
}
async function createVimbisoPay(memberID) {
    const vimbisoPay = await (0, CreateAccount_1.CreateAccountService)(memberID, "BUSINESS", "VimbisoPay", "vimbisopay.audited", "CAD");
    if (!vimbisoPay || !vimbisoPay.accountID) {
        throw new Error("Failed to create VimbisoPay account");
    }
    return vimbisoPay.accountID;
}
async function createInitialRelationships(session, credexFoundationID, greatSunID, vimbisoPayID) {
    await session.run(`
    MATCH (credexFoundation: Account { accountID: $credexFoundationID })
    MATCH (greatSun: Account { accountID: $greatSunID })
    MATCH (vimbisoPay: Account { accountID: $vimbisoPayID })
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (credexFoundation)
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (greatSun)
    MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (vimbisoPay)
  `, { credexFoundationID, greatSunID, vimbisoPayID });
}
async function createInitialCredex(memberID, issuerAccountID, receiverAccountID) {
    const credexData = {
        memberID,
        issuerAccountID,
        receiverAccountID,
        Denomination: "CAD",
        InitialAmount: 365, // fund DCO for a year with no adjustments
        credexType: "PURCHASE",
        securedCredex: true,
    };
    const DCOinitializationOfferCredex = await (0, OfferCredex_1.OfferCredexService)(credexData);
    if (typeof DCOinitializationOfferCredex.credex === "boolean") {
        throw new Error("Invalid response from OfferCredexService");
    }
    if (DCOinitializationOfferCredex.credex &&
        typeof DCOinitializationOfferCredex.credex.credexID === "string") {
        await (0, AcceptCredex_1.AcceptCredexService)(DCOinitializationOfferCredex.credex.credexID, memberID);
    }
    else {
        throw new Error("Invalid credexID from OfferCredexService");
    }
}
//# sourceMappingURL=DBinitialization.js.map


File: build/src/core-cron/MTQ/MinuteTransactionQueue.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MinuteTransactionQueue = MinuteTransactionQueue;
const neo4j_1 = require("../../../config/neo4j");
const LoopFinder_1 = require("./LoopFinder");
const lodash_1 = __importDefault(require("lodash"));
const logger_1 = __importDefault(require("../../../config/logger"));
async function MinuteTransactionQueue() {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    logger_1.default.info("MTQ start: checking if DCO or MTQ is in progress");
    try {
        const { DCOflag, MTQflag } = await checkDCOAndMTQStatus(ledgerSpaceSession);
        if (DCOflag === null || MTQflag === null) {
            logger_1.default.warn("No active daynode found. Skipping MTQ.");
            return false;
        }
        if (DCOflag || MTQflag) {
            if (DCOflag)
                logger_1.default.info("DCO in progress, holding MTQ");
            if (MTQflag)
                logger_1.default.info("MTQ already in progress, holding new MTQ");
            return false;
        }
        logger_1.default.info("Running MTQ");
        await setMTQRunningFlag(ledgerSpaceSession, true);
        const BAIL_TIME = 14 * 60 * 1000; // 14 minutes
        const bailTimer = setTimeout(() => {
            logger_1.default.warn("Bail timer reached");
            return true;
        }, BAIL_TIME);
        try {
            await processQueuedAccounts(ledgerSpaceSession, searchSpaceSession);
            await processQueuedCredexes(ledgerSpaceSession, searchSpaceSession);
        }
        finally {
            clearTimeout(bailTimer);
            await setMTQRunningFlag(ledgerSpaceSession, false);
        }
        logger_1.default.info("MTQ processing completed");
        return true;
    }
    catch (error) {
        logger_1.default.error("Error in MinuteTransactionQueue:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
async function checkDCOAndMTQStatus(session) {
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN
      daynode.DCOrunningNow AS DCOflag,
      daynode.MTQrunningNow AS MTQflag
  `);
    if (result.records.length === 0) {
        logger_1.default.warn("No active daynode found");
        return { DCOflag: null, MTQflag: null };
    }
    return {
        DCOflag: result.records[0].get("DCOflag"),
        MTQflag: result.records[0].get("MTQflag"),
    };
}
async function setMTQRunningFlag(session, value) {
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    SET daynode.MTQrunningNow = $value
    RETURN daynode
  `, { value });
    if (result.records.length === 0) {
        logger_1.default.warn("No active daynode found when setting MTQ running flag");
    }
}
async function processQueuedAccounts(ledgerSpaceSession, searchSpaceSession) {
    const queuedAccounts = await getQueuedAccounts(ledgerSpaceSession);
    for (const account of queuedAccounts) {
        try {
            await createAccountInSearchSpace(searchSpaceSession, account);
            await markAccountAsProcessed(ledgerSpaceSession, account.accountID);
            logger_1.default.info(`Account created in searchSpace: ${account.accountName}`);
        }
        catch (error) {
            logger_1.default.error(`Error processing account ${account.accountName}:`, error);
        }
    }
}
async function getQueuedAccounts(session) {
    const result = await session.run(`
    MATCH (newAccount:Account {queueStatus: "PENDING_ACCOUNT"})
    RETURN
      newAccount.accountID AS accountID,
      newAccount.accountName AS accountName
  `);
    return result.records.map((record) => ({
        accountID: record.get("accountID"),
        accountName: record.get("accountName"),
    }));
}
async function createAccountInSearchSpace(session, account) {
    const result = await session.run(`
    CREATE (newAccount:Account)
    SET newAccount = $account
    RETURN newAccount.accountID AS accountID
    `, { account });
    if (result.records.length === 0) {
        throw new Error(`Failed to create account in searchSpace: ${account.accountName}`);
    }
}
async function markAccountAsProcessed(session, accountID) {
    await session.run(`
    MATCH (processedAccount:Account {accountID: $accountID})
    SET processedAccount.queueStatus = "PROCESSED"
    `, { accountID });
}
async function processQueuedCredexes(ledgerSpaceSession, searchSpaceSession) {
    const queuedCredexes = await getQueuedCredexes(ledgerSpaceSession);
    const sortedQueuedCredexes = lodash_1.default.sortBy(queuedCredexes, "acceptedAt");
    for (const credex of sortedQueuedCredexes) {
        try {
            await (0, LoopFinder_1.LoopFinder)(credex.issuerAccountID, credex.credexID, credex.amount, credex.denomination, credex.CXXmultiplier, credex.credexSecuredDenom, credex.dueDate, credex.acceptorAccountID);
        }
        catch (error) {
            logger_1.default.error(`Error processing credex ${credex.credexID}:`, error);
        }
    }
}
async function getQueuedCredexes(session) {
    const result = await session.run(`
    MATCH
      (issuerAccount:Account)
      -[:OWES]->(queuedCredex:Credex {queueStatus: "PENDING_CREDEX"})
      -[:OWES]->(acceptorAccount:Account)
    OPTIONAL MATCH (queuedCredex)<-[:SECURES]-(securer:Account)
    RETURN queuedCredex.acceptedAt AS acceptedAt,
           issuerAccount.accountID AS issuerAccountID,
           acceptorAccount.accountID AS acceptorAccountID,
           securer.accountID AS securerID,
           queuedCredex.credexID AS credexID,
           queuedCredex.InitialAmount AS amount,
           queuedCredex.Denomination AS denomination,
           queuedCredex.CXXmultiplier AS CXXmultiplier,
           queuedCredex.dueDate AS dueDate
  `);
    return result.records.map((record) => ({
        acceptedAt: record.get("acceptedAt"),
        issuerAccountID: record.get("issuerAccountID"),
        acceptorAccountID: record.get("acceptorAccountID"),
        credexID: record.get("credexID"),
        amount: record.get("amount").toNumber(),
        denomination: record.get("denomination"),
        CXXmultiplier: record.get("CXXmultiplier").toNumber(),
        credexSecuredDenom: record.get("securerID") !== null
            ? record.get("denomination")
            : "floating",
        dueDate: record.get("dueDate"),
    }));
}
//# sourceMappingURL=MinuteTransactionQueue.js.map


File: build/src/core-cron/MTQ/LoopFinder.js
----------------------------------------
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoopFinder = LoopFinder;
const neo4j_1 = require("../../../config/neo4j");
const logger_1 = __importDefault(require("../../../config/logger"));
async function LoopFinder(issuerAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexSecuredDenom, credexDueDate, acceptorAccountID) {
    const ledgerSpaceSession = neo4j_1.ledgerSpaceDriver.session();
    const searchSpaceSession = neo4j_1.searchSpaceDriver.session();
    try {
        const searchOwesType = getSearchOwesType(credexSecuredDenom);
        credexDueDate = await adjustCredexDueDate(ledgerSpaceSession, credexSecuredDenom, credexDueDate);
        await createOrUpdateSearchSpaceCredex(searchSpaceSession, issuerAccountID, acceptorAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexDueDate, searchOwesType);
        let searchForCredloops = true;
        while (searchForCredloops) {
            logger_1.default.info("Searching for credloops...");
            const { valueToClear, credexesInLoop, credexesRedeemed } = await findCredloop(searchSpaceSession, issuerAccountID, searchOwesType);
            if (credexesInLoop.length > 0) {
                await processCredloop(ledgerSpaceSession, searchSpaceSession, valueToClear, credexesInLoop, credexesRedeemed);
            }
            else {
                await markCredexAsProcessed(ledgerSpaceSession, credexID);
                logger_1.default.info("No credloops found. Credex marked as processed.");
                searchForCredloops = false;
            }
        }
        return true;
    }
    catch (error) {
        logger_1.default.error("Error in LoopFinder:", error);
        return false;
    }
    finally {
        await ledgerSpaceSession.close();
        await searchSpaceSession.close();
    }
}
function getSearchOwesType(credexSecuredDenom) {
    return credexSecuredDenom !== "floating" ? `${credexSecuredDenom}_SECURED` : "FLOATING";
}
async function adjustCredexDueDate(session, credexSecuredDenom, credexDueDate) {
    if (credexSecuredDenom !== "floating") {
        const result = await session.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.Date AS today
    `);
        return result.records[0].get("today");
    }
    return credexDueDate;
}
async function createOrUpdateSearchSpaceCredex(session, issuerAccountID, acceptorAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexDueDate, searchOwesType) {
    const credexExists = await checkCredexExists(session, credexID);
    if (!credexExists) {
        await createSearchSpaceCredex(session, issuerAccountID, acceptorAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexDueDate, searchOwesType);
    }
    else {
        logger_1.default.info(`Credex already exists in SearchSpace: ${credexID}`);
    }
}
async function checkCredexExists(session, credexID) {
    const result = await session.run(`
    OPTIONAL MATCH (credex:Credex {credexID: $credexID})
    RETURN credex IS NOT NULL AS credexExists
    `, { credexID });
    return result.records[0].get("credexExists");
}
async function createSearchSpaceCredex(session, issuerAccountID, acceptorAccountID, credexID, credexAmount, Denomination, CXXmultiplier, credexDueDate, searchOwesType) {
    try {
        const result = await session.run(`
      MATCH (issuer:Account {accountID: $issuerAccountID})
      MATCH (acceptor:Account {accountID: $acceptorAccountID})
      MERGE (issuer)-[:${searchOwesType}]->(searchOwesType:${searchOwesType})-[:${searchOwesType}]->(acceptor)
        ON CREATE SET searchOwesType.searchAnchorID = randomUUID()
      CREATE (searchOwesType)<-[:SEARCH_SECURED]-(credex:Credex {
          credexID: $credexID,
          outstandingAmount: $credexAmount,
          Denomination: $Denomination,
          CXXmultiplier: $CXXmultiplier,
          dueDate: date($credexDueDate)
      })
      WITH searchOwesType, credex
      CALL apoc.do.case(
          [
              searchOwesType.earliestDueDate IS NULL
              OR searchOwesType.earliestDueDate > date($credexDueDate), 
              'SET searchOwesType.earliestDueDate = date($credexDueDate) RETURN true'
          ],
          'RETURN false',
          {
            searchOwesType: searchOwesType,
            credexDueDate: credex.dueDate
          }
      ) YIELD value
      RETURN credex.credexID AS credexID
      `, {
            issuerAccountID,
            acceptorAccountID,
            credexID,
            credexAmount,
            Denomination,
            CXXmultiplier,
            credexDueDate,
            searchOwesType,
        });
        if (result.records.length === 0) {
            throw new Error("Unable to create SearchSpace credex");
        }
        logger_1.default.info(`Credex created in SearchSpace: ${result.records[0].get("credexID")}`);
    }
    catch (error) {
        logger_1.default.error("Error creating SearchSpace credex:", error);
        throw error;
    }
}
async function findCredloop(session, issuerAccountID, searchOwesType) {
    const result = await session.run(`
    // Step 1: Find all loops starting and ending at the specified account, with the specified searchOwesType
    MATCH credloops = (issuer:Account {accountID: $issuerAccountID})-[:${searchOwesType}*]->(issuer)
    
    WITH credloops, nodes(credloops) AS loopNodes
    UNWIND loopNodes AS node
    WITH credloops, node
    WITH credloops, MIN(node.earliestDueDate) AS earliestDueDate

    // Step 3: Filter loops to include only those containing a node with the earliest earliestDueDate
    WITH credloops, earliestDueDate, nodes(credloops) AS loopNodes
    UNWIND loopNodes AS node
    WITH credloops, node
    WHERE node.earliestDueDate = earliestDueDate
    WITH credloops, length(credloops) AS loopLength

    // Step 4: Return only the longest loop, breaking ties with rand()
    ORDER BY loopLength DESC, rand()
    LIMIT 1
    WITH nodes(credloops) AS credloopNodes

    // Step 5: Each node returns the credex it is connected to with the earliest dueDate
    // on tie, credex with largest amount
    UNWIND credloopNodes AS loopNode
    MATCH (loopNode)<-[:SEARCH_SECURED]-(credex:Credex)
    WITH loopNode, collect(credex) AS credexList
    WITH 
           reduce(minCredex = credexList[0], c IN credexList | 
                  CASE 
                    WHEN c.dueDate < minCredex.dueDate THEN c
                    WHEN c.dueDate = minCredex.dueDate AND c.outstandingAmount > minCredex.outstandingAmount THEN c
                    ELSE minCredex 
                  END) AS earliestCredex
    WITH collect(earliestCredex) AS finalCredexes, COLLECT(earliestCredex.credexID) AS credexIDs

    // Step 6: Identify the minimum outstandingAmount and subtract it from all credexes
    UNWIND finalCredexes AS credexInLoop
    WITH finalCredexes, min(credexInLoop.outstandingAmount) AS lowestAmount, credexIDs

    UNWIND finalCredexes AS credex
    SET credex.outstandingAmount = credex.outstandingAmount - lowestAmount

    // Step 7: Collect all credexes and filter those with outstandingAmount = 0.
    WITH lowestAmount, COLLECT(credex) AS allCredexes, credexIDs
    WITH lowestAmount, allCredexes, [credex IN allCredexes WHERE credex.outstandingAmount = 0] AS zeroCredexes, credexIDs

    //Step 8: collect credexIDs of the zeroCredexes
    UNWIND zeroCredexes as zeroCredex
    RETURN collect(zeroCredex.credexID) AS zeroCredexIDs, lowestAmount, credexIDs
    `, { issuerAccountID, searchOwesType });
    if (result.records.length > 0) {
        return {
            valueToClear: result.records[0].get("lowestAmount").toNumber(),
            credexesInLoop: result.records[0].get("credexIDs"),
            credexesRedeemed: result.records[0].get("zeroCredexIDs")
        };
    }
    return { valueToClear: 0, credexesInLoop: [], credexesRedeemed: [] };
}
async function processCredloop(ledgerSpaceSession, searchSpaceSession, valueToClear, credexesInLoop, credexesRedeemed) {
    logger_1.default.info("Credexes in loop:", credexesInLoop);
    logger_1.default.info("Credexes redeemed:", credexesRedeemed);
    await cleanupSearchSpace(searchSpaceSession, credexesRedeemed);
    await updateLedgerSpace(ledgerSpaceSession, valueToClear, credexesInLoop, credexesRedeemed);
}
async function cleanupSearchSpace(session, credexesRedeemed) {
    await session.run(`
    // Step 10: Delete zeroCredexes
    UNWIND $credexesRedeemed AS credexRedeemedID
    MATCH (credex:Credex {credexID: credexRedeemedID})-[:SEARCH_SECURED]->(searchAnchor)
    DETACH DELETE credex
    WITH DISTINCT searchAnchor

    // Step 11: Handle orphaned searchAnchors
    OPTIONAL MATCH (searchAnchor)<-[:SEARCH_SECURED]-(otherCredex:Credex)
    WITH searchAnchor, collect(otherCredex) AS otherCredexes
    CALL apoc.do.when(
      size(otherCredexes) = 0,
      'DETACH DELETE searchAnchor RETURN "searchAnchorDeleted" AS result',
      'RETURN "noChanges" AS result',
      {searchAnchor: searchAnchor}
    ) YIELD value AS deleteValue
    WITH deleteValue, searchAnchor, otherCredexes
    WHERE deleteValue <> "searchAnchorDeleted"

    // Step 12: Update earliestDueDate on remaining searchAnchors
    UNWIND otherCredexes AS otherCredex
    WITH DISTINCT searchAnchor, otherCredex
    CALL apoc.do.when(
      (searchAnchor.earliestDueDate IS NULL OR searchAnchor.earliestDueDate > date(otherCredex.dueDate)),
      'SET searchAnchor.earliestDueDate = date(otherCredex.dueDate) RETURN "searchAnchorEarliestUpdated" AS result',
      'RETURN "noChanges" AS result',
      {searchAnchor: searchAnchor, otherCredex: otherCredex}
    ) YIELD value AS updateValue
    RETURN searchAnchor
    `, { credexesRedeemed });
}
async function updateLedgerSpace(session, valueToClear, credexesInLoop, credexesRedeemed) {
    logger_1.default.info(`Credloop of ${valueToClear} CXX found and cleared, now updating ledgerSpace`);
    const result = await session.run(`
    MATCH (daynode:Daynode {Active: true})
    CREATE (loopAnchor:LoopAnchor {
        loopedAt: DateTime(),
        loopID: randomUUID(),
        LoopedAmount: $valueToClear,
        CXXmultiplier: 1,
        Denomination: "CXX"
    })-[to_daynode:CREATED_ON]->(daynode)
    WITH loopAnchor

    UNWIND $credexesInLoop AS credexID
    MATCH (thisCredex:Credex {credexID: credexID})
    SET thisCredex.OutstandingAmount = thisCredex.OutstandingAmount - $valueToClear,
        thisCredex.RedeemedAmount = thisCredex.RedeemedAmount + $valueToClear
    WITH thisCredex, loopAnchor
    CREATE (thisCredex)-[:REDEEMED {
        AmountRedeemed: $valueToClear,
        AmountOutstandingNow: thisCredex.OutstandingAmount,
        Denomination: thisCredex.Denomination,
        CXXmultiplier: thisCredex.CXXmultiplier,
        createdAt: DateTime(),
        redeemedRelID: randomUUID()
    }]->(loopAnchor)

    WITH thisCredex, loopAnchor
    MATCH (loopAnchor)<-[:REDEEMED]-(thisCredex)
      -[:OWES]->(:Account)-[:OWES]->(nextCredex:Credex)
      -[:REDEEMED]->(loopAnchor)
    CREATE (thisCredex)-[:CREDLOOP {
        AmountRedeemed: $valueToClear,
        AmountOutstandingNow: thisCredex.OutstandingAmount,
        Denomination: thisCredex.Denomination,
        CXXmultiplier: thisCredex.CXXmultiplier,
        createdAt: DateTime(),
        loopID: loopAnchor.loopID,
        credloopRelID: randomUUID()
    }]->(nextCredex)

    WITH DISTINCT loopAnchor
    UNWIND $credexesRedeemed AS redeemedCredexID
    MATCH
      (owesOutAccount:Account)-[owes1:OWES]->
        (thisRedeemedCredex:Credex {credexID: redeemedCredexID})-[owes2:OWES]->
        (owesInAccount:Account),
      (thisRedeemedCredex)-[:REDEEMED]->(loopAnchor)
    CREATE
      (owesOutAccount)-[:CLEARED]->(thisRedeemedCredex)-[:CLEARED]->(owesInAccount)
    SET thisRedeemedCredex.DateRedeemed = DateTime()
    DELETE owes1, owes2

    RETURN DISTINCT loopAnchor.loopID AS loopID
    `, { valueToClear, credexesInLoop, credexesRedeemed });
    logger_1.default.info(`LoopAnchor created: ${result.records[0].get("loopID")}`);
}
async function markCredexAsProcessed(session, credexID) {
    await session.run(`
    MATCH (processedCredex:Credex {credexID: $credexID})
    SET processedCredex.queueStatus = "PROCESSED"
    RETURN processedCredex.credexID AS credexID
    `, { credexID });
}
// TODO: Implement notification system
/*
async function createNotifications(session: Session, loopID: string): Promise<void> {
  // Implementation for creating notifications
}
*/
//# sourceMappingURL=LoopFinder.js.map


File: build/src/index.js
----------------------------------------
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.apiVersionOneRoute = exports.app = void 0;
// Import required modules and dependencies
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const memberRoutes_1 = __importDefault(require("./api/Member/memberRoutes"));
const accountRoutes_1 = __importDefault(require("./api/Account/accountRoutes"));
const credexRoutes_1 = __importDefault(require("./api/Credex/credexRoutes"));
const testRoutes_1 = __importDefault(require("./tests/testRoutes"));
const recurringRoutes_1 = __importDefault(require("./api/Avatar/recurringRoutes"));
const logger_1 = __importStar(require("../config/logger"));
const body_parser_1 = __importDefault(require("body-parser"));
const cronJobs_1 = __importDefault(require("./core-cron/cronJobs"));
const authenticate_1 = __importDefault(require("../config/authenticate"));
const helmet_1 = __importDefault(require("helmet"));
const cors_1 = __importDefault(require("cors"));
const express_rate_limit_1 = __importDefault(require("express-rate-limit"));
const adminDashboardRoutes_1 = __importDefault(require("./api/AdminDashboard/adminDashboardRoutes"));
const errorHandler_1 = require("../middleware/errorHandler");
const config_1 = require("../config/config");
const swagger_ui_express_1 = __importDefault(require("swagger-ui-express"));
const swagger_1 = require("../config/swagger");
// Create an Express application
exports.app = (0, express_1.default)();
// Create a JSON parser middleware
const jsonParser = body_parser_1.default.json();
// Define the API version route prefix
exports.apiVersionOneRoute = "/api/v1/";
// Apply security middleware
exports.app.use((0, helmet_1.default)()); // Helps secure Express apps with various HTTP headers
exports.app.use((0, cors_1.default)()); // Enable Cross-Origin Resource Sharing (CORS)
// Apply custom logging middleware
exports.app.use(logger_1.expressLogger);
// Serve Swagger UI for API documentation
exports.app.use("/api-docs", swagger_ui_express_1.default.serve, swagger_ui_express_1.default.setup(swagger_1.swaggerSpec));
// Apply authentication middleware to all routes under the API version prefix
exports.app.use(exports.apiVersionOneRoute, authenticate_1.default);
// Set up rate limiting to prevent abuse
// NOTE: With all requests coming from a single WhatsApp chatbot, rate limiting might cause issues
// Consider adjusting or removing rate limiting based on your specific use case
const limiter = (0, express_rate_limit_1.default)({
    windowMs: config_1.config.rateLimit.windowMs, // Time window for rate limiting
    max: config_1.config.rateLimit.max, // Maximum number of requests per window
    message: "Too many requests from this IP, please try again after 15 minutes",
});
exports.app.use(limiter);
// Start cron jobs for scheduled tasks (e.g., daily credcoin offering, minute transaction queue)
(0, cronJobs_1.default)();
// Apply route handlers for different modules
exports.app.use(`${exports.apiVersionOneRoute}member`, jsonParser, memberRoutes_1.default);
(0, accountRoutes_1.default)(exports.app, jsonParser);
(0, credexRoutes_1.default)(exports.app, jsonParser);
(0, adminDashboardRoutes_1.default)(exports.app, jsonParser);
(0, recurringRoutes_1.default)(exports.app, jsonParser);
// Conditionally apply Test routes based on deployment environment
if (config_1.config.deployment === "demo" || config_1.config.deployment === "dev") {
    (0, testRoutes_1.default)(exports.app, jsonParser);
}
// Apply error handling middleware
exports.app.use(errorHandler_1.notFoundHandler); // Handle 404 errors
exports.app.use(errorHandler_1.errorHandler); // Handle all other errors
// Create HTTP server
const server = http_1.default.createServer(exports.app);
// Start the server
if (require.main === module) {
    server.listen(config_1.config.port, () => {
        logger_1.default.info(`Server is running on http://localhost:${config_1.config.port}`);
        logger_1.default.info(`API documentation available at http://localhost:${config_1.config.port}/api-docs`);
        logger_1.default.info(`Server started at ${new Date().toISOString()}`);
        logger_1.default.info(`Environment: ${config_1.config.nodeEnv}`);
        logger_1.default.info(`Deployment type: ${config_1.config.deployment}`);
    });
}
// Handle uncaught exceptions
process.on("uncaughtException", (error) => {
    logger_1.default.error("Uncaught Exception:", error);
    // Perform any necessary cleanup
    // TODO: Implement a more robust error reporting mechanism (e.g., send to a monitoring service)
    // Gracefully shut down the server
    server.close(() => {
        logger_1.default.info("Server closed due to uncaught exception");
        process.exit(1);
    });
});
// Handle unhandled rejections
process.on("unhandledRejection", (reason, promise) => {
    logger_1.default.error("Unhandled Rejection at:", promise, "reason:", reason);
    // Perform any necessary cleanup
    // TODO: Implement a more robust error reporting mechanism (e.g., send to a monitoring service)
});
// Implement graceful shutdown
process.on("SIGTERM", () => {
    logger_1.default.info("SIGTERM signal received: closing HTTP server");
    server.close(() => {
        logger_1.default.info("HTTP server closed");
        // Perform any additional cleanup (e.g., close database connections)
        process.exit(0);
    });
});
//# sourceMappingURL=index.js.map


File: .devcontainer/devcontainer.json
----------------------------------------
{
  "name": "Credex Core Dev Container",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:1-22-bookworm",
  "customizations": {
    "vscode": {
      "extensions": [
        "esbenp.prettier-vscode",
        "Postman.postman-for-vscode",
        "saoudrizwan.claude-dev",
        "GitHub.copilot",
        "dbaeumer.vscode-eslint",
        "ms-azuretools.vscode-docker",
        "eamodio.gitlens",
        "yzhang.markdown-all-in-one"
      ],
      "settings": {
        "editor.formatOnSave": true,
        "editor.codeActionsOnSave": {
          "source.fixAll.eslint": true
        }
      }
    }
  },
  "features": {
    "ghcr.io/devcontainers/features/node:1": {
      "version": "18"
    },
    "ghcr.io/devcontainers/features/git:1": {}
  },
  "forwardPorts": [5000],
  "postCreateCommand": "npm install && npm install -g nodemon",
  "remoteEnv": {
    "NODE_ENV": "development"
  }
}



File: .github/dependabot.yml
----------------------------------------
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for more information:
# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates
# https://containers.dev/guide/dependabot

version: 2
updates:
  - package-ecosystem: "devcontainers"
    directory: "/"
    schedule:
      interval: weekly



File: .github/workflows/prod.yml
----------------------------------------
name: deploy_to_prod
run-name: ${{ github.actor }} pushed to prod_auto_deploy_setup with commit message '${{ github.event.head_commit.message }}'

on:
  push:
    branches:
      - prod

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: "18"

      - name: Install dependencies
        run: npm install
        working-directory: .

      - name: Set up SSH deploy keys
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Set ownership on remote server
        run: |
          echo "${{ secrets.SSH_KEY }}" > private_key.pem
          chmod 600 private_key.pem

          # Create known_hosts file if it doesn't exist
          mkdir -p /home/runner/.ssh
          touch /home/runner/.ssh/known_hosts
          # Clear old key from known_hosts
          ssh-keygen -R ${{ secrets.EC2_IP }} >> /home/runner/.ssh/known_hosts
          ssh-keyscan -H ${{ secrets.EC2_IP }} >> /home/runner/.ssh/known_hosts

          # Run the SSH command
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_IP }} \
          "cd credex-core &&
            git checkout prod &&
            docker-compose up --build"
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_KEY }}



File: .github/workflows/stage.yml
----------------------------------------
# Documentation https://github.com/appleboy/ssh-action
name: Credex Staging Deployment
on:
  push:
    branches: [stage]

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Executing remote ssh commands using key
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DEMO_SERVER_HOST }}
          username: ${{ secrets.DEMO_SERVER_USER }}
          password: ${{ secrets.DEMO_SERVER_SSH_PASSWORD }}
          port: ${{ secrets.SSH_PORT }}
          command_timeout: 25m
          script: |
            cd credex-core
            git checkout stage
            git pull
            docker compose up --build -d

  post:
    name: Slack Notification Sender
    runs-on: ubuntu-latest
    steps:
      - name: Send custom JSON data to Slack workflow
        id: slack
        uses: slackapi/slack-github-action@v1.23.0
        with:
          # This data can be any valid JSON from a previous step in the GitHub Action
          payload: |
            {
              "text": "${{ github.actor }} created commit.",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": ":desktop_computer:  ${{ github.actor }} created commit:  :desktop_computer:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": " :left_speech_bubble: *Commit Details* :left_speech_bubble:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Commit message: ${{ github.event.commits[0].message }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Repository: ${{ github.repository }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "GitHub Action build result: ${{ job.status }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "See changes: ${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
                  }
                },
                {
                  "type": "divider"
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK



