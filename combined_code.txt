Current Branch: request-recurring-payments
----------------------------------------
File: ./package.json
----------------------------------------
{
  "name": "credex-core-express",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "nodemon": "nodemon",
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc",
    "watch:build": "tsc --watch"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/cors": "^2.8.17",
    "@types/jsonwebtoken": "^9.0.6",
    "axios": "^1.6.8",
    "bcrypt": "^5.1.1",
    "body-parser": "^1.20.2",
    "cheerio": "^1.0.0-rc.12",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "moment-timezone": "^0.5.45",
    "neo4j-driver": "^5.20.0",
    "node-cron": "^3.0.3",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@types/body-parser": "^1.19.5",
    "@types/express": "^4.17.21",
    "@types/lodash": "^4.17.1",
    "@types/node-cron": "^3.0.11",
    "@types/uuid": "^10.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5"
  }
}



File: ./src/DevAdmin/devAdminRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { ClearDevDbController } from "./controllers/clearDevDb";
import { ForceDcoController } from "./controllers/forceDCO";
import { ForceMtqController } from "./controllers/forceMTQ";
import { OfferAndAcceptCredexController } from "./controllers/offerAndAcceptCredex";
import { CreateTestMembersAndAccountsController } from "./controllers/createTestMembersAndAccounts";
import { CreateRandomFloatingCredexesController } from "./controllers/createRandomFloatingCredexes";
import { CreateTestLoopController } from "./controllers/createTestLoop";
import { GrowthTestController } from "./controllers/growthTest";
import { CheckLedgerVsSearchBalancesController } from "./controllers/checkLedgerVsSearchBalances";

export default function DevAdminRoutes(app: express.Application, jsonParser: any) {
    app.delete(
      `${apiVersionOneRoute}clearDevDB`,
      jsonParser,
      ClearDevDbController
    );

    app.post(`${apiVersionOneRoute}forceDCO`, jsonParser, ForceDcoController);
    app.post(`${apiVersionOneRoute}forceMTQ`, jsonParser, ForceMtqController);

    app.post(
      `${apiVersionOneRoute}offerAndAcceptCredex`,
      jsonParser,
      OfferAndAcceptCredexController
    );

    app.post(
      `${apiVersionOneRoute}createTestMembersAndAccounts`,
      jsonParser,
      CreateTestMembersAndAccountsController
    );

    app.post(
      `${apiVersionOneRoute}createRandomFloatingCredexes`,
      jsonParser,
      CreateRandomFloatingCredexesController
    );

    app.post(
      `${apiVersionOneRoute}createTestLoop`,
      jsonParser,
      CreateTestLoopController
    );

    app.post(
      `${apiVersionOneRoute}growthTest`,
      jsonParser,
      GrowthTestController
    );

    app.get(
      `${apiVersionOneRoute}checkLedgerVsSearchBalances`,
      jsonParser,
      CheckLedgerVsSearchBalancesController
    );
}



File: ./src/DevAdmin/controllers/growthTest.ts
----------------------------------------
import express from "express";
import { GrowthTestService } from "../services/GrowthTest";

export async function GrowthTestController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = [
    "numberDays",
    "accountGrowthRate",
    "USD_SECURED_fractionToPurchase",
    "USD_SECURED_amountPerPurchaseLow",
    "USD_SECURED_amountPerPurchaseHigh",
    "USD_SECURED_fractionToSell",
    "ZIG_SECURED_fractionToPurchase",
    "ZIG_SECURED_amountPerPurchaseLow",
    "ZIG_SECURED_amountPerPurchaseHigh",
    "ZIG_SECURED_fractionToSell",
    "dailyFloatingRandomTransactionsPerAccount",
  ];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }
  try {
    const responseData = await GrowthTestService(req.body);
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error in growthTest:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/createRandomFloatingCredexes.ts
----------------------------------------
import express from "express";
import { CreateRandomFloatingCredexesService } from "../services/CreateRandomFloatingCredexes";

export async function CreateRandomFloatingCredexesController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewTransactions is provided in the request body
  if (!req.body.numNewTransactions) {
    return res.status(400).json({ message: "numNewTransactions is required" });
  }

  try {
    // Call the service to create test transactions
    const responseData = await CreateRandomFloatingCredexesService(
      req.body.numNewTransactions
    );

    // Send the response with the created test transactions
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test transactions:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/createTestMembersAndAccounts.ts
----------------------------------------
import express from "express";
import { CreateTestMembersAndAccountsService } from "../services/CreateTestMembersAndAccounts";

export async function CreateTestMembersAndAccountsController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewAccounts is provided in the request body
  if (!req.body.numNewAccounts) {
    return res.status(400).json({ message: "numNewAccounts is required" });
  }

  try {
    // Call the service to create test accounts
    const responseData = await CreateTestMembersAndAccountsService(
      req.body.numNewAccounts
    );

    // Send the response with the created test accounts
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test accounts:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/clearDevDb.ts
----------------------------------------
import express from "express";
import { ClearDevDbService } from "../services/ClearDevDb";

export async function ClearDevDbController(
  req: express.Request,
  res: express.Response,
) {
  try {
    // Call the service to clear the development database
    await ClearDevDbService();

    // Send a success response
    res
      .status(200)
      .json({ message: "Development databases cleared successfully" });
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error clearing development databases:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/forceDCO.ts
----------------------------------------
import express from "express";
import { DailyCredcoinOffering } from "../../Core/DCO/DailyCredcoinOffering";

export async function ForceDcoController(
  req: express.Request,
  res: express.Response
) {
  try {
    const responseData = await DailyCredcoinOffering();
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/DevAdmin/controllers/forceMTQ.ts
----------------------------------------
import express from "express";
import { MinuteTransactionQueue } from "../../Core/MTQ/MinuteTransactionQueue";

export async function ForceMtqController(
  req: express.Request,
  res: express.Response
) {
  try {
    const responseData = await MinuteTransactionQueue();
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/DevAdmin/controllers/offerAndAcceptCredex.ts
----------------------------------------
import express from "express";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";

export async function OfferAndAcceptCredexController(
  req: express.Request,
  res: express.Response
) {
  try {
    /*
    const responseDataOffer = await OfferCredexService(req.body);
    if (typeof responseDataOffer.credex == "boolean") {
      throw new Error("Invalid response from OfferCredexService");
    }
    if (
      responseDataOffer.credex &&
      typeof responseDataOffer.credex.credexID === "string"
    ) {
      const responseDataAccept = await AcceptCredexService(
        responseDataOffer.credex.credexID
      );
      if (responseDataAccept) {
        res.json(responseDataAccept.acceptedCredexID);
      }
    } else {
      res.status(500).json(responseDataOffer.message);
    }
      */
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/DevAdmin/controllers/checkLedgerVsSearchBalances.ts
----------------------------------------
import express from "express";
import { CheckLedgerVsSearchBalances } from "../services/CheckLedgerVsSearchBalances";

export async function CheckLedgerVsSearchBalancesController(
  req: express.Request,
  res: express.Response
) {
  try {
    const balanceCheck = await CheckLedgerVsSearchBalances();

    // Send a success response
    res.status(200).json({ balanceCheck });
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error checking balances:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/controllers/createTestLoop.ts
----------------------------------------
import express from "express";
import { CreateTestLoopService } from "../services/CreateTestLoop";

export async function CreateTestLoopController(
  req: express.Request,
  res: express.Response
) {
  // Check if numNewTransactions is provided in the request body
  if (!req.body.numNewTransactions) {
    return res.status(400).json({ message: "numNewTransactions is required" });
  }

  try {
    // Call the service to create test transactions
    const responseData = await CreateTestLoopService(
      req.body.numNewTransactions
    );

    // Send the response with the created test transactions
    res.status(200).json(responseData);
  } catch (err) {
    // Handle errors and send an appropriate error response
    console.error("Error creating test transactions:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/DevAdmin/services/GrowthTest.ts
----------------------------------------
import { CreateTestMembersAndAccountsService } from "./CreateTestMembersAndAccounts";
import { CreateRandomFloatingCredexesService } from "./CreateRandomFloatingCredexes";
import { DailyCredcoinOffering } from "../../Core/DCO/DailyCredcoinOffering";
import { MinuteTransactionQueue } from "../../Core/MTQ/MinuteTransactionQueue";
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { PurchaseSecuredCredexesService } from "./PurchaseSecuredCredexes";
import { SellSecuredCredexesService } from "./SellSecuredCredexes";
import { InEcosystemSecuredCredexesService } from "./InEcosystemSecuredCredexes";

export async function GrowthTestService(variables: any) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    // Get current number of accounts
    const numberAccountsQuery = await ledgerSpaceSession.run(`
      MATCH (account:Account)
      RETURN count(account) AS numberAccounts
    `);
    let numberAccounts = parseFloat(
      numberAccountsQuery.records[0].get("numberAccounts")
    );

    for (let index = 0; index < variables.numberDays; index++) {
      let numberNewAccounts = Math.round(
        numberAccounts * variables.accountGrowthRate
      );
      if (numberNewAccounts < 1) {
        numberNewAccounts = 1;
      }

      console.log(`Day ${index + 1}`);
      console.log(`Current number of accounts: ${numberAccounts}`);
      console.log(`Creating new accounts: ${numberNewAccounts}`);
      numberAccounts += numberNewAccounts;

      await CreateTestMembersAndAccountsService(numberNewAccounts);

      const numberUSDpurchases = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToPurchase
      );
      await PurchaseSecuredCredexesService(
        "USD",
        numberUSDpurchases,
        variables.USD_SECURED_amountPerPurchaseLow,
        variables.USD_SECURED_amountPerPurchaseHigh
      );

      const numberUSDsecuredCirculate = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToCirculate
      );
      await InEcosystemSecuredCredexesService("USD", numberUSDsecuredCirculate);

      const numberUSDsales = Math.round(
        numberAccounts * variables.USD_SECURED_fractionToSell
      );
      await SellSecuredCredexesService("USD", numberUSDsales);

      const numberZIGpurchases = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToPurchase
      );
      await PurchaseSecuredCredexesService(
        "ZIG",
        numberZIGpurchases,
        variables.ZIG_SECURED_amountPerPurchaseLow,
        variables.ZIG_SECURED_amountPerPurchaseHigh
      );

      const numberZIGsecuredCirculate = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToCirculate
      );
      await InEcosystemSecuredCredexesService("ZIG", numberZIGsecuredCirculate);

      const numberZIGsales = Math.round(
        numberAccounts * variables.ZIG_SECURED_fractionToSell
      );
      await SellSecuredCredexesService("ZIG", numberZIGsales);

      const numberRandomFloatingTransactions = Math.round(
        numberAccounts * variables.dailyFloatingRandomTransactionsPerAccount
      );
      console.log(
        `Creating random floating credexes: ${numberRandomFloatingTransactions}`
      );
      if (numberRandomFloatingTransactions > 0) {
        await CreateRandomFloatingCredexesService(
          numberRandomFloatingTransactions
        );
      }

      await DailyCredcoinOffering();
      await MinuteTransactionQueue();
    }

    console.log("This run of GrowthTestService is complete");
  } catch (error) {
    console.error(
      "An error occurred during the GrowthTestService execution:",
      error
    );
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/DevAdmin/services/CheckLedgerVsSearchBalances.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";

export async function CheckLedgerVsSearchBalances() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    // Query ledgerSpace for credex data
    const ledgerSpaceCredexesQuery = await ledgerSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDledger,
        credex.OutstandingAmount AS OutstandingAmountLedger
    `);

    // Query searchSpace for credex data
    const searchSpaceCredexesQuery = await searchSpaceSession.run(`
      MATCH (credex:Credex)
      RETURN
        credex.credexID AS credexIDsearch,
        credex.outstandingAmount AS OutstandingAmountSearch
    `);

    // Process ledgerSpace results
    const ledgerSpaceCredexes = ledgerSpaceCredexesQuery.records.map(
      (record) => ({
        credexID: record.get("credexIDledger"),
        OutstandingAmount: record.get("OutstandingAmountLedger"),
      })
    );

    // Process searchSpace results
    const searchSpaceCredexes = searchSpaceCredexesQuery.records.map(
      (record) => ({
        credexID: record.get("credexIDsearch"),
        OutstandingAmount: record.get("OutstandingAmountSearch"),
      })
    );

    // Create a map for quick lookup from searchSpace
    const searchSpaceCredexMap = new Map(
      searchSpaceCredexes.map((credex) => [
        credex.credexID,
        credex.OutstandingAmount,
      ])
    );

    // Compare and analyze the data
    let matchingCount = 0;
    const mismatchedCredexes = [];

    for (const ledgerCredex of ledgerSpaceCredexes) {
      const searchOutstandingAmount = searchSpaceCredexMap.get(
        ledgerCredex.credexID
      );

      // If the credex does not exist in searchSpace and the amount in ledgerSpace is 0, count as a match
      if (
        searchOutstandingAmount === undefined &&
        ledgerCredex.OutstandingAmount === 0
      ) {
        matchingCount++;
      } else if (ledgerCredex.OutstandingAmount === searchOutstandingAmount) {
        matchingCount++;
      } else {
        mismatchedCredexes.push({
          credexID: ledgerCredex.credexID,
          OutstandingAmountLedger: ledgerCredex.OutstandingAmount,
          OutstandingAmountSearch: searchOutstandingAmount || 0,
        });
      }
    }

    // Return the results
    return {
      matchingCount,
      mismatchedCredexes,
    };
  } catch (error) {
    console.error("An error occurred during the execution:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}



File: ./src/DevAdmin/services/InEcosystemSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { GetSecuredAuthorizationService } from "../../Credex/services/GetSecuredAuthorization";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function InEcosystemSecuredCredexesService(
  denom: string,
  number: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Creating in-ecosystem ${denom} secured credexes: ${number}`);

  try {
    if (number > 0) {
      const result = await ledgerSpaceSession.run(
        `
        MATCH
          (issuer:Account)<-[transactionType:OWES]-
          (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH
          (issuer)-[transactionType:OWES]->
          (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
        WITH
          issuer,
          sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
        WHERE netIn > 0
        WITH
          issuer.accountID AS issuerAccountID
        ORDER BY rand() 
        LIMIT $number
        WITH collect(issuerAccountID) AS issuerAccountIDs
        UNWIND issuerAccountIDs AS issuerAccountID
        MATCH (randomCounterparty:Account)
        WHERE randomCounterparty.accountID <> issuerAccountID
        WITH issuerAccountID, randomCounterparty.accountID AS receiverAccountID
        ORDER BY rand()
        RETURN issuerAccountID, receiverAccountID
        LIMIT $number
        `,
        {
          number: neo4j.int(number),
          denom,
        }
      );

      if (result.records.length === 0) {
        console.log("No records found for circulation.");
        return;
      }

      const batchSize = 3;
      const records = result.records;

      for (let i = 0; i < records.length; i += batchSize) {
        const batch = records.slice(i, i + batchSize);

        const offerPromises = batch.map(async (record) => {
          const issuerAccountID: string = record.get("issuerAccountID");
          const receiverAccountID: string = record.get("receiverAccountID");

          try {
            const securableData = await GetSecuredAuthorizationService(
              issuerAccountID,
              denom
            );

            const maxSecurable = securableData.securableAmountInDenom;
            let InitialAmount;
            if (maxSecurable >= 1) {
              InitialAmount = random(maxSecurable);
            } else {
              InitialAmount = random(0.1, maxSecurable);
            }
            console.log("random initialAmount: " + InitialAmount);

            const credexSpecs = {
              issuerAccountID: issuerAccountID,
              receiverAccountID: receiverAccountID,
              Denomination: denom,
              InitialAmount: InitialAmount,
              credexType: "PURCHASE",
              securedCredex: true,
            };

            const newcredex = await OfferCredexService(credexSpecs);

            if (
              typeof newcredex.credex === "boolean" ||
              !newcredex.credex?.credexID
            ) {
              throw new Error("Invalid response from OfferCredexService");
            }

            await AcceptCredexService(newcredex.credex.credexID);
          } catch (error) {
            console.error("Error processing credex offer:", error);
            // Handle error as needed
          }
        });

        await Promise.all(offerPromises);
      }
    }
  } catch (error) {
    console.error("Error in InEcosystemSecuredCredexesService:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
*/
}



File: ./src/DevAdmin/services/PurchaseSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function PurchaseSecuredCredexesService(
  denom: string,
  number: number,
  lowValue: number,
  highValue: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Purchasing ${denom} secured credexes: ${number}`);

  if (number > 0) {
    const getSecuredUSDCounterparties = await ledgerSpaceSession.run(
      `
        // Step 1: Select a random audited account
        MATCH (auditedAccount:Account)<-[:CREDEX_FOUNDATION_AUDITED]-(foundation:Account)
        WITH auditedAccount, rand() AS rand
        ORDER BY rand LIMIT 1

        // Step 2: Collect account IDs for purchasers
        MATCH (accounts:Account)
        WHERE accounts.accountID <> auditedAccount.accountID
        WITH auditedAccount, collect(accounts.accountID) AS allaccounts
        RETURN auditedAccount.accountID AS auditedID, allaccounts[0..$number] AS accountsToPurchaseUSDsecured
      `,
      {
        number: neo4j.int(number),
      }
    );

    const issuerAccountID =
      getSecuredUSDCounterparties.records[0].get("auditedID");
    const accountsToPurchaseUSDsecured =
      getSecuredUSDCounterparties.records[0].get(
        "accountsToPurchaseUSDsecured"
      );

    const batchSize = 3;

    for (let i = 0; i < accountsToPurchaseUSDsecured.length; i += batchSize) {
      const batch = accountsToPurchaseUSDsecured.slice(i, i + batchSize);

      const offerPromises = batch.map((receiverAccountID: string) => {
        const InitialAmount = random(lowValue, highValue);

        const credexSpecs = {
          issuerAccountID: issuerAccountID,
          receiverAccountID: receiverAccountID,
          Denomination: denom,
          InitialAmount: InitialAmount,
          credexType: "PURCHASE",
          securedCredex: true,
        };

        return OfferCredexService(credexSpecs);
      });

      const offerCredexArray = await Promise.all(offerPromises);

      const acceptPromises = offerCredexArray.map((newcredex) => {
        if (typeof newcredex.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
          return AcceptCredexService(newcredex.credex.credexID);
        } else {
          return Promise.reject(newcredex.message);
        }
      });

      await Promise.all(acceptPromises);
    }
  }

  await ledgerSpaceSession.close();
  */
}



File: ./src/DevAdmin/services/CreateTestMembersAndAccounts.ts
----------------------------------------
import axios from "axios";
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OnboardMemberService } from "../../Member/services/OnboardMember";
import { CreateAccountService } from "../../Account/services/CreateAccount";
import { random } from "lodash";

export async function CreateTestMembersAndAccountsService(numNewAccounts: number) {
  const batchSize = 3; // Size of each batch

  const numNewMembers = Math.round(numNewAccounts * 0.75)
  const numNewAccountsForExisting = numNewAccounts - numNewMembers;

  const memberPromises = [];
  for (let i = 0; i < numNewMembers; i++) {
    memberPromises.push(
      (async () => {
        // Fetch a new name for each iteration
        
        // comment out when daily limit reached        
        const nameObject = await axios.get(
          "https://api.parser.name/?api_key=f30409d63186d13cfa335a40e14dcd17&endpoint=generate"
        );
        const firstname = nameObject.data.data[0].name.firstname.name_ascii;
        const lastname = nameObject.data.data[0].name.lastname.name_ascii;
        /*
        // comment out when name coming from query above
        const randomNum1 = random(100, 999);
        const randomNum2 = random(100, 999);
        const firstname = "first" + randomNum1;
        const lastname = "last" + randomNum2;
        */
        const phone = "263" + Math.floor(100000000 + Math.random() * 900000000);
        // need to check if phone unique here and generate new if not

        const onboardedMember = await OnboardMemberService(
          firstname,
          lastname,
          phone
        );
        if (!onboardedMember.onboardedMemberID) {
          throw new Error("member could not be onboarded");
        }

        const consumptionAccount = await CreateAccountService(
          onboardedMember.onboardedMemberID,
          "PERSONAL_CONSUMPTION",
          `${firstname} ${lastname} Personal`,
          `${firstname}_${lastname}`,
          "USD"
        );

        if (!consumptionAccount.accountID) {
          console.log(consumptionAccount.message);
          throw new Error("new consumption account could not be created");
        }

        return {
          onboardedMemberID: onboardedMember.onboardedMemberID,
          consumptionAccountID: consumptionAccount.accountID,
        };
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewMembers - 1) {
      await Promise.all(memberPromises);
      memberPromises.length = 0; // Clear the array for the next batch
    }
  }

  const accountPromises = [];
  for (let i = 0; i < numNewAccountsForExisting; i++) {
    accountPromises.push(
      (async () => {
        var ledgerSpaceSession = ledgerSpaceDriver.session();
        const getRandomMemberQuery = await ledgerSpaceSession.run(`
          MATCH (members:Member)
          WITH members.memberID AS memberID, rand() AS rand
          ORDER BY rand LIMIT 1
          RETURN memberID
        `);
        await ledgerSpaceSession.close();

        const ownerID = getRandomMemberQuery.records[0].get("memberID");
        const businessName = "biz" + random(100000, 999999);

        const newAccount = await CreateAccountService(
          ownerID,
          "BUSINESS",
          businessName,
          businessName,
          "USD"
        );

        if (!newAccount.accountID) {
          console.log(newAccount.message);
          throw new Error("new account could not be created");
        }
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewAccountsForExisting - 1) {
      await Promise.all(accountPromises);
      accountPromises.length = 0; // Clear the array for the next batch
    }
  }
  return true;
}



File: ./src/DevAdmin/services/ClearDevDb.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";

export async function ClearDevDbService() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();
  await ledgerSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
  await searchSpaceSession.run(`
      MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r
      `);
  await ledgerSpaceSession.close();
  await searchSpaceSession.close();

  //check success first
  console.log("LedgerSpace and SearchSpace DBs cleared");
  return true;
}



File: ./src/DevAdmin/services/SellSecuredCredexes.ts
----------------------------------------
import { random } from "lodash";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { GetSecuredAuthorizationService } from "../../Credex/services/GetSecuredAuthorization";
import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function SellSecuredCredexesService(
  denom: string,
  number: number
) {
  /*
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  console.log(`Selling ${denom} secured credexes for cash: ${number}`);

  try {
    if (number > 0) {
      const result = await ledgerSpaceSession.run(
        `
        MATCH
          (issuer:Account)<-[transactionType:OWES]-
          (inCredex:Credex{Denomination:$denom})<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH
          (issuer)-[transactionType:OWES]->
          (outCredex:Credex{Denomination: $denom})<-[:SECURES]-(securer)
        WITH
          issuer, securer,
          sum(inCredex.OutstandingAmount) - sum(outCredex.OutstandingAmount) AS netIn
        WHERE netIn > 0
        RETURN
          issuer.accountID AS issuerAccountID,
          securer.accountID AS receiverAccountID
          ORDER BY rand() LIMIT $number;
        `,
        {
          number: neo4j.int(number),
          denom,
        }
      );

      if (result.records.length === 0) {
        console.log("No records found for selling secured credexes.");
        return;
      }

      const batchSize = 3;
      const records = result.records;

      for (let i = 0; i < records.length; i += batchSize) {
        const batch = records.slice(i, i + batchSize);

        const offerPromises = batch.map(async (record) => {
          const issuerAccountID: string = record.get("issuerAccountID");
          const receiverAccountID: string = record.get("receiverAccountID");

          try {
            const securableData = await GetSecuredAuthorizationService(
              issuerAccountID,
              denom
            );

            const InitialAmount = random(
              1,
              securableData.securableAmountInDenom || 1
            );

            const credexSpecs = {
              issuerAccountID: issuerAccountID,
              receiverAccountID: receiverAccountID,
              Denomination: denom,
              InitialAmount: InitialAmount,
              credexType: "PURCHASE",
              securedCredex: true,
            };

            const newcredex = await OfferCredexService(credexSpecs);

            if (
              typeof newcredex.credex === "boolean" ||
              !newcredex.credex?.credexID
            ) {
              throw new Error("Invalid response from OfferCredexService");
            }

            await AcceptCredexService(newcredex.credex.credexID);
          } catch (error) {
            console.error("Error processing credex offer:", error);
            // Handle error as needed
          }
        });

        await Promise.all(offerPromises);
      }
    }
  } catch (error) {
    console.error("Error in SellSecuredCredexesService:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
  */
}



File: ./src/DevAdmin/services/CreateRandomFloatingCredexes.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { random } from "lodash";
import moment from "moment-timezone";

async function getDateAndRandCounterparties() {
  var ledgerSpaceSession = ledgerSpaceDriver.session();
  const getDateAndRandomCounterpartiesQuery = await ledgerSpaceSession.run(`
    MATCH (accounts1:Account)
    WITH accounts1, rand() AS rand1
    ORDER BY rand1
    WITH accounts1.accountID AS accountID_1 LIMIT 1
    MATCH (accounts2:Account)
    WHERE accounts2.accountID <> accountID_1
    WITH accountID_1, accounts2, rand() AS rand2
    ORDER BY rand2
    WITH accountID_1, accounts2.accountID AS accountID_2 LIMIT 1
    MATCH (daynode:Daynode{Active:true})
    RETURN daynode.Date AS date, accountID_1, accountID_2
  `);

  await ledgerSpaceSession.close();

  return {
    accountID_1:
      getDateAndRandomCounterpartiesQuery.records[0].get("accountID_1"),
    accountID_2:
      getDateAndRandomCounterpartiesQuery.records[0].get("accountID_2"),
    date: getDateAndRandomCounterpartiesQuery.records[0].get("date"),
  };
}

export async function CreateRandomFloatingCredexesService(
  numNewTransactions: number
) {
  /*
  const credexesCreated = [];
  const batchSize = 3;
  const transactionPromises = [];

  for (let i = 0; i < numNewTransactions; i++) {
    transactionPromises.push(
      (async () => {
        const dateAndCounterparties = await getDateAndRandCounterparties();
        const date = dateAndCounterparties.date;
        const issuerAccountID = dateAndCounterparties.accountID_1;
        const receiverAccountID = dateAndCounterparties.accountID_2;
        const InitialAmount = random(1, 100);
        const Denomination = InitialAmount < 80 ? "USD" : "ZIG";

        // floating credex due in 8-34 days
        const credspanDays = random(8, 34);
        const dueDate = moment(date)
          .subtract(1, "months")
          .add(credspanDays, "days")
          .format("YYYY-MM-DD");

        const credexSpecs = {
          issuerAccountID: issuerAccountID,
          receiverAccountID: receiverAccountID,
          Denomination: Denomination,
          InitialAmount: InitialAmount,
          credexType: "PURCHASE",
          dueDate: dueDate,
          securedCredex: false,
        };

        const newcredex = await OfferCredexService(credexSpecs);
        if (typeof newcredex.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
          const credexCreatedData = await AcceptCredexService(
            newcredex.credex.credexID
          );
          return credexCreatedData;
        } else {
          return newcredex.message;
        }
      })()
    );

    // Process in batches of `batchSize`
    if ((i + 1) % batchSize === 0 || i === numNewTransactions - 1) {
      const batchResults = await Promise.all(transactionPromises);
      credexesCreated.push(
        ...batchResults.filter((result) => result !== undefined)
      );
      transactionPromises.length = 0; // Clear the array for the next batch
    }
  }

  console.log(`${numNewTransactions} new floating transactions created`);
  return credexesCreated;
  */
}



File: ./src/DevAdmin/services/CreateTestLoop.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { random } from "lodash";
import moment from "moment-timezone";
import * as neo4j from "neo4j-driver";

export async function CreateTestLoopService(numNewTransactions: number) {
  /*
  var ledgerSpaceSession = ledgerSpaceDriver.session();
  const getRandomCounterpartiesQuery = await ledgerSpaceSession.run(
    `
      MATCH (account:Account)
      WITH account, rand() AS rand1
      ORDER BY rand1
      RETURN account.accountID AS accountID LIMIT $numNewTransactions
    `,
    {
      numNewTransactions: neo4j.int(numNewTransactions),
    }
  );

  const getDaynodeDate = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.Date AS today
  `);
  const today = getDaynodeDate.records[0].get("today");

  let credexesCreated = [];
  // Iterate numNewTransactions times
  for (let i = 0; i < numNewTransactions; i++) {
    const issuerAccountID =
      getRandomCounterpartiesQuery.records[i].get("accountID");

    let receiverAccountID;
    if (getRandomCounterpartiesQuery.records[i + 1]) {
      receiverAccountID =
        getRandomCounterpartiesQuery.records[i + 1].get("accountID");
    } else {
      receiverAccountID =
        getRandomCounterpartiesQuery.records[0].get("accountID");
    }

    const credexSpecs = {
      issuerAccountID: issuerAccountID,
      receiverAccountID: receiverAccountID,
      Denomination: "USD",
      InitialAmount: random(1, 100),
      credexType: "PURCHASE",
      //securedCredex: true,
      dueDate: moment(today)
        .utc()
        .add(8, "days")
        .subtract(1, "month")
        .format("YYYY-MM-DD"),
    };

    console.log(
      "Amount: " + credexSpecs.InitialAmount + " " + credexSpecs.Denomination
    );
    const newcredex = await OfferCredexService(credexSpecs);
    if (typeof newcredex.credex == "boolean") {
      throw new Error("Invalid response from OfferCredexService");
    }
    if (newcredex.credex && typeof newcredex.credex.credexID === "string") {
      const credexCreatedData = await AcceptCredexService(
        newcredex.credex.credexID
      );
      credexesCreated.push(credexCreatedData);
    } else {
      return newcredex.message;
    }
  }
  console.log(numNewTransactions + " new transactions created");
  return credexesCreated;
  */
}



File: ./src/Account/accountRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { CreateAccountController } from "./controllers/createAccount";
import { GetAccountByHandleController } from "./controllers/getAccountByHandle";
import { UpdateAccountController } from "./controllers/updateAccount";
import { AuthorizeForAccountController } from "./controllers/authorizeForAccount";
import { UnauthorizeForAccountController } from "./controllers/unauthorizeForAccount";
import { UpdateSendOffersToController } from "./controllers/updateSendOffersTo";

export default function AccountRoutes(
  app: express.Application,
  jsonParser: any
) {
  app.post(
    `${apiVersionOneRoute}createAccount`,
    jsonParser,
    CreateAccountController
  );

  app.get(
    `${apiVersionOneRoute}getAccountByHandle`,
    jsonParser,
    GetAccountByHandleController
  );

  app.patch(
    `${apiVersionOneRoute}updateAccount`,
    jsonParser,
    UpdateAccountController
  );

  app.post(
    `${apiVersionOneRoute}authorizeForAccount`,
    jsonParser,
    AuthorizeForAccountController
  );

  app.post(
    `${apiVersionOneRoute}unauthorizeForAccount`,
    jsonParser,
    UnauthorizeForAccountController
  );

  app.post(
    `${apiVersionOneRoute}updateSendOffersTo`,
    jsonParser,
    UpdateSendOffersToController
  );
}



File: ./src/Account/controllers/updateSendOffersTo.ts
----------------------------------------
import express from "express";
import { UpdateSendOffersToService } from "../services/UpdateSendOffersTo";

export async function UpdateSendOffersToController(
  req: express.Request,
  res: express.Response
) {
  const requiredFields = ["memberIDtoSendOffers", "accountID", "ownerID"];

  for (const field of requiredFields) {
    if (!req.body[field]) {
      return res.status(400).json({ message: `${field} is required` });
    }
  }

  try {
    const responseData = await UpdateSendOffersToService(
      req.body.memberIDtoSendOffers,
      req.body.accountID,
      req.body.ownerID
    );

    if (!responseData) {
      return res
        .status(400)
        .json({ message: "Failed to update offer recipient for company" });
    }

    return res.status(200).json(responseData);
  } catch (err) {
    console.error("Error updating offer recipient for company:", err);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Account/controllers/getAccountByHandle.ts
----------------------------------------
import express from "express";
import { GetAccountByHandleService } from "../services/GetAccountByHandle";

export async function GetAccountByHandleController(
  req: express.Request,
  res: express.Response
) {
    const requiredFields = ["accountHandle"];

  for (const field of requiredFields) {
    if (!req.body[field]) {
      return res.status(400).json({ message: `${field} is required` });
    }
  }

  try {
    const accountData = await GetAccountByHandleService(req.body.accountHandle);

    if (accountData) {
      res.status(200).json({ accountData });
    } else {
      res.status(404).json({ message: "Account not found" });
    }
  } catch (err) {
    console.error("Error retrieving account:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Account/controllers/authorizeForAccount.ts
----------------------------------------
import express from "express";
import { AuthorizeForAccountService } from "../services/AuthorizeForAccount";

export async function AuthorizeForAccountController(
  req: express.Request,
  res: express.Response
) {
  const requiredFields = ["memberHandleToBeAuthorized", "accountID", "ownerID"];

  for (const field of requiredFields) {
    if (!req.body[field]) {
      return res.status(400).json({ message: `${field} is required` });
    }
  }

  try {
    const responseData = await AuthorizeForAccountService(
      req.body.memberHandleToBeAuthorized,
      req.body.accountID,
      req.body.ownerID
    );

    if (!responseData) {
      return res
        .status(400)
        .json({ message: "Failed to authorize member for account" });
    }

    return res.status(200).json(responseData);
  } catch (err) {
    console.error("Error authorizing member for account:", err);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Account/controllers/createAccount.ts
----------------------------------------
import express from "express";
import { CreateAccountService } from "../services/CreateAccount";

export async function CreateAccountController(
  req: express.Request,
  res: express.Response
): Promise<void> {
  const fieldsRequired = [
    "ownerID",
    "accountType",
    "accountName",
    "accountHandle",
    "defaultDenom",
  ];

  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      res.status(400).json({ message: `${field} is required` });
      return;
    }
  }

  try {
    const newAccount = await CreateAccountService(
      req.body.ownerID,
      req.body.accountType,
      req.body.accountName,
      req.body.accountHandle,
      req.body.defaultDenom
    );

    if (newAccount.accountID) {
      res.status(200).json(newAccount.accountID);
    } else {
      res.status(400).json({ message: newAccount.message });
    }
  } catch (error) {
    console.error("Error creating account:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Account/controllers/updateAccount.ts
----------------------------------------
import express from "express";
import { UpdateAccountService } from "../services/UpdateAccount";

export async function UpdateAccountController(
  req: express.Request,
  res: express.Response
) {
  const requiredFields = ["ownerID", "accountID"];

  for (const field of requiredFields) {
    if (!req.body[field]) {
      return res.status(400).json({ message: `${field} is required` });
    }
  }

  try {
    const updatedAccountID = await UpdateAccountService(
      req.body.ownerID,
      req.body.accountID,
      req.body.accountName,
      req.body.accountHandle,
      req.body.defaultDenom
    );

    if (updatedAccountID) {
      res
        .status(200)
        .json({ message: `Account updated successfully: ${updatedAccountID}` });
    } else {
      res
        .status(404)
        .json({ message: "Account not found or no update performed" });
    }
  } catch (error) {
    console.error("Error updating account:", error);
    res.status(500).json({ error: "Failed to update account" });
  }
}



File: ./src/Account/controllers/unauthorizeForAccount.ts
----------------------------------------
import express from "express";
import { UnauthorizeForCompanyService } from "../services/UnauthorizeForAccount";

export async function UnauthorizeForAccountController(
  req: express.Request,
  res: express.Response
) {
  const requiredFields = ["memberIDtoBeUnauthorized", "accountID", "ownerID"];

  for (const field of requiredFields) {
    if (!req.body[field]) {
      return res.status(400).json({ message: `${field} is required` });
    }
  }

  try {
    const responseData = await UnauthorizeForCompanyService(
      req.body.memberIDtoBeUnauthorized,
      req.body.accountID,
      req.body.ownerID
    );

    if (!responseData) {
      return res
        .status(400)
        .json({ message: "Failed to unauthorize account for the company" });
    }

    return res.status(200).json(responseData);
  } catch (err) {
    console.error("Error unauthorizing account for company:", err);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Account/services/GetBalances.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";

export async function GetBalancesService(accountID: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    const getSecuredBalancesQuery = await ledgerSpaceSession.run(
      `
      MATCH (account:Account {accountID: $accountID})

      // Get all unique denominations from Credex nodes related to the account
      OPTIONAL MATCH (account)-[:OWES|OFFERED]-(securedCredex:Credex)<-[:SECURES]-()
      WITH DISTINCT securedCredex.Denomination AS denom, account

      // Aggregate incoming secured amounts for each denomination ensuring uniqueness
      OPTIONAL MATCH (account)<-[:OWES]-(inSecuredCredex:Credex {Denomination: denom})<-[:SECURES]-()
      WITH denom, account, 
          collect(DISTINCT inSecuredCredex) AS inSecuredCredexes

      // Aggregate outgoing secured amounts for each denomination ensuring uniqueness
      OPTIONAL MATCH (account)-[:OWES|OFFERED]->(outSecuredCredex:Credex {Denomination: denom})<-[:SECURES]-()
      WITH denom, 
          reduce(s = 0, n IN inSecuredCredexes | s + n.OutstandingAmount) AS sumSecuredIn, 
          collect(DISTINCT outSecuredCredex) AS outSecuredCredexes

      // Calculate the total outgoing amount
      WITH denom, sumSecuredIn, 
          reduce(s = 0, n IN outSecuredCredexes | s + n.OutstandingAmount) AS sumSecuredOut

      // Get the current day node which should have active status
      MATCH (daynode:Daynode {Active: true})

      // Calculate the net secured balance for each denomination and return the result
      RETURN denom, (sumSecuredIn - sumSecuredOut) / daynode[denom] AS netSecured
      `,
      { accountID }
    );

    const securedNetBalancesByDenom: string[] = getSecuredBalancesQuery.records
      .filter((record) => {
        const amount = record.get("netSecured");
        return typeof amount === "number" && isFinite(amount) && amount !== 0;
      })
      .map((record) => {
        const denom = record.get("denom");
        const amount = record.get("netSecured");
        return `${denomFormatter(amount, denom)} ${denom}`;
      });

    const getUnsecuredBalancesAndTotalAssetsQuery =
      await ledgerSpaceSession.run(
        `
        MATCH (account:Account{accountID:$accountID})

        OPTIONAL MATCH (account)<-[:OWES]-(owesInCredexUnsecured:Credex)
        WHERE NOT (owesInCredexUnsecured)<-[:SECURES]-()
        WITH account, COLLECT(DISTINCT owesInCredexUnsecured) AS unsecuredCredexesIn

        OPTIONAL MATCH (account)-[:OWES]->(owesOutCredexUnsecured:Credex)
        WHERE NOT (owesOutCredexUnsecured)<-[:SECURES]-()
        WITH account, unsecuredCredexesIn, COLLECT(DISTINCT owesOutCredexUnsecured) AS unsecuredCredexesOut

        OPTIONAL MATCH (account)<-[:OWES]-(owesInCredexAll:Credex)
        WITH account, unsecuredCredexesIn, unsecuredCredexesOut, COLLECT(DISTINCT owesInCredexAll) AS owesInCredexesAll

        OPTIONAL MATCH (account)-[:OWES]->(owesOutCredexAll:Credex)
        WITH account, unsecuredCredexesIn, unsecuredCredexesOut, owesInCredexesAll, COLLECT(DISTINCT owesOutCredexAll) AS owesOutCredexesAll

        WITH
          account.defaultDenom AS defaultDenom,
          REDUCE(total = 0, credex IN unsecuredCredexesIn | total + credex.OutstandingAmount) AS receivablesTotalCXX,
          REDUCE(total = 0, credex IN unsecuredCredexesOut | total + credex.OutstandingAmount) AS payablesTotalCXX,
          REDUCE(total = 0, credex IN unsecuredCredexesIn | total + credex.OutstandingAmount)
            - REDUCE(total = 0, credex IN unsecuredCredexesOut | total + credex.OutstandingAmount) AS unsecuredNetCXX,
          REDUCE(total = 0, credex IN owesInCredexesAll | total + credex.OutstandingAmount)
            - REDUCE(total = 0, credex IN owesOutCredexesAll | total + credex.OutstandingAmount) AS netCredexAssetsCXX
        MATCH (daynode:Daynode{Active:true})
        RETURN
          defaultDenom,
          receivablesTotalCXX / daynode[defaultDenom] AS receivablesTotalInDefaultDenom,
          payablesTotalCXX / daynode[defaultDenom] AS payablesTotalInDefaultDenom,
          unsecuredNetCXX / daynode[defaultDenom] AS unsecuredNetInDefaultDenom,
          netCredexAssetsCXX / daynode[defaultDenom] AS netCredexAssetsInDefaultDenom
      `,
        { accountID }
      );

    const unsecuredBalancesAndTotalAssets =
      getUnsecuredBalancesAndTotalAssetsQuery.records[0];
    const defaultDenom = unsecuredBalancesAndTotalAssets.get("defaultDenom");
    const unsecuredBalancesInDefaultDenom = {
      totalPayables: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("payablesTotalInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
      totalReceivables: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("receivablesTotalInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
      netPayRec: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("unsecuredNetInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
    };

    return {
      securedNetBalancesByDenom,
      unsecuredBalancesInDefaultDenom,
      netCredexAssetsInDefaultDenom: `${denomFormatter(
        unsecuredBalancesAndTotalAssets.get("netCredexAssetsInDefaultDenom"),
        defaultDenom
      )} ${defaultDenom}`,
    };
  } catch (error) {
    console.error("Error fetching balances:", error);
    throw new Error("Failed to fetch balances. Please try again later.");
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/GetAccountDashboard.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { GetBalancesService } from "./GetBalances";
import { GetPendingOffersInService } from "../../Credex/services/GetPendingOffersIn";
import { GetPendingOffersOutService } from "../../Credex/services/GetPendingOffersOut";

export async function GetAccountDashboardService(
  memberID: string,
  accountID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    interface AuthMember {
      memberID: string;
      firstname: string;
      lastname: string;
    }

    interface AccountData {
      accountID: string;
      accountName: string;
      accountHandle: string;
      defaultDenom: string;
      isOwnedAccount: boolean;
      sendOffersToFirstname: string;
      sendOffersToLastname: string;
      sendOffersToMemberID: string;
      authFor: AuthMember[];
      balanceData: any;
      pendingInData: any;
      pendingOutData: any;
    }

    const result = await ledgerSpaceSession.run(
      `
    MATCH
      (account:Account { accountID: $accountID })
      <-[:AUTHORIZED_FOR]-
      (member:Member { memberID: $memberID})
    MATCH
      (account)<-[:AUTHORIZED_FOR]-(allAuthMembers)
    OPTIONAL MATCH
      (account)<-[owns:OWNS]-(member)
    OPTIONAL MATCH
      (account)-[:SEND_OFFERS_TO]->(sendOffersTo:Member)
    RETURN
      account.accountID AS accountID,
      account.accountType AS accountType,
      account.accountName AS accountName,
      account.accountHandle AS accountHandle,
      account.defaultDenom AS defaultDenom,
      sendOffersTo.firstname AS sendOffersToFirstname,
      sendOffersTo.lastname AS sendOffersToLastname,
      sendOffersTo.memberID AS sendOffersToMemberID,
      owns IS NOT NULL AS isOwnedAccount,
      allAuthMembers.firstname AS authMemberFirstname,
      allAuthMembers.lastname AS authMemberLastname,
      allAuthMembers.memberID AS authMemberID
  `,
      { memberID, accountID }
    );

    if (!result.records.length) {
      console.log("account not found");
      return null;
    }

    const accountData: AccountData = {
      accountID: result.records[0].get("accountID"),
      accountName: result.records[0].get("accountName"),
      accountHandle: result.records[0].get("accountHandle"),
      defaultDenom: result.records[0].get("defaultDenom"),
      isOwnedAccount: result.records[0].get("isOwnedAccount"),
      sendOffersToFirstname: "",
      sendOffersToLastname: "",
      sendOffersToMemberID: "",
      authFor: [],
      balanceData: [],
      pendingInData: [],
      pendingOutData: [],
    };

    if (accountData.isOwnedAccount) {
      (accountData.sendOffersToFirstname = result.records[0].get(
        "sendOffersToFirstname"
      )),
        (accountData.sendOffersToLastname = result.records[0].get(
          "sendOffersToLastname"
        )),
        (accountData.sendOffersToMemberID = result.records[0].get(
          "sendOffersToMemberID"
        )),
        result.records.forEach((record) => {
          accountData.authFor.push({
            memberID: record.get("authMemberID"),
            firstname: record.get("authMemberFirstname"),
            lastname: record.get("authMemberLastname"),
          });
        });
    } else {
      accountData.authFor = [];
    }
    accountData.balanceData = await GetBalancesService(accountData.accountID);
    accountData.pendingInData = await GetPendingOffersInService(
      accountData.accountID
    );
    accountData.pendingOutData = await GetPendingOffersOutService(
      accountData.accountID
    );

    return accountData;
  } catch (error) {
    console.error("Error fetching account data:", error);
    return null;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/CreateAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../../Core/constants/denominations";
import { checkPermittedAccountType } from "../../Core/constants/accountTypes";

export async function CreateAccountService(
  ownerID: string,
  accountType: string,
  accountName: string,
  accountHandle: string,
  defaultDenom: string,
  DCOgiveInCXX: number | null = null,
  DCOdenom: string | null = null
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  //check that account creation is permitted on membership tier
  const getMemberTier = await ledgerSpaceSession.run(
    `
        MATCH (member:Member{ memberID: $ownerID })
        OPTIONAL MATCH (member)-[:OWNS]->(account:Account)
        RETURN
          member.memberTier AS memberTier,
          COUNT(account) AS numAccounts
      `,
    { ownerID }
  );

  const memberTier = getMemberTier.records[0].get("memberTier");
  const numAccounts = getMemberTier.records[0].get("numAccounts");
  if (memberTier <= 2 && numAccounts >= 1) {
    return {
      account: false,
      message:
        "You cannot create an account on the Open or Verified membership tiers.",
    };
  }

  // Validation: Check defaultDenom in denominations
  if (!getDenominations({ code: defaultDenom }).length) {
    const message = "defaultDenom not in denoms";
    console.log(message);
    return { account: false, message: message };
  }

  // Check credex type validity
  if (!checkPermittedAccountType(accountType)) {
    const message = "Error: accountType not permitted";
    console.log(message);
    console.log("accountType: " + accountType);
    return {
      account: false,
      message: message,
    };
  }

  // Transform to lowercase and remove spaces
  accountHandle = accountHandle.toLowerCase().replace(/\s/g, "");

  // Validate the accountHandle
  const isValid = /^[a-z0-9._]+$/.test(accountHandle);

  if (!isValid) {
    return {
      account: false,
      message:
        "Invalid account handle. Only lowercase letters, numbers, periods, and underscores are allowed.",
    };
  }

  // Validation: Check DCOdenom in denominations
  if (DCOdenom && !getDenominations({ code: DCOdenom }).length) {
    const message = "DCOdenom not in denoms";
    console.log(message);
    return { account: false, message: message };
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode { Active: true })
        MATCH (owner:Member { memberID: $ownerID })
        CREATE (owner)-[:OWNS]->(account:Account {
          accountType: $accountType,
          accountName: $accountName,
          accountHandle: $accountHandle,
          defaultDenom: $defaultDenom,
          DCOgiveInCXX: $DCOgiveInCXX,
          DCOdenom: $DCOdenom,
          accountID: randomUUID(),
          queueStatus: "PENDING_ACCOUNT",
          createdAt: datetime(),
          updatedAt: datetime()
        })-[:CREATED_ON]->(daynode)
        CREATE
          (owner)-[:AUTHORIZED_FOR]->
          (account)
          -[:SEND_OFFERS_TO]->(owner)
        RETURN account.accountID AS accountID
      `,
      {
        ownerID,
        accountType,
        accountName,
        accountHandle,
        defaultDenom,
        DCOgiveInCXX,
        DCOdenom,
      }
    );

    if (!result.records.length) {
      const message = "could not create account";
      console.log(message);
      return { account: false, message };
    }

    const createdAccountID = result.records[0].get("accountID");
    console.log(accountType + " account created: " + createdAccountID);
    return {
      accountID: createdAccountID,
      message: "account created",
    };
  } catch (error) {
    console.error("Error creating account:", error);

    // Type guard to narrow the type of error
    if (
      isNeo4jError(error) &&
      error.code === "Neo.ClientError.Schema.ConstraintValidationFailed"
    ) {
      if (error.message.includes("phone")) {
        return { account: false, message: "Phone number already in use" };
      }
      if (error.message.includes("handle")) {
        return {
          account: false,
          message: "Sorry, that handle is already in use",
        };
      }
      return { account: false, message: "Required unique field not unique" };
    }

    return {
      account: false,
      message:
        "Error: " + (error instanceof Error ? error.message : "Unknown error"),
    };
  } finally {
    await ledgerSpaceSession.close();
  }
}

// Type guard to check if an error is a Neo4j error
function isNeo4jError(
  error: unknown
): error is { code: string; message: string } {
  return (
    typeof error === "object" &&
    error !== null &&
    "code" in error &&
    "message" in error
  );
}



File: ./src/Account/services/UpdateAccount.ts
----------------------------------------
/*
updates data for a account

requires object of account data to be updated
field required: accountID

fields that can be updated:
    firstname
    lastname
    companyname
    phone
    accountHandle
    DailyCredcoinOfferingGive
    DailyCredcoinOfferingDenom

if extraneous data or data not matching criteria is included it will be ignored, data
that fits criteria (if any) will still be updated, and success message will be returned

returns accountID of updated account

returns null on error
*/

import { ledgerSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../../Core/constants/denominations";

export async function UpdateAccountService(
  ownerID: string,
  accountID: string,
  accountName: string,
  accountHandle: string,
  defaultDenom: string
) {
  // Validation: Check defaultDenom in denominations
  if (!getDenominations({ code: defaultDenom }).length) {
    const message = "defaultDenom not in denoms";
    console.log(message);
    return false;
  }

  const dataToUpdate = {
    accountName: accountName,
    accountHandle: accountHandle,
    defaultDenom: defaultDenom,
  };

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH
          (owner:Member { memberID: $ownerID })
          -[:OWNS]->
          (account:Account { accountID: $accountID })
        SET account += $dataToUpdate
        RETURN account.accountID AS accountID
            `,
      { ownerID, accountID, dataToUpdate }
    );

    if (!result.records[0].get("accountID")) {
      return false;
    }

    return result.records[0].get("accountID");
  } catch (error) {
    console.error("Error updating account data:", error);
    return null;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/UpdateSendOffersTo.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function UpdateSendOffersToService(
  memberIDtoSendOffers: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH
                (newMemberForOffers: Member { memberID: $memberIDtoSendOffers})
                -[:AUTHORIZED_FOR]->(account:Account { accountID: $accountID})
                <-[:OWNS]-(owner:Member { memberID: $ownerID}),
                (account)-[currentAccountForOffersRel:SEND_OFFERS_TO]->(:Member)
            DELETE currentAccountForOffersRel
            CREATE (account)-[:SEND_OFFERS_TO]->(newMemberForOffers)
            RETURN true
            `,
      {
        memberIDtoSendOffers,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      return false;
    }

    return true;
  } catch (error) {
    console.error(
      "Error updating account to receive offer notifications:",
      error
    );
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/GetAccountByHandle.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function GetAccountByHandleService(
  accountHandle: string
): Promise<any | null> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  if (!accountHandle) {
    console.log("accountHandle is required");
    return null;
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH (account:Account { accountHandle: $accountHandle })
            RETURN
              account.accountID AS accountID,
              account.accountName AS accountName
        `,
      { accountHandle }
    );

    if (!result.records.length) {
      console.log("account not found");
      return null;
    }

    const accountID = result.records[0].get("accountID");
    const accountName = result.records[0].get("accountName");

    return {
      accountID: accountID,
      accountName: accountName,
    };
  } catch (error) {
    console.error("Error fetching account data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/UnauthorizeForAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function UnauthorizeForCompanyService(
  memberIDtoBeUnauthorized: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH
                (memberToUnauthorize:Member { memberID: $memberIDtoBeUnauthorized })
                -[authRel:AUTHORIZED_FOR]->(account:Account { accountID: $accountID })
                <-[:OWNS]-(owner:Member { memberID: $ownerID })
            DELETE authRel
            RETURN
                account.accountID AS accountID,
                memberToUnauthorize.accountID AS memberToUnauthorize
        `,
      {
        memberIDtoBeUnauthorized,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      console.log("could not unauthorize account");
      return false;
    }
    const record = result.records[0];

    console.log(
      `account ${record.get(
        "memberToUnauthorize"
      )} unauthorized to transact for ${record.get("accountID")}`
    );
    return true;
  } catch (error) {
    console.error("Error unauthorizing account:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Account/services/AuthorizeForAccount.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function AuthorizeForAccountService(
  memberHandleToBeAuthorized: string,
  accountID: string,
  ownerID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  //check that account authorization is permitted on membership tier
  const getMemberTier = await ledgerSpaceSession.run(
    `
        MATCH (member:Member{ memberID: $ownerID })
        RETURN member.memberTier as memberTier
      `,
    { ownerID }
  );

  const memberTier = getMemberTier.records[0].get("memberTier");
  if (memberTier <= 3) {
    return {
      message:
        "You can only authorize someone to transact on behalf of your account when you are on the Entrepreneur tier or above.",
    };
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH (account:Account { accountID: $accountID })
            <-[:OWNS]-(owner:Member { memberID: $ownerID })
        MATCH (memberToAuthorize:Member { memberHandle: $memberHandleToBeAuthorized })
        MATCH (:Member)-[currentAuthForRel:AUTHORIZED_FOR]->(account)
        WITH count (currentAuthForRel) AS numAuthorized, memberToAuthorize, account
        CALL apoc.do.when(
          numAuthorized >= 5,
          'RETURN "limitReached" AS message',
          'MERGE (memberToAuthorize)-[:AUTHORIZED_FOR]->(account)
            RETURN
              "accountAuthorized" AS message,
              account.accountID AS accountID,
              memberToAuthorize.memberID AS memberIDtoAuthorize',
          {
            numAuthorized: numAuthorized,
            memberToAuthorize: memberToAuthorize,
            account: account
          }
        )
        YIELD value
        RETURN
          value.message AS message,
          value.accountID AS accountID,
          value.memberIDtoAuthorize AS memberIDtoAuthorize
      `,
      {
        memberHandleToBeAuthorized,
        accountID,
        ownerID,
      }
    );

    if (!result.records.length) {
      return {
        message: "accounts not found",
      };
    }

    const record = result.records[0];

    if (record.get("message") == "limitReached") {
      return {
        message:
          "Limit of 5 authorized accounts reached. Remove an authorized account if you want to add another.",
      };
    }

    if (record.get("message") == "accountAuthorized") {
      console.log(
        `account ${record.get(
          "memberIDtoAuthorize"
        )} authorized to transact for ${record.get("accountID")}`
      );
      return {
        message: "account authorized",
        accountID: record.get("accountID"),
        memberIdAuthorized: record.get("memberIDtoAuthorize"),
      };
    } else {
      console.log("could not authorize account");
      return false;
    }
  } catch (error) {
    console.error("Error authorizing account:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Member/memberRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { OnboardMemberController } from "./controllers/onboardMember";
import { GetMemberDashboardByPhoneController } from "./controllers/getMemberDashboardByPhone";
import { GetMemberByHandleController } from "./controllers/getMemberByHandle";
import { UpdateMemberTierController } from "./controllers/updateMemberTier";

export default function MemberRoutes(
  app: express.Application,
  jsonParser: any
) {
  app.post(
    `${apiVersionOneRoute}onboardMember`,
    jsonParser,
    OnboardMemberController
  );

  app.get(
    `${apiVersionOneRoute}getMemberDashboardByPhone`,
    jsonParser,
    GetMemberDashboardByPhoneController
  );

  app.get(
    `${apiVersionOneRoute}getMemberByHandle`,
    jsonParser,
    GetMemberByHandleController
  );

    app.post(
      `${apiVersionOneRoute}updateMemberTier`,
      jsonParser,
      UpdateMemberTierController
    );

}


File: ./src/Member/controllers/onboardMember.ts
----------------------------------------
import express from "express";
import { OnboardMemberService } from "../services/OnboardMember";
import { CreateAccountService } from "../../Account/services/CreateAccount";
import { GetMemberDashboardByPhoneService } from "../services/GetMemberDashboardByPhone";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

export async function OnboardMemberController(
  req: express.Request,
  res: express.Response
): Promise<void> {
  const fieldsRequired = [
    "firstname",
    "lastname",
    "phone",
  ];

  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      res.status(400).json({ message: `${field} is required` });
      return;
    }
  }

  try {
    const onboardedMember = await OnboardMemberService(
      req.body.firstname,
      req.body.lastname,
      req.body.phone
    );

    if (!onboardedMember.onboardedMemberID) {
      res.status(400).json({ message: onboardedMember.message });
      return;
    }

    const consumptionAccount = await CreateAccountService(
      onboardedMember.onboardedMemberID,
      "PERSONAL_CONSUMPTION",
      `${req.body.firstname} ${req.body.lastname} Personal`,
      req.body.phone,
      "USD",
      req.body.DCOgiveInCXX,
      req.body.DCOdenom
    );

    if (!consumptionAccount.accountID) {
      res.status(400).json({ message: consumptionAccount.message });
      return;
    }

    const memberDashboard = await GetMemberDashboardByPhoneService(
      req.body.phone
    );
    if (!memberDashboard) {
      res.status(400).json({ message: "Could not retrieve member dashboard" });
      return;
    }

    const accountDashboards = await Promise.all(
      memberDashboard.accountIDS.map((accountId: string) =>
        GetAccountDashboardService(memberDashboard.memberID, accountId)
      )
    );

    res.status(200).json({ memberDashboard, accountDashboards });
  } catch (error) {
    console.error("Error onboarding member:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Member/controllers/updateMemberTier.ts
----------------------------------------
import express from "express";
import { UpdateMemberTierService } from "../services/UpdateMemberTier";

export async function UpdateMemberTierController(
  req: express.Request,
  res: express.Response
) {
  const requiredFields = ["memberID", "newTier"];

  for (const field of requiredFields) {
    if (!req.body[field]) {
      return res.status(400).json({ message: `${field} is required` });
    }
  }

  try {
    const memberData = await UpdateMemberTierService(
      req.body.memberID,
      req.body.newTier
    );

    if (memberData) {
      res.status(200).json( true );
    } else {
      res.status(404).json({ message: "Member not found" });
    }
  } catch (err) {
    console.error("Error retrieving member:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Member/controllers/getMemberByHandle.ts
----------------------------------------
import express from "express";
import { GetMemberByHandleService } from "../services/GetMemberByHandle";

export async function GetMemberByHandleController(
  req: express.Request,
  res: express.Response
) {
  const requiredFields = ["memberHandle"];

  for (const field of requiredFields) {
    if (!req.body[field]) {
      return res.status(400).json({ message: `${field} is required` });
    }
  }

  try {
    const memberData = await GetMemberByHandleService(req.body.memberHandle);

    if (memberData) {
      res.status(200).json({ memberData });
    } else {
      res.status(404).json({ message: "Member not found" });
    }
  } catch (err) {
    console.error("Error retrieving member:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Member/controllers/getMemberDashboardByPhone.ts
----------------------------------------
import express from "express";
import { GetMemberDashboardByPhoneService } from "../services/GetMemberDashboardByPhone";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

export async function GetMemberDashboardByPhoneController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["phone"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    const memberDashboard = await GetMemberDashboardByPhoneService(
      req.body.phone
    );
    if (!memberDashboard) {
      res.status(400).json({ message: "Could not retrieve member dashboard" });
      return;
    }

    const accountDashboards = await Promise.all(
      memberDashboard.accountIDS.map((accountId: string) =>
        GetAccountDashboardService(memberDashboard.memberID, accountId)
      )
    );

    res.status(200).json({ memberDashboard, accountDashboards });
  } catch (err) {
    console.error("Error retrieving account:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}



File: ./src/Member/services/GetMemberDashboardByPhone.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";

export async function GetMemberDashboardByPhoneService(phone: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
      MATCH (daynode:Daynode { Active: true })
      MATCH (member:Member { phone: $phone })
      OPTIONAL MATCH (member)-[:OWNS]->(account:Account)
      OPTIONAL MATCH (account)-[:OWES|OFFERS]->(credex:Credex)-[:CREATED_ON]->(daynode)
      WITH
        member, daynode,
        COLLECT(account.accountID) AS accountIDs,
        SUM(credex.InitialAmount) AS totalIssuedTodayCXX
      RETURN
        member.memberID AS memberID,
        member.firstname AS firstname,
        member.lastname AS lastname,
        member.memberHandle AS memberHandle,
        member.defaultDenom AS defaultDenom,
        member.memberTier AS memberTier,
        totalIssuedTodayCXX/daynode["USD"] AS totalIssuedTodayUSD,
        accountIDs AS accountIDS
      `,
      { phone }
    );

    if (!result.records.length) {
      console.log("member not found by phone");
      return false;
    }

    const memberTier = result.records[0].get("memberTier").low;
    const totalIssuedTodayUSD = result.records[0].get("totalIssuedTodayUSD");
    console.log(totalIssuedTodayUSD);
    let remainingAvailableUSD: number = Infinity;
    if (memberTier == 1) {
      remainingAvailableUSD = parseFloat(
        denomFormatter(10 - totalIssuedTodayUSD, "USD")
      );
    }
    if (memberTier == 2) {
      remainingAvailableUSD = parseFloat(
        denomFormatter(100 - totalIssuedTodayUSD, "USD")
      );
    }

    return {
      memberID: result.records[0].get("memberID"),
      firstname: result.records[0].get("firstname"),
      lastname: result.records[0].get("lastname"),
      memberHandle: result.records[0].get("memberHandle"),
      defaultDenom: result.records[0].get("defaultDenom"),
      memberTier: memberTier,
      remainingAvailableUSD: remainingAvailableUSD,
      accountIDS: result.records[0].get("accountIDS"),
    };
  } catch (error) {
    console.error("Error fetching account data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Member/services/OnboardMember.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../../Core/constants/denominations";

export async function OnboardMemberService(
  firstname: string,
  lastname: string,
  phone: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const defaultDenom = "USD";

  try {
    // Validation: Check defaultDenom in denominations
    if (!getDenominations({ code: defaultDenom }).length) {
      const message = "defaultDenom not in denoms";
      console.log(message);
      return { onboardedMemberID: false, message: message };
    }

    const result = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode { Active: true })
        CREATE (member:Member{
          firstname: $firstname,
          lastname: $lastname,
          memberHandle: $phone,
          defaultDenom: $defaultDenom,
          phone: $phone,
          memberID: randomUUID(),
          memberTier: 1,
          createdAt: datetime(),
          updatedAt: datetime()
        })-[:CREATED_ON]->(daynode)
        RETURN
          member.memberID AS memberID
      `,
      {
        firstname,
        lastname,
        defaultDenom,
        phone,
      }
    );

    if (!result.records.length) {
      const message = "could not onboard member";
      console.log(message);
      return { onboardedMemberID: false, message: message };
    }

    const memberID = result.records[0].get("memberID");

    console.log("member onboarded: " + memberID);
    return {
      onboardedMemberID: memberID,
      message: "member onboarded",
    };
  } catch (error) {
    console.error("Error onboarding member:", error);

    // Type guard to narrow the type of error
    if (
      isNeo4jError(error) &&
      error.code === "Neo.ClientError.Schema.ConstraintValidationFailed"
    ) {
      if (error.message.includes("phone")) {
        return {
          onboardedMemberID: false,
          message: "Phone number already in use",
        };
      }
      if (error.message.includes("memberHandle")) {
        return {
          onboardedMemberID: false,
          message: "Member handle already in use",
        };
      }
      return {
        onboardedMemberID: false,
        message: "Required unique field not unique",
      };
    }

    return {
      onboardedMemberID: false,
      message:
        "Error: " + (error instanceof Error ? error.message : "Unknown error"),
    };
  } finally {
    await ledgerSpaceSession.close();
  }
}

// Type guard to check if an error is a Neo4j error
function isNeo4jError(
  error: unknown
): error is { code: string; message: string } {
  return (
    typeof error === "object" &&
    error !== null &&
    "code" in error &&
    "message" in error
  );
}



File: ./src/Member/services/GetMemberByHandle.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function GetMemberByHandleService(
  memberHandle: string
): Promise<any | null> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  if (!memberHandle) {
    console.log("memberHandle is required");
    return null;
  }

  try {
    const result = await ledgerSpaceSession.run(
      `
            MATCH (member:Member { memberHandle: $memberHandle })
            RETURN
              member.memberID AS memberID,
              member.firstname AS firstname,
              member.lastname AS lastname
        `,
      { memberHandle }
    );

    if (!result.records.length) {
      console.log("member not found");
      return null;
    }

    const memberID = result.records[0].get("memberID");
    const firstname = result.records[0].get("firstname");
    const lastname = result.records[0].get("lastname");

    return {
      memberID: memberID,
      memberName: firstname + " " + lastname,
    };
  } catch (error) {
    console.error("Error fetching member data:", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Member/services/UpdateMemberTier.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import * as neo4j from "neo4j-driver";

export async function UpdateMemberTierService(
  memberIDtoUpdate: string,
  newTier: number
) {
  if (newTier < 1 || newTier > 5) {
    return {
      message: "New member tier is not a valid value",
    };
  }
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH (member:Member { memberID: $memberIDtoUpdate })
        SET member.memberTier = $newTier
        RETURN
          member.memberID AS memberIDupdated
      `,
      {
        memberIDtoUpdate,
        newTier: neo4j.int(newTier),
      }
    );

    if (!result.records.length) {
      return false;
    }

    const record = result.records[0];

    if (record.get("memberIDupdated")) {
      console.log("Member tier for " + memberIDtoUpdate + " set to " + newTier);
      return true;
    } else {
      console.log("could not authorize account");
      return false;
    }
  } catch (error) {
    console.error("Error updating member tier: ", error);
    return false;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Member/services/SecuredCredexAuthForTier.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";

export async function SecuredCredexAuthForTier(
  issuerAccountID: string,
  amount: number,
  denom: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    const queryResult = await ledgerSpaceSession.run(
      `
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        WITH member, member.memberTier AS memberTier

        // If memberTier > 2, return true immediately as "result"
        WHERE memberTier > 2
        RETURN true AS result

        UNION

        // If memberTier <= 2, proceed with the larger search query and return calculated values in an object as "result"
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        WITH member, member.memberTier AS memberTier, account
        WHERE memberTier <= 2
        MATCH (daynode:Daynode { Active: true })
        OPTIONAL MATCH (member)-[:OWNS]->(allAccounts:Account)
        OPTIONAL MATCH
          (allAccounts)-[:OWES|OFFERS]->(credex:Credex)<-[:SECURES]-(Account),
          (credex)-[:CREATED_ON]->(daynode)
        WITH
          daynode.USD AS daynodeUSD,
          SUM(credex.InitialAmount) AS dayTotalCXX,
          $amount * daynode[$denom] AS credexAmountCXX,
          memberTier
        RETURN
          {
            dayTotalUSD: dayTotalCXX / daynodeUSD,
            credexAmountUSD: credexAmountCXX / daynodeUSD,
            memberTier: memberTier
          } AS result
    `,
      { issuerAccountID, amount, denom }
    );

    if (queryResult.records.length === 0) {
      return "query error";
    }
    if (queryResult.records[0].get("result") == true) {
      return true;
    }

    const memberTier = queryResult.records[0].get("result").memberTier;
    const dayTotalUSD = queryResult.records[0].get("result").dayTotalUSD;
    const credexAmountUSD =
      queryResult.records[0].get("result").credexAmountUSD;

    var amountAvailableUSD = 0;
    if (memberTier == 1) {
      amountAvailableUSD = 10 - dayTotalUSD;
    }
    if (memberTier == 2) {
      amountAvailableUSD = 100 - dayTotalUSD;
    }
    if (amountAvailableUSD >= credexAmountUSD) {
      return true;
    } else {
      return (
        "You are only able to issue " +
        denomFormatter(amountAvailableUSD, "USD") +
        " USD until tomorrow. Limits renew at midnight UTC."
      );
    }
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Core/cronJobs.ts
----------------------------------------
import cron from "node-cron";
import { DailyCredcoinOffering } from "./DCO/DailyCredcoinOffering";
import { MinuteTransactionQueue } from "./MTQ/MinuteTransactionQueue";

export default function startCronJobs() {
  // Running DailyCredcoinOffering every day at midnight UTC
  cron.schedule(
    "0 0 * * *",
    async () => {
      try {
        await DailyCredcoinOffering();
      } catch (error) {
        console.error("Error running DailyCredcoinOffering:", error);
      }
    },
    {
      timezone: "UTC",
    }
  );

  // Running MinuteTransactionQueue every minute
  cron.schedule("* * * * *", async () => {
    try {
      await MinuteTransactionQueue();
    } catch (error) {
      console.error("Error running MinuteTransactionQueue:", error);
    }
  });
}



File: ./src/Core/constants/credexTypes.ts
----------------------------------------
export const credexTypes = [
  "PURCHASE",
  "GIFT",
  "DCO_GIVE",
  "DCO_RECEIVE"
];

export function checkPermittedCredexType(credexTypeToCheck: string) {
  if (credexTypes.includes(credexTypeToCheck)) {
    return true;
  }
}



File: ./src/Core/constants/credspan.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import moment from "moment-timezone";

export const credspan = 35;

export async function checkDueDate(dueDate: any): Promise<boolean> {
  const dueDateMoment = moment.utc(dueDate, "YYYY-MM-DD", true);
  if (!dueDateMoment.isValid()) {
    console.error("Due date not in valid format");
    return false;
  }

  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const currentDateQuery = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      RETURN daynode.Date AS today
    `);
  const today = currentDateQuery.records[0].get("today");
  if (!today) {
    console.log("could not get date from daynode");
    return false;
  }
  const lastPermittedDayMoment = moment(today)
    .subtract(1, "months") // because of diff date formats
    .add(credspan, "days");
  const firstPermittedDayMoment = moment(today)
    .subtract(1, "months") // because of diff date formats
    .add(7, "days");
  if (
    dueDateMoment >= lastPermittedDayMoment ||
    dueDateMoment < firstPermittedDayMoment
  ) {
    console.error("Due date is not within permitted credspan");
    return false;
  }
  return true;
}



File: ./src/Core/constants/denominations.ts
----------------------------------------
import { filter } from "lodash";

type DenomOptions = {
  code?: string;
  sourceForRate?: string;
  formatAsList?: boolean;
};

type Denominations = {
  code: string;
  fulldescription: string;
  regionalization: string;
  sourceForRate: string;
};

export function getDenominations(
  options: DenomOptions
): string | Denominations[] {
  const denominations: Denominations[] = [
    {
      code: "CXX",
      fulldescription: "CXX (Credcoin)",
      regionalization: "en-CA",
      sourceForRate: "DCO",
    },
    {
      code: "CAD",
      fulldescription: "CAD (Canadian Dollars)",
      regionalization: "en-CA",
      sourceForRate: "OpenExchangeRates",
    },
    {
      code: "USD",
      fulldescription: "USD (United States Dollars)",
      regionalization: "en-US",
      sourceForRate: "OpenExchangeRates",
    },
    {
      code: "XAU",
      fulldescription: "XAU (Troy Gold Ounces)",
      regionalization: "en-CA",
      sourceForRate: "OpenExchangeRates",
    },
    {
      code: "ZIG",
      fulldescription: "ZIG (Zimbabwe Gold Official Rate)",
      regionalization: "en-CA",
      sourceForRate: "RBZ",
    },
  ];

  let returndata: Denominations[] = denominations;
  if (options.code) {
    returndata = filter(
      returndata,
      (i: Denominations) => i.code === options.code
    );
  }
  if (options.sourceForRate) {
    returndata = filter(
      returndata,
      (i: Denominations) => i.sourceForRate === options.sourceForRate
    );
  }
  if (options.formatAsList) {
    return returndata.map((x) => x.code).join(",");
  }
  return returndata;
}

export const denomFormatter = (amount: number, code: string): string => {
  // Ensure amount is a finite number
  if (!isFinite(amount)) {
    amount = 0;
  }

  // Function to format currency amounts
  const formatCurrencyAmount = (
    amount: number,
    roundedTo: number,
    regionalization: string
  ): string => {
    const roundedAmount =
      Math.round(amount * Math.pow(10, roundedTo)) / Math.pow(10, roundedTo);
    const formatter = new Intl.NumberFormat(regionalization);
    return formatter.format(roundedAmount);
  };

  const denomData: any = getDenominations({ code });
  const regionalization =
    denomData && denomData.length > 0 ? denomData[0].regionalization : "en-US";

  let formattedAmount;
  switch (code) {
    case "CXX":
      formattedAmount = formatCurrencyAmount(amount, 3, regionalization);
      break;
    case "XAU":
      formattedAmount = formatCurrencyAmount(amount, 4, regionalization);
      break;
    default:
      formattedAmount = formatCurrencyAmount(amount, 2, regionalization);
  }
  return formattedAmount;
};



File: ./src/Core/constants/accountTypes.ts
----------------------------------------
export const accountTypes = ["PERSONAL_CONSUMPTION", "BUSINESS", "CREDEX_FOUNDATION"];

export function checkPermittedAccountType(credexTypeToCheck: string) {
  if (accountTypes.includes(credexTypeToCheck)) {
    return true;
  }
}



File: ./src/Core/MTQ/LoopFinder.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";

export async function LoopFinder(
  issuerAccountID: string,
  credexID: string,
  credexAmount: number,
  Denomination: string,
  CXXmultiplier: number,
  credexSecuredDenom: string,
  credexDueDate: string,
  acceptorAccountID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  var searchOwesType = "FLOATING";
  if (credexSecuredDenom != "floating") {
    searchOwesType = credexSecuredDenom + "_SECURED";

    //this is a bit of a hack for secured credexes, assigning them a due date of today
    //as per daynode, so that they can be processed through the loopfinder and will be
    //prioritized by oldest outstanding credex
    const getDaynodeDate = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      RETURN daynode.Date AS today
      `);
    credexDueDate = getDaynodeDate.records[0].get("today");
  }

  //check if credex already exists in DB
  //this happens if the loopfinder overloads the processors or otherwise fails and
  //doesn't mark the credex as processed in ledgerSpace
  //in this case, we don't want to recreate the credex, just run the loopfinder.
  const checkCredexExists = await searchSpaceSession.run(
    `
      OPTIONAL MATCH (credex:Credex {credexID: $credexID})
      RETURN credex IS NOT NULL AS credexExists
    `,
    { credexID }
  );
  const credexExists = checkCredexExists.records[0].get("credexExists");

  //if the credex doesn't exist in searchSpace, create it
  if (!credexExists) {
    try {
      const createSearchSpaceCredex = await searchSpaceSession.run(
        `
        MATCH (issuer:Account {accountID: $issuerAccountID})
        MATCH (acceptor:Account {accountID: $acceptorAccountID})
        MERGE (issuer)-[:${searchOwesType}]->(searchOwesType:${searchOwesType})-[:${searchOwesType}]->(acceptor)
          ON CREATE SET searchOwesType.searchAnchorID = randomUUID()
        CREATE (searchOwesType)<-[:SEARCH_SECURED]-(credex:Credex {
            credexID: $credexID,
            outstandingAmount: $credexAmount,
            Denomination: $Denomination,
            CXXmultiplier: $CXXmultiplier,
            dueDate: date($credexDueDate)
        })
        WITH searchOwesType, credex
        CALL apoc.do.case(
            [
                searchOwesType.earliestDueDate IS NULL
                OR searchOwesType.earliestDueDate > date($credexDueDate), 
                'SET searchOwesType.earliestDueDate = date($credexDueDate) RETURN true'
            ],
            'RETURN false',
            {
              searchOwesType: searchOwesType,
              credexDueDate: credex.dueDate
            }
        ) YIELD value
        RETURN credex.credexID AS credexID
        `,
        {
          issuerAccountID: issuerAccountID,
          acceptorAccountID: acceptorAccountID,
          credexID: credexID,
          credexAmount: credexAmount,
          Denomination: Denomination,
          CXXmultiplier: CXXmultiplier,
          credexDueDate: credexDueDate,
          searchOwesType: searchOwesType,
        }
      );

      if (createSearchSpaceCredex.records.length === 0) {
        console.log("Unable to create SearchSpace credex");
        console.log("issuerAccountID: " + issuerAccountID);
        console.log("acceptorAccountID: " + acceptorAccountID);
        console.log("credexID: " + credexID);
        console.log("credexAmount: " + credexAmount);
        console.log("Denomination: " + Denomination);
        console.log("CXXmultiplier: " + CXXmultiplier);
        console.log("credexDueDate: " + credexDueDate);
        console.log("searchOwesType: " + searchOwesType);
        return false;
      }
      console.log(
        "Credex created in SearchSpace: " +
          createSearchSpaceCredex.records[0].get("credexID")
      );
    } catch (error) {
      console.error("Error creating SearchSpace credex:", error);
      return false;
    }
  } else {
    console.log("credex already exists in SearchSpace: " + credexID);
  }

  let searchForCredloops = true;
  while (searchForCredloops) {
    console.log("searching for credloops...");
    const searchSpaceQuery = await searchSpaceSession.run(
      `
      // Step 1: Find all loops starting and ending at the specified account, with the specified searchOwesType
      MATCH credloops = (issuer:Account {accountID: $issuerAccountID})-[:${searchOwesType}*]->(issuer)
      
      WITH credloops, nodes(credloops) AS loopNodes
      UNWIND loopNodes AS node
      WITH credloops, node
      WITH credloops, MIN(node.earliestDueDate) AS earliestDueDate

      // Step 3: Filter loops to include only those containing a node with the earliest earliestDueDate
      WITH credloops, earliestDueDate, nodes(credloops) AS loopNodes
      UNWIND loopNodes AS node
      WITH credloops, node
      WHERE node.earliestDueDate = earliestDueDate
      WITH credloops, length(credloops) AS loopLength

      // Step 4: Return only the longest loop, breaking ties with rand()
      ORDER BY loopLength DESC, rand()
      LIMIT 1
      WITH nodes(credloops) AS credloopNodes

      // Step 5: Each node returns the credex it is connected to with the earliest dueDate
      // on tie, credex with largest amount
      UNWIND credloopNodes AS loopNode
      MATCH (loopNode)<-[:SEARCH_SECURED]-(credex:Credex)
      WITH loopNode, collect(credex) AS credexList
      WITH 
             reduce(minCredex = credexList[0], c IN credexList | 
                    CASE 
                      WHEN c.dueDate < minCredex.dueDate THEN c
                      WHEN c.dueDate = minCredex.dueDate AND c.outstandingAmount > minCredex.outstandingAmount THEN c
                      ELSE minCredex 
                    END) AS earliestCredex
      WITH collect(earliestCredex) AS finalCredexes, COLLECT(earliestCredex.credexID) AS credexIDs

      // Step 6: Identify the minimum outstandingAmount and subtract it from all credexes
      UNWIND finalCredexes AS credexInLoop
      WITH finalCredexes, min(credexInLoop.outstandingAmount) AS lowestAmount, credexIDs

      UNWIND finalCredexes AS credex
      SET credex.outstandingAmount = credex.outstandingAmount - lowestAmount

      // Step 7: Collect all credexes and filter those with outstandingAmount = 0.
      WITH lowestAmount, COLLECT(credex) AS allCredexes, credexIDs
      WITH lowestAmount, allCredexes, [credex IN allCredexes WHERE credex.outstandingAmount = 0] AS zeroCredexes, credexIDs

      //Step 8: collect credexIDs of the zeroCredexes
      UNWIND zeroCredexes as zeroCredex
      RETURN collect(zeroCredex.credexID) AS zeroCredexIDs, lowestAmount, credexIDs
      `,
      { issuerAccountID, searchOwesType }
    );

    if (searchSpaceQuery.records.length > 0) {
      const valueToClear = searchSpaceQuery.records[0].get("lowestAmount");
      const credexesInLoop = searchSpaceQuery.records[0].get("credexIDs");
      const credexesRedeemed = searchSpaceQuery.records[0].get("zeroCredexIDs");
      console.log("credexesInLoop:");
      console.log(credexesInLoop);
      console.log("credexesRedeemed:");
      console.log(credexesRedeemed);

      const cleanupQuery = await searchSpaceSession.run(
        `
        // Step 10: Delete zeroCredexes
        UNWIND $credexesRedeemed AS credexRedeemedID
        MATCH (credex:Credex {credexID: credexRedeemedID})-[:SEARCH_SECURED]->(searchAnchor)
        DETACH DELETE credex
        WITH DISTINCT searchAnchor

        // Step 11: Handle orphaned searchAnchors
        OPTIONAL MATCH (searchAnchor)<-[:SEARCH_SECURED]-(otherCredex:Credex)
        WITH searchAnchor, collect(otherCredex) AS otherCredexes
        CALL apoc.do.when(
          size(otherCredexes) = 0,
          'DETACH DELETE searchAnchor RETURN "searchAnchorDeleted" AS result',
          'RETURN "noChanges" AS result',
          {searchAnchor: searchAnchor}
        ) YIELD value AS deleteValue
        WITH deleteValue, searchAnchor, otherCredexes
        WHERE deleteValue <> "searchAnchorDeleted"

        // Step 12: Update earliestDueDate on remaining searchAnchors
        UNWIND otherCredexes AS otherCredex
        WITH DISTINCT searchAnchor, otherCredex
        CALL apoc.do.when(
          (searchAnchor.earliestDueDate IS NULL OR searchAnchor.earliestDueDate > date(otherCredex.dueDate)),
          'SET searchAnchor.earliestDueDate = date(otherCredex.dueDate) RETURN "searchAnchorEarliestUpdated" AS result',
          'RETURN "noChanges" AS result',
          {searchAnchor: searchAnchor, otherCredex: otherCredex}
        ) YIELD value AS updateValue
        RETURN searchAnchor
        `,
        { credexesRedeemed }
      );

      console.log(
        "credloop of " +
          valueToClear +
          " CXX found and cleared, now updating ledgerSpace"
      );

      const ledgerSpaceQuery = await ledgerSpaceSession.run(
        `
          MATCH (daynode:Daynode {Active: true})
          CREATE (loopAnchor:LoopAnchor {
              loopedAt: DateTime(),
              loopID: randomUUID(),
              LoopedAmount: $valueToClear,
              CXXmultiplier: 1,
              Denomination: "CXX"
          })-[to_daynode:CREATED_ON]->(daynode)
          WITH loopAnchor

          UNWIND $credexesInLoop AS credexID
          MATCH (thisCredex:Credex {credexID: credexID})
          SET thisCredex.OutstandingAmount = thisCredex.OutstandingAmount - $valueToClear,
              thisCredex.RedeemedAmount = thisCredex.RedeemedAmount + $valueToClear
          WITH thisCredex, loopAnchor
          CREATE (thisCredex)-[:REDEEMED {
              AmountRedeemed: $valueToClear,
              AmountOutstandingNow: thisCredex.OutstandingAmount,
              Denomination: thisCredex.Denomination,
              CXXmultiplier: thisCredex.CXXmultiplier,
              createdAt: DateTime(),
              redeemedRelID: randomUUID()
          }]->(loopAnchor)

          WITH thisCredex, loopAnchor
          MATCH (loopAnchor)<-[:REDEEMED]-(thisCredex)
            -[:OWES]->(:Account)-[:OWES]->(nextCredex:Credex)
            -[:REDEEMED]->(loopAnchor)
          CREATE (thisCredex)-[:CREDLOOP {
              AmountRedeemed: $valueToClear,
              AmountOutstandingNow: thisCredex.OutstandingAmount,
              Denomination: thisCredex.Denomination,
              CXXmultiplier: thisCredex.CXXmultiplier,
              createdAt: DateTime(),
              loopID: loopAnchor.loopID,
              credloopRelID: randomUUID()
          }]->(nextCredex)

          WITH DISTINCT loopAnchor
          UNWIND $credexesRedeemed AS redeemedCredexID
          MATCH
            (owesOutAccount:Account)-[owes1:OWES]->
              (thisRedeemedCredex:Credex {credexID: redeemedCredexID})-[owes2:OWES]->
              (owesInAccount:Account),
            (thisRedeemedCredex)-[:REDEEMED]->(loopAnchor)
          CREATE
            (owesOutAccount)-[:CLEARED]->(thisRedeemedCredex)-[:CLEARED]->(owesInAccount)
          SET thisRedeemedCredex.DateRedeemed = DateTime()
          DELETE owes1, owes2

          RETURN DISTINCT loopAnchor.loopID AS loopID
        `,
        { valueToClear, credexesInLoop, credexesRedeemed }
      );
      console.log(
        "loopAnchor created: " + ledgerSpaceQuery.records[0].get("loopID")
      );
    } else {
      // if no credloops found this iteration
      const markCredexAsProcessed = await ledgerSpaceSession.run(
        `
          MATCH (processedCredex:Credex {credexID: $credexID})
          SET processedCredex.queueStatus = "PROCESSED"
          RETURN processedCredex.credexID AS credexID
      `,
        { credexID }
      );

      console.log("...none. credex marked processed");

      searchForCredloops = false;
    }
  }

  return true;
}

/*

const transformIntegers = (val: number) =>
  neo4j.isInt(val)
    ? neo4j.integer.inSafeRange(val)
      ? val.toNumber()
      : val.toString()
    : val;


        //create notifications for each account
        var notiFeedDataQuery = await ledgerSpaceSession.run(`
            MATCH (loopAnchor:LoopAnchor{loopID:$loopID})<-[:REDEEMED]-(everyLoopedCredex:Credex)-[:OWES|CLEARED]->(NotiAccount:Account)
            
            MATCH (NotiAccount)-[:OWES|CLEARED]->(payableCredex:Credex)-[redeemedPayable:REDEEMED]->(loopAnchor), (payableCredex:Credex)-[:OWES|CLEARED]->(payableAccount:Account)
            
            MATCH (NotiAccount)<-[:OWES|CLEARED]-(receivableCredex:Credex)-[redeemedReceivable:REDEEMED]->(loopAnchor), (receivableCredex:Credex)<-[:OWES|CLEARED]-(receivableAccount:Account)
            
            RETURN
              NotiAccount.accountID AS notiAccountID,
              redeemedPayable.AmountRedeemed AS payableRedeemed,
              redeemedPayable.Denomination AS payableDenom,
              redeemedPayable.CXXmultiplier AS payableCXXmult,
              payableAccount.firstname AS payableAccountFirstname,
              payableAccount.lastname AS payableAccountLastname,
              redeemedReceivable.AmountRedeemed AS receivableRedeemed,
              redeemedReceivable.Denomination AS receivableDenom,
              redeemedReceivable.CXXmultiplier AS receivableCXXmult,
              receivableAccount.firstname AS receivableAccountFirstname,
              receivableAccount.lastname AS receivableAccountLastname
  
            `,
          {
            loopID: loopID
          }
        )
        for (let notiIndex = 0; notiIndex < notiFeedDataQuery.records.length; notiIndex++) {
          var notiData = notiFeedDataQuery.records[notiIndex];

          var notiAccountID = notiData.get("notiAccountID")
          var amountPayableCXX = notiData.get("payableRedeemed")
          var payableDenom = notiData.get("payableDenom")
          var payableCXXmult = notiData.get("payableCXXmult")
          var payableAccountFirstname = notiData.get("payableAccountFirstname")
          var payableAccountLastname = notiData.get("payableAccountLastname")
          var amountReceivableCXX = notiData.get("receivableRedeemed")
          var receivableDenom = notiData.get("receivableDenom")
          var receivableCXXmult = notiData.get("receivableCXXmult")
          var receivableAccountFirstname = notiData.get("receivableAccountFirstname")
          var receivableAccountLastname = notiData.get("receivableAccountLastname")

          //get denom data based on denom code for each
          var payableDenomData = getDenoms({ 'code': payableDenom });
          var receivableDenomData = getDenoms({ 'code': receivableDenom });
          var payableDenomDataFull = {
            code: payableDenom,
            fulldescription: payableDenomData.fulldescription,
            rate: payableCXXmult,
            regionalization: payableDenomData.regionalization,
            type: payableDenomData.type
          };
          var receivableDenomDataFull = {
            code: receivableDenom,
            fulldescription: receivableDenomData.fulldescription,
            rate: receivableCXXmult,
            regionalization: receivableDenomData.regionalization,
            type: receivableDenomData.type
          };

          //convert and format amounts
          var amountPayableFormatted = denomAmountProcessor(amountPayableCXX, payableDenomDataFull, payableDenomDataFull)
          var amountReceivableFormatted = denomAmountProcessor(amountReceivableCXX, receivableDenomDataFull, receivableDenomDataFull)

          var notiFeedText = amountPayableFormatted + " that you owed to " + payableAccountFirstname + " " + payableAccountLastname + " has been credlooped against " + amountReceivableFormatted + " that " + receivableAccountFirstname + " " + receivableAccountLastname + " owed you.";


          console.log(notiAccountID)
          console.log(notiFeedText)

          //push noti to account
          var rest = new Ably.Rest({ key: process.env.ABLY_API_KEY });
          var channel = rest.channels.get('credex-user-' + notiAccountID);

          channel.publish('user-notification', JSON.stringify({ notiAccountID: null, message: notiFeedText }));

          channel.publish('update-user', "refresh data after loop");
        }
      */



File: ./src/Core/MTQ/MinuteTransactionQueue.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { LoopFinder } from "./LoopFinder";
import _ from "lodash";

export async function MinuteTransactionQueue() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  console.log("MTQ start: check if DCO or MTQ is in progress");
  //and set MTQrunningNow flag to postpone DCO
  const DCOinProgressCheck = await ledgerSpaceSession.run(`
    MATCH (daynode:Daynode {Active: true})
    RETURN
      daynode.DCOrunningNow AS DCOflag,
      daynode.MTQrunningNow AS MTQflag
  `);
  const DCOflag = DCOinProgressCheck.records[0].get("DCOflag");
  const MTQflag = DCOinProgressCheck.records[0].get("MTQflag");

  if (DCOflag || MTQflag) {
    if (DCOflag) {
      console.log("DCO in progress, holding MTQ");
    }
    if (MTQflag) {
      console.log("MTQ in progress, holding MTQ");
    }
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
    return;
  }

  console.log("Running MTQ");

  await ledgerSpaceSession.run(`
    MATCH (daynode:Daynode {Active: true})
    SET daynode.MTQrunningNow = true
  `);

  const BAIL_TIME = 60 * 1000 * 14; // 14 minutes
  const bailTimer = setTimeout(() => {
    console.log("Bail timer reached");
    return true;
  }, BAIL_TIME);

  try {
    const getQueuedAccounts = await ledgerSpaceSession.run(`
      MATCH (newAccount:Account {queueStatus: "PENDING_ACCOUNT"})
      RETURN
        newAccount.accountID AS accountID,
        newAccount.accountName AS accountName
    `);

    for (const record of getQueuedAccounts.records) {
      const accountForSearchSpace = {
        accountID: record.get("accountID"),
        accountName: record.get("accountName"),
      };

      const addAccount = await searchSpaceSession.run(
        `
          CREATE (newAccount:Account)
          SET newAccount = $accountForSearchSpace
          RETURN newAccount.accountID AS accountID
        `,
        { accountForSearchSpace }
      );

      if (addAccount.records.length === 0) {
        console.log(
          "Error creating account in searchSpace: " +
            accountForSearchSpace.accountName
        );
        continue;
      }

      const accountID = addAccount.records[0].get("accountID");

      await ledgerSpaceSession.run(
        `
          MATCH (processedAccount:Account {accountID: $accountID})
          SET processedAccount.queueStatus = "PROCESSED"
        `,
        { accountID }
      );

      console.log(
        "Account created in searchSpace: " + accountForSearchSpace.accountName
      );
    }

    const getQueuedCredexes = await ledgerSpaceSession.run(`
      MATCH
        (issuerAccount:Account)
        -[:OWES]->(queuedCredex:Credex {queueStatus: "PENDING_CREDEX"})
        -[:OWES]->(acceptorAccount:Account)
      OPTIONAL MATCH (queuedCredex)<-[:SECURES]-(securer:Account)
      RETURN queuedCredex.acceptedAt AS acceptedAt,
             issuerAccount.accountID AS issuerAccountID,
             acceptorAccount.accountID AS acceptorAccountID,
             securer.accountID AS securerID,
             queuedCredex.credexID AS credexID,
             queuedCredex.InitialAmount AS amount,
             queuedCredex.Denomination AS denomination,
             queuedCredex.CXXmultiplier AS CXXmultiplier,
             queuedCredex.dueDate AS dueDate
    `);

    const sortedQueuedCredexes = _.sortBy(
      getQueuedCredexes.records.map((record) => {
        const credexObject = {
          acceptedAt: record.get("acceptedAt"),
          issuerAccountID: record.get("issuerAccountID"),
          acceptorAccountID: record.get("acceptorAccountID"),
          credexID: record.get("credexID"),
          amount: record.get("amount"),
          denomination: record.get("denomination"),
          CXXmultiplier: record.get("CXXmultiplier"),
          credexSecuredDenom: "floating",
          dueDate: record.get("dueDate"),
        };
        // add secured data if appropriate
        if (record.get("securerID") !== null) {
          credexObject.credexSecuredDenom = record.get("denomination");
        }
        return credexObject;
      }),
      "acceptedAt"
    );

    for (const credex of sortedQueuedCredexes) {
      await LoopFinder(
        credex.issuerAccountID,
        credex.credexID,
        credex.amount,
        credex.denomination,
        credex.CXXmultiplier,
        credex.credexSecuredDenom,
        credex.dueDate,
        credex.acceptorAccountID
      );
    }
  } catch (error) {
    console.error("Error in MinuteTransactionQueue:", error);
  } finally {
    //turn off MTQrunningNow flag
    await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode{MTQrunningNow: true})
      SET daynode.MTQrunningNow = false
    `);

    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
    clearTimeout(bailTimer); // Clear bail timer
    console.log("MTQ processing completed");
  }

  return true;
}



File: ./src/Core/DCO/DCOsnapshots/2024-08-18_ledgerSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-20_searchSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-19_ledgerSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-23_searchSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-22_ledgerSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-23_ledgerSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-17_searchSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-17_ledgerSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-18_searchSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-22_searchSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-16_searchSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-20_ledgerSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-21_searchSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-19_searchSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-15_searchSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-18_searchSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-17_searchSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-15_ledgerSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-18_ledgerSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-20_ledgerSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-22_ledgerSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-16_searchSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-21_ledgerSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-17_ledgerSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-21_ledgerSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-16_ledgerSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/placeholder.ts
----------------------------------------
//placeholder


File: ./src/Core/DCO/DCOsnapshots/2024-08-19_ledgerSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-20_searchSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-19_searchSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-21_searchSpace_dev_end.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-16_ledgerSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DCOsnapshots/2024-08-22_searchSpace_dev_start.json
----------------------------------------
null


File: ./src/Core/DCO/DBbackup.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import fs from "fs";
import path from "path";

const exportDatabase = async (
  driver: any,
  databaseName: string,
  previousDate: string,
  append: string
): Promise<void> => {
  const session = driver.session();
  try {
    const fileName = `${previousDate}_${databaseName}${append}.json`;
    const filePath = path.join(__dirname, "DCOsnapshots", fileName);

    const result = await session.run(`
      CALL apoc.export.json.all(null, {stream:true, useTypes:true})
    `);

    const records = result.records;
    let jsonData = "";
    records.forEach((record: any) => {
      jsonData += record.get(0);
    });

    fs.writeFileSync(filePath, jsonData);
    console.log(`Backup for ${databaseName} created successfully: ${filePath}`);
  } catch (error) {
    console.error(`Error creating backup for ${databaseName}:`, error);
    throw error;
  } finally {
    await session.close();
  }
};

export const createNeo4jBackup = async (
  previousDate: string,
  append: string
): Promise<void> => {
  try {
    await exportDatabase(ledgerSpaceDriver, "ledgerSpace_dev", previousDate, append);
    await exportDatabase(
      searchSpaceDriver,
      "searchSpace_dev",
      previousDate,
      append
    );
    console.log("Both databases backed up successfully.");
  } catch (error) {
    console.error("Error creating backups:", error);
    throw error;
  }
};



File: ./src/Core/DCO/DailyCredcoinOffering.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { DBinitialization } from "./DBinitialization";
import { DCOexecute } from "./DCOexecute";
import { DCOavatars } from "./DCOavatars";

export async function DailyCredcoinOffering(): Promise<boolean> {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    //check for active daynode
    const daynodeExistsQuery = await ledgerSpaceSession.run(`
      OPTIONAL MATCH (daynode:Daynode {Active: true})
      RETURN daynode IS NOT NULL AS activeDaynodeExists
    `);
    const daynodeExists = daynodeExistsQuery.records[0].get(
      "activeDaynodeExists"
    );

    if (!daynodeExists) {
      console.log("No active daynode, initializing database...");
      await DBinitialization();
      console.log("Database ready");
    }

    await DCOexecute();
    await DCOavatars();
  } finally {
    console.log("Turning off DCOrunningNow flag");
    await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      SET daynode.DCOrunningNow = false
    `);

    await ledgerSpaceSession.close();
  }

  return true;
}



File: ./src/Core/DCO/DCOexecute.ts
----------------------------------------
import axios from "axios";
import _ from "lodash";
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../constants/denominations";
import { GetSecuredAuthorizationService } from "../../Credex/services/GetSecuredAuthorization";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { fetchZigRate } from "./fetchZigRate";
import { createNeo4jBackup } from "./DBbackup";

export async function DCOexecute() {
  console.log("DCOexecute start");
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    console.log("check for MTQrunningNow flag");
    let MTQflag = true;
    while (MTQflag) {
      const MTQinProgressCheck = await ledgerSpaceSession.run(`
        MATCH (daynode:Daynode {Active: true})
        RETURN daynode.MTQrunningNow AS MTQflag
      `);
      MTQflag = MTQinProgressCheck.records[0]?.get("MTQflag");
      if (MTQflag) {
        console.log("MTQ running. Waiting 5 seconds...");
        await new Promise((resolve) => {
          setTimeout(() => {
            resolve(true);
          }, 5000);
        });
      }
    }
    console.log("MTQ not running. Proceed...");
    console.log("fetch expiring daynode and set DCOrunningNow flag");
    const priorDaynodeData = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      SET daynode.DCOrunningNow = true
      RETURN
        daynode.Date AS previousDate,
        daynode.Date + Duration({days: 1}) AS nextDate
    `);
    const previousDate = priorDaynodeData.records[0].get("previousDate");
    const nextDate = priorDaynodeData.records[0].get("nextDate");

    console.log("Expiring day: " + previousDate);

    console.log("End of day backup...");
    await createNeo4jBackup(previousDate, "_end");
    console.log("End of day backup completed.");

    //process defaulting unsecured credexes
    let numberDefaulted = 0;
    const DCOdefaulting = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      OPTIONAL MATCH (account1:Account)-[rel1:OWES]->(defaulting:Credex)-[rel2:OWES]->(account2:Account)
      WHERE defaulting.dueDate <= daynode.Date AND defaulting.DefaultedAmount <= 0
      SET defaulting.DefaultedAmount = defaulting.OutstandingAmount
      WITH defaulting, daynode
      UNWIND defaulting AS defaultingCredex
      CREATE (defaultingCredex)-[:DEFAULTED_ON]->(daynode)
      RETURN count(defaulting) AS numberDefaulted
    `);
    if (DCOdefaulting.records.length) {
      numberDefaulted = DCOdefaulting.records[0].get("numberDefaulted");
    }
    console.log("Defaults: " + numberDefaulted);

    //expire offers/requests that have been pending for more than a full day
    let numberExpiringPending = 0;
    const DCOexpiring = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: TRUE})
      OPTIONAL MATCH (:Account)-[rel1:OFFERS|REQUESTS]->(expiringPending:Credex)-[rel2:OFFERS|REQUESTS]->(:Account),
      (expiringPending)-[:CREATED_ON]->(createdDaynode:Daynode)
      WHERE createdDaynode.Date + Duration({days: 1}) < daynode.Date
      DELETE rel1, rel2
      RETURN count(expiringPending) AS numberExpiringPending
    `);
    if (DCOexpiring.records.length) {
      numberExpiringPending = DCOexpiring.records[0].get(
        "numberExpiringPending"
      );
    }
    console.log("Expired pending offers/requests: " + numberExpiringPending);

    console.log("Loading currencies and current rates");
    const symbolsForOpenExchangeRateApi = getDenominations({
      sourceForRate: "OpenExchangeRates",
      formatAsList: true,
    });
    const ratesRequest = await axios.get(
      `https://openexchangerates.org/api/historical/${nextDate}.json`,
      {
        params: {
          app_id: process.env.OPEN_EXCHANGE_RATES_API,
          symbols: symbolsForOpenExchangeRateApi,
        },
      }
    );

    var USDbaseRates = ratesRequest.data.rates;
    const ZIGrates = await fetchZigRate();
    if (ZIGrates.length > 0) {
      USDbaseRates.ZIG = parseFloat(ZIGrates[1].avg);
    } else {
      console.log("error fetching ZIG");
      USDbaseRates.ZIG = "error fetching ZIG";
    }

    // Make sure that all required data exists in the required format
    var alldenoms = getDenominations({ formatAsList: true });

    if (typeof alldenoms === "string") {
      // Remove CXX from string
      alldenoms = alldenoms
        .replace("CXX,", "")
        .replace(",CXX", "")
        .replace("CXX", "");

      const requiredDenoms = alldenoms.split(",");

      // Check if every required denomination is present in USDbaseRates and has a number value
      let allValid = true;

      requiredDenoms.forEach((code) => {
        if (
          !USDbaseRates.hasOwnProperty(code) ||
          typeof USDbaseRates[code] !== "number"
        ) {
          allValid = false;
        }
      });

      if (!allValid) {
        console.error(
          "Error in fetching and processing USD base rates. Some required denominations are missing or have non-numeric values:",
          {
            USDbaseRates,
            requiredDenoms,
          }
        );
        console.log("Aborting DCO");
        return false;
      }

      console.log("Exchange rates fetched and checked.");
    }

    const denomsInXAU = _.mapValues(
      USDbaseRates,
      (value) => value / USDbaseRates.XAU
    );

    console.log("Fetching declared DCO participants");
    const DCOparticipantsDeclared = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode{Active:true})
      MATCH (DCOparticpantsDeclared:Account)<-[:OWNS]-(DCOmember:Member)
      WHERE DCOparticpantsDeclared.DCOgiveInCXX > 0
      RETURN
        DCOparticpantsDeclared.accountID AS accountID,
        DCOmember.memberID AS DCOmemberID,
        DCOparticpantsDeclared.DCOgiveInCXX AS DCOgiveInCXX,
        DCOparticpantsDeclared.DCOgiveInCXX
          / daynode[DCOparticpantsDeclared.DCOdenom]
          AS DCOgiveInDenom,
        DCOparticpantsDeclared.DCOdenom AS DCOdenom
    `);

    console.log("Filtering participants for available secured balance");
    const declaredParticipants = DCOparticipantsDeclared.records;
    console.log("declaredParticipants: " + declaredParticipants.length);
    let DCOinCXX = 0;
    let DCOinXAU = 0;
    const confirmedParticipants = [];

    for (const declaredParticipant of declaredParticipants) {
      const accountID = declaredParticipant.get("accountID");
      const DCOmemberID = declaredParticipant.get("DCOmemberID");
      const DCOdenom = declaredParticipant.get("DCOdenom");
      const DCOgiveInCXX = declaredParticipant.get("DCOgiveInCXX");
      const DCOgiveInDenom = declaredParticipant.get("DCOgiveInDenom");
      const securableData = await GetSecuredAuthorizationService(
        accountID,
        DCOdenom
      );

      if (DCOgiveInDenom <= securableData.securableAmountInDenom) {
        confirmedParticipants.push(declaredParticipant);
        DCOinCXX += DCOgiveInCXX;
        DCOinXAU += DCOgiveInDenom / denomsInXAU[DCOdenom];
      }
    }

    const numberConfirmedParticipants = confirmedParticipants.length;
    const nextCXXinXAU = DCOinXAU / numberConfirmedParticipants;
    const CXXprior_CXXcurrent = DCOinCXX / numberConfirmedParticipants;
    console.log("numberConfirmedParticipants: " + numberConfirmedParticipants);
    console.log("DCOinCXX: " + DCOinCXX);
    console.log("DCOinXAU: " + DCOinXAU);
    console.log("nextCXXinXAU: " + nextCXXinXAU);

    const newCXXrates = _.mapValues(
      denomsInXAU,
      (value) => 1 / nextCXXinXAU / value
    );
    newCXXrates.CXX = 1;
    console.log("newCXXrates:");
    console.log(newCXXrates);

    console.log("Creating new daynode");
    await ledgerSpaceSession.run(
      `
      MATCH (expiringDaynode:Daynode {Active: TRUE})
      CREATE (expiringDaynode)-[:NEXT_DAY]->(nextDaynode:Daynode)
      SET expiringDaynode.Active = false,
          expiringDaynode.DCOrunningNow = false,
          nextDaynode = $newCXXrates,
          nextDaynode.CXXprior_CXXcurrent = $CXXprior_CXXcurrent,
          nextDaynode.Date = date($nextDate),
          nextDaynode.Active = true,
          nextDaynode.DCOrunningNow = true
    `,
      { newCXXrates, nextDate, CXXprior_CXXcurrent }
    );

    console.log("Creating DCO give transactions");
    const getFoundationData = (
      await ledgerSpaceSession.run(`
      MATCH (credexFoundation:Account {accountType: "CREDEX_FOUNDATION"})<-[:OWNS]-(foundationXO:Member)
      RETURN
        credexFoundation.accountID AS foundationID,
        foundationXO.memberID AS foundationXOid
    `)
    )
    
    const foundationID = getFoundationData.records[0].get("foundationID");
    const foundationXOid = getFoundationData.records[0].get("foundationXOid");

    const offerAndAcceptPromisesDCOgive = confirmedParticipants.map(
      async (confirmedParticipant) => {
        const dataForDCOgive = {
          memberID: confirmedParticipant.get("DCOmemberID"),
          issuerAccountID: confirmedParticipant.get("accountID"),
          receiverAccountID: foundationID,
          Denomination: confirmedParticipant.get("DCOdenom"),
          InitialAmount: confirmedParticipant.get("DCOgiveInDenom"),
          credexType: "DCO_GIVE",
          securedCredex: true,
        };

        const DCOgiveCredex = await OfferCredexService(dataForDCOgive);
        if (typeof DCOgiveCredex.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (
          DCOgiveCredex.credex &&
          typeof DCOgiveCredex.credex.credexID === "string"
        ) {
          return AcceptCredexService(
            DCOgiveCredex.credex.credexID,
            foundationXOid
          );
        } else {
          throw new Error("Invalid credexID from OfferCredexService");
        }
      }
    );

    await Promise.all(offerAndAcceptPromisesDCOgive);

    console.log("Updating credex and asset balances");
    await ledgerSpaceSession.run(`
      MATCH (newDaynode:Daynode {Active: TRUE})

      // Update balances on CXX credexes
      MATCH (credcoinCredex:Credex)
      WHERE credcoinCredex.Denomination = "CXX"
      SET 
        credcoinCredex.InitialAmount =
          credcoinCredex.InitialAmount
          / newDaynode.CXXprior_CXXcurrent,
        credcoinCredex.OutstandingAmount =
          credcoinCredex.OutstandingAmount
          / newDaynode.CXXprior_CXXcurrent,
        credcoinCredex.RedeemedAmount =
          credcoinCredex.RedeemedAmount
          / newDaynode.CXXprior_CXXcurrent,
        credcoinCredex.DefaultedAmount =
          credcoinCredex.DefaultedAmount
          / newDaynode.CXXprior_CXXcurrent,
        credcoinCredex.WrittenOffAmount =
          credcoinCredex.WrittenOffAmount
          / newDaynode.CXXprior_CXXcurrent

      // Update balances on currency credexes
      WITH newDaynode
      MATCH (currencyCredex:Credex)
      WHERE currencyCredex.Denomination <> "CXX"
      SET
        currencyCredex.InitialAmount =
          (currencyCredex.InitialAmount / currencyCredex.CXXmultiplier)
          * newDaynode[currencyCredex.Denomination],
        currencyCredex.OutstandingAmount =
          (currencyCredex.OutstandingAmount / currencyCredex.CXXmultiplier)
          * newDaynode[currencyCredex.Denomination],
        currencyCredex.RedeemedAmount =
          (currencyCredex.RedeemedAmount / currencyCredex.CXXmultiplier)
          * newDaynode[currencyCredex.Denomination],
        currencyCredex.DefaultedAmount =
          (currencyCredex.DefaultedAmount / currencyCredex.CXXmultiplier)
          * newDaynode[currencyCredex.Denomination],
        currencyCredex.WrittenOffAmount =
          (currencyCredex.WrittenOffAmount / currencyCredex.CXXmultiplier)
          * newDaynode[currencyCredex.Denomination],
        currencyCredex.CXXmultiplier = newDaynode[currencyCredex.Denomination]

      // Update balances on CXX :REDEEMED relationships
      WITH newDaynode
      MATCH ()-[CXXredeemed:REDEEMED]-()
      WHERE CXXredeemed.Denomination = "CXX"
      SET
        CXXredeemed.AmountRedeemed =
          CXXredeemed.AmountRedeemed
          / newDaynode.CXXprior_CXXcurrent,
        CXXredeemed.AmountOutstandingNow =
          CXXredeemed.AmountOutstandingNow
          / newDaynode.CXXprior_CXXcurrent

      // Update balances on currency :REDEEMED relationships
      WITH newDaynode
      MATCH ()-[currencyRedeemed:REDEEMED]-()
      WHERE currencyRedeemed.Denomination <> "CXX"
      SET
        currencyRedeemed.AmountOutstandingNow =
          (currencyRedeemed.AmountOutstandingNow / currencyRedeemed.CXXmultiplier)
          * newDaynode[currencyRedeemed.Denomination],
        currencyRedeemed.AmountRedeemed =
          (currencyRedeemed.AmountRedeemed / currencyRedeemed.CXXmultiplier)
          * newDaynode[currencyRedeemed.Denomination],
        currencyRedeemed.CXXmultiplier = newDaynode[currencyRedeemed.Denomination]

      // Update balances on CXX :CREDLOOP relationships
      WITH newDaynode
      MATCH ()-[CXXcredloop:CREDLOOP]-()
      WHERE CXXcredloop.Denomination = "CXX"
      SET
        CXXcredloop.AmountRedeemed =
          CXXcredloop.AmountRedeemed
          / newDaynode.CXXprior_CXXcurrent,
        CXXcredloop.AmountOutstandingNow =
          CXXcredloop.AmountOutstandingNow
          / newDaynode.CXXprior_CXXcurrent

      // Update balances on currency :CREDLOOP relationships
      WITH newDaynode
      MATCH ()-[currencyCredloop:CREDLOOP]-()
      WHERE currencyCredloop.Denomination <> "CXX"
      SET
        currencyCredloop.AmountOutstandingNow =
          (currencyCredloop.AmountOutstandingNow / currencyCredloop.CXXmultiplier)
          * newDaynode[currencyCredloop.Denomination],
        currencyCredloop.AmountRedeemed =
          (currencyCredloop.AmountRedeemed / currencyCredloop.CXXmultiplier)
          * newDaynode[currencyCredloop.Denomination],
        currencyCredloop.CXXmultiplier = newDaynode[currencyCredloop.Denomination]

      // Update balances on loop anchors (always CXX)
      WITH newDaynode
      MATCH (loopAnchors:LoopAnchor)
      SET
        loopAnchors.LoopedAmount =
          loopAnchors.LoopedAmount
          / newDaynode.CXXprior_CXXcurrent
    `);

    //update balances in searchSpace CXX credexes
    await searchSpaceSession.run(
      `
      MATCH (credex:Credex)
      WHERE credex.Denomination = "CXX"
      SET
        credex.outstandingAmount =
          credex.outstandingAmount
          / $CXXprior_CXXcurrent
    `,
      { CXXprior_CXXcurrent }
    );

    //update balances in searchSpace currency credexes
    await searchSpaceSession.run(
      `
        MATCH (credex:Credex)
        WHERE credex.Denomination <> "CXX"
        WITH credex, $newCXXrates AS rates
        SET credex.outstandingAmount = 
              (credex.outstandingAmount / credex.CXXmultiplier) * 
              coalesce(rates[credex.Denomination], 1),
            credex.CXXmultiplier = coalesce(rates[credex.Denomination], 1)
      `,
      { newCXXrates }
    );

    console.log("Creating DCO receive transactions");
    const offerAndAcceptPromisesDCOreceive = confirmedParticipants.map(
      async (confirmedParticipant) => {
        const dataForDCOreceive = {
          memberID: foundationXOid,
          issuerAccountID: foundationID,
          receiverAccountID: confirmedParticipant.get("accountID"),
          Denomination: "CXX",
          InitialAmount: 1,
          credexType: "DCO_RECEIVE",
          securedCredex: true,
        };

        const DCOreceiveCredex = await OfferCredexService(dataForDCOreceive);
        if (typeof DCOreceiveCredex.credex == "boolean") {
          throw new Error("Invalid response from OfferCredexService");
        }
        if (
          DCOreceiveCredex.credex &&
          typeof DCOreceiveCredex.credex.credexID === "string"
        ) {
          return AcceptCredexService(
            DCOreceiveCredex.credex.credexID,
            foundationXOid
          );
        } else {
          throw new Error("Invalid credexID from OfferCredexService");
        }
      }
    );

    await Promise.all(offerAndAcceptPromisesDCOreceive);

    console.log("Start of day backup...");
    await createNeo4jBackup(nextDate, "_start");
    console.log("Start of day backup completed.");
    console.log(`DCOexecute done to open ${nextDate}`);
  } catch (error) {
    console.error("Error during DCOexecute:", error);
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }

  return true;
}



File: ./src/Core/DCO/DBinitialization.ts
----------------------------------------
import { ledgerSpaceDriver, searchSpaceDriver } from "../../../config/neo4j";
import { getDenominations } from "../constants/denominations";
import { OnboardMemberService } from "../../Member/services/OnboardMember";
import { UpdateMemberTierService } from "../../Member/services/UpdateMemberTier";
import { CreateAccountService } from "../../Account/services/CreateAccount";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import { fetchZigRate } from "./fetchZigRate";
import axios from "axios";
import _ from "lodash";

export async function DBinitialization(): Promise<void> {
  console.log("DBinitialization start");

  const ledgerSpaceSession = ledgerSpaceDriver.session();
  const searchSpaceSession = searchSpaceDriver.session();

  try {
    console.log("Creating database constraints and indexes...");

    //remove any current db constraints
    await ledgerSpaceSession.run(
      `
      CALL apoc.schema.assert({}, {})
      `
    );

    await searchSpaceSession.run(
      `
      CALL apoc.schema.assert({}, {})
      `
    );

    //set constraints
    await ledgerSpaceSession.run(
      `
      CREATE CONSTRAINT daynodeDate_unique IF NOT EXISTS
      FOR (daynode:Daynode) REQUIRE daynode.Date IS UNIQUE
      `
    );

    await ledgerSpaceSession.run(
      `
      CREATE CONSTRAINT memberID_unique IF NOT EXISTS
      FOR (member:Member) REQUIRE member.memberID IS UNIQUE
      `
    );

    await ledgerSpaceSession.run(
      `
      CREATE CONSTRAINT memberHandle_unique IF NOT EXISTS
      FOR (member:Member) REQUIRE member.memberHandle IS UNIQUE
      `
    );

    await ledgerSpaceSession.run(
      `
      CREATE CONSTRAINT memberPhone_unique IF NOT EXISTS
      FOR (member:Member) REQUIRE member.phone IS UNIQUE
      `
    );

    await ledgerSpaceSession.run(
      `
      CREATE CONSTRAINT accountID_unique IF NOT EXISTS
      FOR (account:Account) REQUIRE account.accountID IS UNIQUE
      `
    );

    await ledgerSpaceSession.run(
      `
      CREATE CONSTRAINT accountHandle_unique IF NOT EXISTS
      FOR (account:Account) REQUIRE account.accountHandle IS UNIQUE
      `
    );

    await searchSpaceSession.run(
      `
      CREATE CONSTRAINT accountID_unique IF NOT EXISTS
      FOR (account:Account) REQUIRE account.accountID IS UNIQUE
      `
    );

    await searchSpaceSession.run(
      `
      CREATE CONSTRAINT credexID_unique IF NOT EXISTS
      FOR (credex:Credex) REQUIRE credex.credexID IS UNIQUE
      `
    );

    console.log("establish dayZero");
    const dayZero = "2024-08-15";
    console.log("dayZero:", dayZero);

    const OneCXXinCXXdenom = 1;
    const CXXdenom = "CAD";
    console.log(OneCXXinCXXdenom + " CXX = 1 " + CXXdenom);

    console.log("Loading currencies and current rates...");
    const symbols = getDenominations({
      sourceForRate: "OpenExchangeRates",
      formatAsList: true,
    });
    // docs: https://docs.openexchangerates.org/reference/historical-json
    const baseUrl = `https://openexchangerates.org/api/historical/${dayZero}.json?app_id=${process.env.OPEN_EXCHANGE_RATES_API}&symbols=${symbols}`;
    const {
      data: { rates: USDbaseRates },
    } = await axios.get(baseUrl);

    //this always gets current rates (not historical for dev)
    USDbaseRates.ZIG = (await fetchZigRate())[1].avg;

    //convert USD base rate from query to XAU
    const XAUbaseRates = _.mapValues(
      USDbaseRates,
      (value) => value / USDbaseRates.XAU
    );

    console.log("Establishing dayZero CXX rates...");
    const dayZeroCXXrates = _.mapValues(
      XAUbaseRates,
      (value) => (1 / value) * OneCXXinCXXdenom * XAUbaseRates[CXXdenom]
    );
    //add CXX to rates
    dayZeroCXXrates.CXX = 1;
    console.log("dayZeroCXXrates:");
    console.log(dayZeroCXXrates);

    console.log("Creating dayzero daynode...");
    await ledgerSpaceSession.run(
      `
        CREATE (daynode:Daynode)
        SET daynode = $dayZeroCXXrates,
            daynode.Date = date($dayZero),
            daynode.Active = TRUE,
            daynode.DCOrunningNow = TRUE
      `,
      { dayZeroCXXrates, dayZero }
    );

    console.log("Creating initialization accounts and relationships...");

    //create initial member
    const rdubs = await OnboardMemberService("Ryan", "Watson", "263778177125");
    if (typeof rdubs.onboardedMemberID == "boolean") {
      throw new Error("rdubs could not be created");
    }

    //update rdubs member tier to enable account creation below
    const tierUpdated = await UpdateMemberTierService(
      rdubs.onboardedMemberID,
      5
    );
    if (!tierUpdated) {
      throw new Error("rdubs memberTier could not be updated");
    }

    const rdubsPersonalAccount = await CreateAccountService(
      rdubs.onboardedMemberID,
      "PERSONAL_CONSUMPTION",
      "Ryan Watson Personal",
      "ryanlukewatson",
      "USD",
      1,
      CXXdenom
    );

    const rdubsAccountID = rdubsPersonalAccount.accountID;

    //create credex foundation
    const credexFoundation = await CreateAccountService(
      rdubs.onboardedMemberID,
      "CREDEX_FOUNDATION",
      "Credex Foundation",
      "credexfoundation",
      "CXX"
    );
    let credexFoundationID;
    if (typeof credexFoundation.account == "boolean") {
      throw new Error("credexFoundation could not be created");
    }
    if (
      credexFoundation.accountID &&
      typeof credexFoundation.accountID === "string"
    ) {
      credexFoundationID = credexFoundation.accountID;
    } else {
      throw new Error("credexFoundation could not be created");
    }

    //create great sun
    const greatSun = await CreateAccountService(
      rdubs.onboardedMemberID,
      "BUSINESS",
      "Great Sun Financial",
      "greatsunfinancial",
      "CAD"
    );
    if (!greatSun) {
      throw new Error("greatSun could not be created");
    }
    const greatSunID = greatSun.accountID;

    //create vimbisopay
    const vimbisoPay = await CreateAccountService(
      rdubs.onboardedMemberID,
      "BUSINESS",
      "VimbisoPay",
      "vimbisopay.audited",
      "CAD"
    );
    if (!greatSun) {
      throw new Error("vimbisoPay could not be created");
    }
    const vimbisoPayID = vimbisoPay.accountID;

    //create to secure participation in first DCO
    await ledgerSpaceSession.run(
      `
        MATCH (credexFoundation: Account { accountID: $credexFoundationID })
        MATCH (greatSun: Account { accountID: $greatSunID })
        MATCH (vimbisoPay: Account { accountID: $vimbisoPayID })
        MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (credexFoundation)
        MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (greatSun)
        MERGE (credexFoundation) - [:CREDEX_FOUNDATION_AUDITED] -> (vimbisoPay)
      `,
      { credexFoundationID, greatSunID, vimbisoPayID }
    );

    //charging an account for participation in first DCO
    const credexData = {
      memberID: rdubs.onboardedMemberID,
      issuerAccountID: greatSunID,
      receiverAccountID: rdubsAccountID,
      Denomination: CXXdenom,
      InitialAmount: OneCXXinCXXdenom * 365, // fund DCO for a year with no adjustments
      credexType: "PURCHASE",
      securedCredex: true,
    };

    const DCOinitializationOfferCredex = await OfferCredexService(credexData);
    if (typeof DCOinitializationOfferCredex.credex == "boolean") {
      throw new Error("Invalid response from OfferCredexService");
    }
    if (
      DCOinitializationOfferCredex.credex &&
      typeof DCOinitializationOfferCredex.credex.credexID === "string"
    ) {
      await AcceptCredexService(
        DCOinitializationOfferCredex.credex.credexID,
        rdubs.onboardedMemberID
      );
    } else {
      throw new Error("Invalid credexID from OfferCredexService");
    }
  } catch (error) {
    console.error("Error during DBinitialization:", error);
  } finally {
    await ledgerSpaceSession.close();
    await searchSpaceSession.close();
  }
}



File: ./src/Core/DCO/DCOavatars.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { OfferCredexService } from "../../Credex/services/OfferCredex";
import { AcceptCredexService } from "../../Credex/services/AcceptCredex";
import moment from "moment-timezone";

/**
 * DCOavatars function
 * This function is run as a cronjob every 24 hours to process recurring avatars.
 * It identifies active recurring avatars, creates credexes, and updates their status.
 */
export async function DCOavatars() {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    console.log("Checking for activated recurring avatars...");
    
    // Query to get active recurring avatars that are due for processing
    const GetActiveRecurringAvatars = await ledgerSpaceSession.run(`
      MATCH (daynode:Daynode {Active: true})
      MATCH
        (issuer:Account)-[rel1:ACTIVE]->
        (avatar:Avatar { avatarType: "RECURRING", nextPayDate: daynode.Date})-[rel2:ACTIVE]->
        (acceptor:Account)
      MATCH
        (issuer)<-[authRel1:AUTHORIZED_FOR]-
        (avatar)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2
      
      // Reduce remainingPays by 1 if it exists
      SET avatar.remainingPays = 
        CASE
          WHEN avatar.remainingPays IS NOT NULL THEN avatar.remainingPays - 1
          ELSE null
        END
      
      // Calculate the new nextPayDate
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2,
           CASE
             WHEN avatar.remainingPays IS NULL OR avatar.remainingPays > 0 
             THEN date(avatar.nextPayDate) + duration({days: avatar.daysBetweenPays})
             ELSE null
           END AS newNextPayDate
      
      // Update nextPayDate
      SET avatar.nextPayDate = newNextPayDate
      
      WITH daynode, issuer, avatar, acceptor, rel1, rel2, authRel1, authRel2, newNextPayDate
      
      // Check if the avatar should be marked as completed
      OPTIONAL MATCH (issuer)-[completed1:COMPLETED]->(avatar)-[completed2:COMPLETED]->(acceptor)
      FOREACH(ignoreMe IN CASE WHEN newNextPayDate IS NULL AND completed1 IS NULL
               THEN [1] ELSE [] END |
        DELETE rel1, rel2, authRel1, authRel2
        CREATE (issuer)-[:COMPLETED]->(avatar)-[:COMPLETED]->(acceptor)
      )
      
      RETURN
        avatar {
          .*,
          remainingPays: avatar.remainingPays,
          nextPayDate: avatar.nextPayDate
        } AS avatar,
        issuer.accountID AS issuerAccountID,
        acceptor.accountID AS acceptorAccountID,
        daynode.Date AS Date    
    `);

    // Process each active recurring avatar
    for (const record of GetActiveRecurringAvatars.records) {
      const avatar = record.get("avatar");
      const issuerAccountID = record.get("issuerAccountID");
      const acceptorAccountID = record.get("acceptorAccountID");

      // Prepare data for creating a new credex
      const offerData: any = {
        memberID: avatar.memberID,
        issuerAccountID: issuerAccountID,
        receiverAccountID: acceptorAccountID,
        Denomination: avatar.Denomination,
        InitialAmount: avatar.InitialAmount,
        credexType: "PURCHASE",
        OFFERSorREQUESTS: "OFFERS",
      };

      // Handle secured and unsecured credexes differently
      if (avatar.securedCredex) {
        offerData.securedCredex = true;
      } else {
        // Calculate dueDate for unsecured credexes using the avatar's credspan
        avatar.dueDate = moment(record.get("Date"))
          .add(avatar.credspan, "days")
          .format("YYYY-MM-DD");
        
        offerData.dueDate = avatar.dueDate;
      }

      // Create a new credex offer
      const offerResult = await OfferCredexService(offerData);

      // If offer is successful, automatically accept it
      if (
        offerResult &&
        typeof offerResult.credex === "object" &&
        offerResult.credex.credexID
      ) {
        const acceptResult = await AcceptCredexService(
          offerResult.credex.credexID,
          avatar.memberID
        );
        if (acceptResult) {
          console.log(
            `Successfully created credex for recurring avatar: ${avatar.memberID}. Remaining pays: ${avatar.remainingPays}, Next pay date: ${avatar.nextPayDate}`
          );
        } else {
          console.error(
            `Failed to accept credex for avatar: ${avatar.memberID}`
          );
        }
      } else {
        console.error(`Failed to create offer for avatar: ${avatar.memberID}`);
      }
    }
  } catch (error) {
    console.error("Error in DCOavatars:", error);
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Core/DCO/fetchZigRate.ts
----------------------------------------
import axios from "axios";
import cheerio from "cheerio";

const https = require("https");

const url = "https://www.rbz.co.zw/index.php";

const httpsAgent = new https.Agent({
  rejectUnauthorized: false, // To Ignore SSL errors in dev
});

export async function fetchZigRate(): Promise<
  { currency: string; bid: string; ask: string; avg: string }[]
> {
  try {
    const { data } = await axios.get(url, { httpsAgent });
    const parsedHtml = cheerio.load(data);

    const rates: { currency: string; bid: string; ask: string; avg: string }[] =
      [];

    parsedHtml("#baTab1 table tbody tr").each((index: number, element: any) => {
      const currency: string = parsedHtml(element)
        .find("td")
        .eq(0)
        .text()
        .trim();
      const bid: string = parsedHtml(element).find("td").eq(1).text().trim();
      const ask: string = parsedHtml(element).find("td").eq(2).text().trim();
      const avg: string = parsedHtml(element).find("td").eq(3).text().trim();

      if (currency && bid && ask && avg) {
        rates.push({ currency, bid, ask, avg });
      }
    });
    //console.log(rates);
    return rates;
  } catch (error) {
    console.error("Error fetching exchange rates:", error);
    return [];
  }
}



File: ./src/Credex/credexRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { OfferCredexController } from "./controllers/offerCredex";
import { AcceptCredexController } from "./controllers/acceptCredex";
import { AcceptCredexBulkController } from "./controllers/acceptCredexBulk";
import { DeclineCredexController } from "./controllers/declineCredex";
import { CancelCredexController } from "./controllers/cancelCredex";
import { GetCredexController } from "./controllers/getCredex";
import { GetLedgerController } from "./controllers/getLedger";

export default function CredexRoutes(
  app: express.Application,
  jsonParser: any
) {
  app.post(
    `${apiVersionOneRoute}offerCredex`,
    jsonParser,
    OfferCredexController
  );

  app.put(
    `${apiVersionOneRoute}acceptCredex`,
    jsonParser,
    AcceptCredexController
  );

  app.put(
    `${apiVersionOneRoute}acceptCredexBulk`,
    jsonParser,
    AcceptCredexBulkController
  );

  app.put(
    `${apiVersionOneRoute}declineCredex`,
    jsonParser,
    DeclineCredexController
  );

  app.put(
    `${apiVersionOneRoute}cancelCredex`,
    jsonParser,
    CancelCredexController
  );

  app.get(`${apiVersionOneRoute}getCredex`, jsonParser, GetCredexController);

  app.get(`${apiVersionOneRoute}getLedger`, jsonParser, GetLedgerController);
}



File: ./src/Credex/controllers/getLedger.ts
----------------------------------------
import express from "express";
import { GetLedgerService } from "../services/GetLedger";

export async function GetLedgerController(
  req: express.Request,
  res: express.Response
) {
  try {
    const responseData = await GetLedgerService(
      req.body.accountID,
      req.body.numRows,
      req.body.startRow
    );
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/controllers/cancelCredex.ts
----------------------------------------
import express from "express";
import { CancelCredexService } from "../services/CancelCredex";

export async function CancelCredexController(
  req: express.Request,
  res: express.Response,
) {
  const fieldsRequired = ["credexID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }
  try {
    const responseData = await CancelCredexService(req.body.credexID);
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/controllers/acceptCredex.ts
----------------------------------------
import express from "express";
import { AcceptCredexService } from "../services/AcceptCredex";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

export async function AcceptCredexController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["credexID", "signerID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    const acceptCredexData = await AcceptCredexService(
      req.body.credexID,
      req.body.signerID,
    );
    
    if (acceptCredexData) {
      const dashboardData = await GetAccountDashboardService(
        req.body.signerID,
        acceptCredexData.acceptorAccountID
      );
      res.json({
        acceptCredexData: acceptCredexData,
        dashboardData: dashboardData,
      });
    }
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/controllers/offerCredex.ts
----------------------------------------
import express from "express";
import { OfferCredexService } from "../services/OfferCredex";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

/**
 * OfferCredexController
 * 
 * This controller handles the creation of new Credex offers.
 * It validates the required fields, calls the OfferCredexService,
 * and returns the result along with updated dashboard data.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function OfferCredexController(
  req: express.Request,
  res: express.Response
) {
  // Validate required fields
  const fieldsRequired = [
    "memberID",
    "issuerAccountID",
    "receiverAccountID",
    "Denomination",
    "InitialAmount",
  ];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    // Call OfferCredexService to create the Credex offer
    const offerCredexData = await OfferCredexService(req.body);
    
    // Fetch updated dashboard data
    const dashboardData = await GetAccountDashboardService(
      req.body.memberID,
      req.body.issuerAccountID
    );
    
    // Return the offer data and updated dashboard data
    res.json({
      offerCredexData: offerCredexData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in OfferCredexController:", err);
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/controllers/declineCredex.ts
----------------------------------------
import express from "express";
import { DeclineCredexService } from "../services/DeclineCredex";

export async function DeclineCredexController(
  req: express.Request,
  res: express.Response,
) {
  const fieldsRequired = ["credexID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }
  try {
    const responseData = await DeclineCredexService(req.body.credexID);
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/controllers/acceptCredexBulk.ts
----------------------------------------
import express from "express";
import { AcceptCredexService } from "../services/AcceptCredex";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

export async function AcceptCredexBulkController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["credexIDs", "signerID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  if (
    !Array.isArray(req.body.credexIDs) ||
    !req.body.credexIDs.every((id: any) => typeof id === "string")
  ) {
    return res
      .status(400)
      .json({ message: "Array of credexIDs to accept is required" });
  }

  try {
    const acceptCredexData = await Promise.all(
      req.body.credexIDs.map(async (credexID: string) => {
        const data = await AcceptCredexService(credexID, req.body.signerID);
        if (data) {
          return data;
        }
        return null;
      })
    );

    // Filter out any null values
    const validCredexData = acceptCredexData.filter(
      (
        item
      ): item is {
        acceptedCredexID: any;
        acceptorAccountID: any;
        memberID: any;
      } => item !== null
    );

    if (validCredexData.length > 0) {
      // Assuming that memberID and acceptorAccountID are the same for all returned objects
      const { memberID, acceptorAccountID } = validCredexData[0];

      const dashboardData = await GetAccountDashboardService(
        memberID,
        acceptorAccountID
      );
      res.json({
        acceptCredexData: validCredexData,
        dashboardData: dashboardData,
      });
    } else {
      // Handle the case when there are no valid data returned from AcceptCredexService
      res
        .status(400)
        .json({ error: "No valid data returned from AcceptCredexService" });
    }
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/controllers/getCredex.ts
----------------------------------------
import express from "express";
import { GetCredexService } from "../services/GetCredex";

export async function GetCredexController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["credexID", "accountID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    const responseData = await GetCredexService(
      req.body.credexID,
      req.body.accountID
    );
    res.json(responseData);
  } catch (err) {
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Credex/services/OfferCredex.ts
----------------------------------------
import { CreateCredexService } from "./CreateCredex";
import { ledgerSpaceDriver } from "../../../config/neo4j";

/**
 * OfferCredexService
 * 
 * This service handles the creation of a new Credex offer.
 * It uses the CreateCredexService to create the Credex and then
 * signs the offer and prepares it for notification.
 * 
 * @param credexData - An object containing the data for the new Credex
 * @returns The result of the Credex offer creation
 */
export async function OfferCredexService(credexData: any) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    // Set default values for the Credex
    credexData.OFFERSorREQUESTS = "OFFERS";
    if (!credexData.credexType) {
      credexData.credexType = "PURCHASE";
    }
    
    // Create the new Credex
    const newCredex = await CreateCredexService(credexData);

    // Sign the Credex and prepare for notification
    sendNoti: if (
      typeof newCredex.credex != "boolean" &&
      newCredex.credex.credexID
    ) {
      const signAndGetSendOfferToQuery = await ledgerSpaceSession.run(
        `
        MATCH
          (credex:Credex { credexID: $credexID })<-[:OFFERS]-
          (Account)<-[:AUTHORIZED_FOR]-
          (signer:Member|Avatar { memberID: $signingMemberID })
        CREATE (credex)<-[:SIGNED]-(signer)
        RETURN signer.memberID AS signerID
        `,
        {
          recipientID: credexData.receiverAccountID,
          credexID: newCredex.credex.credexID,
          signingMemberID: credexData.memberID,
        }
      );

      if (!signAndGetSendOfferToQuery.records.length) {
        console.log("could not get notiPhone");
        break sendNoti;
      }
      // TODO: Implement offer notification
      // const notiPhone = signAndGetSendOfferToQuery.records[0].get("notiPhone");
      // console.log("sending offer notification to " + notiPhone);
      // hit offer noti endpoint
    }
    console.log(newCredex.message);

    return newCredex;
  } catch (error) {
    console.error("Error offering credex:", error);
    throw error; // Rethrow to allow further handling upstream
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/CreateCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import {
  getDenominations,
  denomFormatter,
} from "../../Core/constants/denominations";
import { GetSecuredAuthorizationService } from "./GetSecuredAuthorization";
import { checkDueDate, credspan } from "../../Core/constants/credspan";
import { checkPermittedCredexType } from "../../Core/constants/credexTypes";
import { SecuredCredexAuthForTier } from "../../Member/services/SecuredCredexAuthForTier";

export async function CreateCredexService(credexData: any) {
  const {
    issuerAccountID,
    receiverAccountID,
    InitialAmount,
    Denomination,
    credexType,
    OFFERSorREQUESTS,
    securedCredex = false,
    dueDate = "",
  } = credexData;

  const ledgerSpaceSession = ledgerSpaceDriver.session();

  // Validate input data
  if (
    !issuerAccountID ||
    !receiverAccountID ||
    issuerAccountID == receiverAccountID ||
    !InitialAmount ||
    !Denomination ||
    !credexType ||
    !OFFERSorREQUESTS ||
    (securedCredex && dueDate) ||
    (!securedCredex && !dueDate)
  ) {
    let failMessage = "Data missing or mismatch, could not create credex.";
    if (!issuerAccountID) failMessage += " issuerAccountID required";
    if (!receiverAccountID) failMessage += " receiverAccountID required";
    if (issuerAccountID == receiverAccountID)
      failMessage += " issuer and receiver cannot be the same account";
    if (!InitialAmount) failMessage += " InitialAmount required";
    if (!Denomination) failMessage += " Denomination required";
    if (!credexType) failMessage += " credexType required";
    if (!OFFERSorREQUESTS) failMessage += " OFFERSorREQUESTS required";
    if (securedCredex && dueDate)
      failMessage += " Secured credex cannot have a due date";
    if (!securedCredex && !dueDate)
      failMessage += " Unsecured credex must have a due date";
    console.log(failMessage);
    console.log(credexData);
    return { credex: false, message: failMessage };
  }

  // make sure InitialAmount is a number
  if (typeof InitialAmount != "number") {
    const message = "Error: InitialAmount must be a number";
    console.log(message);
    console.log(credexData);
    return {
      credex: false,
      message: message,
    };
  }

  // Check denomination validity
  if (!getDenominations({ code: Denomination }).length) {
    const message = "Error: denomination not permitted";
    console.log(message);
    console.log(credexData);
    return {
      credex: false,
      message: message,
    };
  }

  // Check credex type validity
  if (!checkPermittedCredexType(credexType)) {
    const message = "Error: credex type not permitted";
    console.log(message);
    console.log(credexData);
    return {
      credex: false,
      message: message,
    };
  }

  // Validate OFFERSorREQUESTS and set OFFEREDorREQUESTED accordingly
  let OFFEREDorREQUESTED = "";
  if (OFFERSorREQUESTS === "OFFERS") {
    OFFEREDorREQUESTED = "OFFERED";
  } else if (OFFERSorREQUESTS === "REQUESTS") {
    OFFEREDorREQUESTED = "REQUESTED";
  } else {
    const message = "Error: invalid OFFER/REQUEST";
    console.log(message);
    console.log(credexData);
    return {
      credex: false,
      message: message,
    };
  }

  // Check due date for unsecured credex
  if (!securedCredex) {
    const dueDateOK = await checkDueDate(dueDate);
    if (!dueDateOK) {
      const message = `Error: due date must be permitted date, in format YYYY-MM-DD. First permitted due date is 1 week from today. Last permitted due date is ${
        credspan / 7
      } weeks from today.`;
      console.log(message);
      console.log(credexData);
      return {
        credex: false,
        message: message,
      };
    }
  }

  //check that secured credex is within limits of membership tier
  if (securedCredex) {
    const tierAuth = await SecuredCredexAuthForTier(
      issuerAccountID,
      InitialAmount,
      Denomination
    );
    if (tierAuth != true) {
      return {
        credex: false,
        message: tierAuth,
      };
    }
  }

  //check that unsecured credex is permitted on membership tier
  if (!securedCredex) {
    const getMemberTier = await ledgerSpaceSession.run(
      `
        MATCH (member:Member)-[:OWNS]->(account:Account { accountID: $issuerAccountID })
        RETURN member.memberTier as memberTier
      `,
      { issuerAccountID }
    );

    const memberTier = getMemberTier.records[0].get("memberTier");
    if (memberTier == 1) {
      return {
        credex: false,
        message: "Members on the Open Tier cannot issue unsecured credexes",
      };
    }
  }

  // Get securable data for secured credex
  let secureableData = { securerID: "", securableAmountInDenom: 0 };
  if (securedCredex) {
    secureableData = await GetSecuredAuthorizationService(
      issuerAccountID,
      Denomination
    );
    if (secureableData.securableAmountInDenom < InitialAmount) {
      console.log("secureableData.securableAmountInDenom: ");
      console.log(secureableData.securableAmountInDenom);
      console.log("InitialAmount: ");
      console.log(InitialAmount);

      return {
        credex: false,
        message: `Error: Your secured credex for ${denomFormatter(
          InitialAmount,
          Denomination
        )} ${Denomination} cannot be issued because your maximum securable ${Denomination} balance is ${denomFormatter(
          secureableData.securableAmountInDenom,
          Denomination
        )} ${Denomination}`,
      };
    }
  }

  try {
    // Create the credex
    const createCredexQuery = await ledgerSpaceSession.run(
      `
        MATCH (daynode:Daynode {Active: true})
        MATCH (issuer:Account {accountID: $issuerAccountID})
        MATCH (receiver:Account {accountID: $receiverAccountID})
        CREATE (newCredex:Credex)
        SET
          newCredex.credexID = randomUUID(),
          newCredex.Denomination = $Denomination,
          newCredex.CXXmultiplier = daynode[$Denomination],
          newCredex.InitialAmount = $InitialAmount * daynode[$Denomination],
          newCredex.OutstandingAmount = $InitialAmount * daynode[$Denomination],
          newCredex.RedeemedAmount = 0,
          newCredex.DefaultedAmount = 0,
          newCredex.WrittenOffAmount = 0,
          newCredex.credexType = $credexType,
          newCredex.createdAt = datetime(),
          newCredex.queueStatus = "PENDING_CREDEX"
        MERGE (newCredex)-[:CREATED_ON]->(daynode)
        MERGE (issuer)-[:${OFFERSorREQUESTS}]->(newCredex)-[:${OFFERSorREQUESTS}]->(receiver)
        MERGE (issuer)-[:${OFFEREDorREQUESTED}]->(newCredex)-[:${OFFEREDorREQUESTED}]->(receiver)
        RETURN
          newCredex.credexID AS credexID,
          receiver.accountName AS receiverAccountName
      `,
      {
        issuerAccountID,
        receiverAccountID,
        InitialAmount,
        Denomination,
        credexType,
      }
    );

    const credexID = createCredexQuery.records[0].get("credexID");

    // Add dueDate for unsecured credex
    if (!securedCredex) {
      const addDueDateQuery = await ledgerSpaceSession.run(
        `
          MATCH (newCredex:Credex {credexID: $credexID})
          SET newCredex.dueDate = date($dueDate)
          RETURN newCredex.dueDate AS dueDate
        `,
        {
          credexID,
          dueDate,
        }
      );
      if (addDueDateQuery.records.length === 0) {
        return { credex: false, message: "error creating credex" };
      }
    }

    // Add secured relationships for secured credex
    if (securedCredex && secureableData.securerID) {
      await ledgerSpaceSession.run(
        `
          MATCH (newCredex:Credex {credexID: $credexID})
          MATCH (securingAccount: Account {accountID: $securingAccountID})
          MERGE (securingAccount)-[:SECURES]->(newCredex)
        `,
        {
          credexID,
          securingAccountID: secureableData.securerID,
        }
      );
    }

    const newCredex = {
      credexID: createCredexQuery.records[0].get("credexID"),
      formattedInitialAmount: denomFormatter(InitialAmount, Denomination),
      counterpartyAccountName: createCredexQuery.records[0].get(
        "receiverAccountName"
      ),
      secured: securedCredex,
      dueDate: dueDate,
    };

    return {
      credex: newCredex,
      message: "Credex created: " + newCredex.credexID,
    };
  } catch (error) {
    return { credex: false, message: "Error creating credex: " + error };
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/GetSecuredAuthorization.ts
----------------------------------------
/*
returns information on a account's secured balance

required inputs:
  issuerAccountID,
  Denomination,

returns:
  securerID (null if no secured balances available or error)
  securableAmountInDenom (0 if no secured balances or error, infinity if CREDEX_FOUNDATION_AUDITED)
    
*/

import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function GetSecuredAuthorizationService(
  issuerAccountID: string,
  Denomination: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  // Check if issuer is CREDEX_FOUNDATION_AUDITED
  const isFoundationAuditedQuery = await ledgerSpaceSession.run(
    `
      OPTIONAL MATCH
        (issuer:Account { accountID: $issuerAccountID })
        <-[:CREDEX_FOUNDATION_AUDITED]-
        (credexFoundation:Account { accountType: "CREDEX_FOUNDATION" })
      RETURN issuer IS NOT NULL AS isAudited
    `,
    { issuerAccountID }
  );

  const record = isFoundationAuditedQuery.records[0];
  const isAudited = record ? record.get("isAudited") : false;

  // If the issuer is CREDEX_FOUNDATION_AUDITED, authorize for unlimited secured credex issuance
  if (isAudited) {
    await ledgerSpaceSession.close();
    return {
      securerID: issuerAccountID,
      securableAmountInDenom: Infinity,
    };
  }

  // If issuer is not CREDEX_FOUNDATION_AUDITED, verify the available secured balance in denom
  const getSecurableDataQuery = await ledgerSpaceSession.run(
    `
      MATCH (account:Account {accountID: $accountID})
      OPTIONAL MATCH (account)-[transactionType:OWES|OFFERS]-(credex:Credex)<-[:SECURES]-(securer:Account)
      WHERE credex.Denomination = $Denomination
      WITH
        securer.accountID AS securingAccountID,
        SUM(CASE WHEN endNode(transactionType) = account THEN credex.OutstandingAmount ELSE 0 END) -
        SUM(CASE WHEN startNode(transactionType) = account THEN credex.OutstandingAmount ELSE 0 END)
        AS netSecurablePerSecurerCXX
      MATCH (daynode:Daynode {Active: true})
      RETURN
        securingAccountID,
        netSecurablePerSecurerCXX / daynode[$Denomination] AS netSecurableInDenom
        ORDER BY netSecurableInDenom DESC
        LIMIT 1
    `,
    {
      accountID: issuerAccountID,
      Denomination: Denomination,
    }
  );

  await ledgerSpaceSession.close();

  const securableRecord = getSecurableDataQuery.records[0];
  if (!securableRecord || securableRecord.length === 0) {
    return {
      securerID: null,
      securableAmountInDenom: 0,
    };
  }
    console.log({
      securerID: securableRecord.get("securingAccountID"),
      securableAmountInDenom: securableRecord.get("netSecurableInDenom"),
    });

  return {
    securerID: securableRecord.get("securingAccountID"),
    securableAmountInDenom: securableRecord.get("netSecurableInDenom"),
  };
}



File: ./src/Credex/services/GetCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";
import moment from "moment-timezone";

export async function GetCredexService(credexID: string, accountID: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH
        (account:Account {accountID: $accountID})-[transactionType:OWES|CLEARED|REQUESTS|OFFERS|DECLINED|CANCELLED]-(credex:Credex {credexID: $credexID})-[:OWES|CLEARED|REQUESTS|OFFERS|DECLINED|CANCELLED]-(counterparty:Account)
        OPTIONAL MATCH (credex)<-[:SECURES]-(securer:Account)
        OPTIONAL MATCH (credex)-[credloopRel:CREDLOOP]-(clearedAgainstCredex:Credex)-[:OWES|CLEARED]-(account), (clearedAgainstCredex)-[:OWES|CLEARED]-(clearedAgainstCounterparty:Account)
        RETURN
        credex.credexID AS credexID,
        type(transactionType) AS transactionType,
        (startNode(transactionType) = account) AS debit,
        counterparty.accountName AS counterpartyAccountName,
        securer.accountID AS securerID,
        securer.accountName AS securerName,
        credex.Denomination AS Denomination,
        credex.InitialAmount / credex.CXXmultiplier AS InitialAmount,
        credex.OutstandingAmount / credex.CXXmultiplier AS OutstandingAmount,
        credex.RedeemedAmount / credex.CXXmultiplier AS RedeemedAmount,
        credex.DefaultedAmount / credex.CXXmultiplier AS DefaultedAmount,
        credex.WrittenOffAmount / credex.CXXmultiplier AS WrittenOffAmount,
        credex.acceptedAt AS acceptedAt,
        credex.declinedAt AS declinedAt,
        credex.cancelledAt AS cancelledAt,
        credex.dueDate AS dueDate,
        clearedAgainstCredex.credexID AS clearedAgainstCredexID,
        credloopRel.AmountRedeemed / credloopRel.CXXmultiplier AS clearedAmount,
        clearedAgainstCredex.InitialAmount / clearedAgainstCredex.CXXmultiplier AS clearedAgainstCredexInitialAmount,
        clearedAgainstCredex.Denomination AS clearedAgainstCredexDenomination,
        clearedAgainstCounterparty.accountName AS clearedAgainstCounterpartyAccountName
      `,
      { credexID, accountID }
    );

    if (result.records.length === 0) {
      throw new Error("No records found");
    }

    const record = result.records[0];
    const debit = record.get("debit");

    type Amounts = {
      InitialAmount: number;
      OutstandingAmount: number;
      RedeemedAmount: number;
      DefaultedAmount: number;
      WrittenOffAmount: number;
    };

    const amounts: Amounts = [
      "InitialAmount",
      "OutstandingAmount",
      "RedeemedAmount",
      "DefaultedAmount",
      "WrittenOffAmount",
    ].reduce(
      (acc: Amounts, amount: string) => {
        const value = parseFloat(record.get(amount));
        acc[amount as keyof Amounts] = debit ? -value : value;
        return acc;
      },
      {
        InitialAmount: 0,
        OutstandingAmount: 0,
        RedeemedAmount: 0,
        DefaultedAmount: 0,
        WrittenOffAmount: 0,
      }
    );

    const Denomination = record.get("Denomination");
    const formattedAmounts = (
      Object.entries(amounts) as [keyof Amounts, number][]
    ).reduce((acc, [key, value]) => {
      acc[`formatted${key}`] = `${denomFormatter(
        value,
        Denomination
      )} ${Denomination}`;
      return acc;
    }, {} as Record<string, string>);

    const acceptedAt = moment(record.get("acceptedAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const declinedAt = moment(record.get("declinedAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const cancelledAt = moment(record.get("cancelledAt"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const dueDate = moment(record.get("dueDate"))
      .subtract(1, "month")
      .format("YYYY-MM-DD");
    const counterpartyAccountName = record.get("counterpartyAccountName")

    const credexData = {
      credexID: record.get("credexID"),
      transactionType: record.get("transactionType"),
      debit,
      counterpartyAccountName,
      securerID: record.get("securerID"),
      securerName: record.get("securerName"),
      Denomination,
      acceptedAt: acceptedAt,
      declinedAt: declinedAt,
      cancelledAt: cancelledAt,
      dueDate: dueDate,
      ...formattedAmounts,
    };

    const clearedAgainstData = result.records
      .filter((record) => record.get("clearedAgainstCredexID"))
      .map((record) => {
        const clearedAmount = record.get("clearedAmount");
        const clearedAgainstCredexInitialAmount = parseFloat(
          record.get("clearedAgainstCredexInitialAmount")
        );
        const signumClearedAgainstCredexInitialAmount = debit
          ? clearedAgainstCredexInitialAmount
          : -clearedAgainstCredexInitialAmount;
        const clearedAgainstCredexDenomination = record.get(
          "clearedAgainstCredexDenomination"
        );

        const clearedAgainstCounterpartyAccountName = record.get("clearedAgainstCounterpartyAccountName")

        return {
          clearedAgainstCredexID: record.get("clearedAgainstCredexID"),
          formattedClearedAmount: `${denomFormatter(
            clearedAmount,
            clearedAgainstCredexDenomination
          )} ${clearedAgainstCredexDenomination}`,
          formattedClearedAgainstCredexInitialAmount: `${denomFormatter(
            signumClearedAgainstCredexInitialAmount,
            clearedAgainstCredexDenomination
          )} ${clearedAgainstCredexDenomination}`,
          clearedAgainstCounterpartyAccountName,
        };
      });

    return { credexData, clearedAgainstData };
  } catch (error) {
    console.error("Error in GetCredexService:", error);
    throw error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/DeclineCredex.ts
----------------------------------------
/*
marks a credex as declined by changing the relationships
from OFFERS or REQUESTS to DECLINED

required inputs:
  credexID

on success returns credexID

will return false if:
  credexID not found
  credex does not have OFFERS or REQUESTS relationships (credex already accepted/declined/cancelled)
    
*/

import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function DeclineCredexService(credexID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        MATCH (issuer:Account)-[rel1:OFFERS|REQUESTS]->(credex:Credex{credexID:$credexID})-[rel2:OFFERS|REQUESTS]->(acceptor:Account)
        DELETE rel1, rel2
        CREATE (issuer)-[:DECLINED]->(credex)-[:DECLINED]->(acceptor)
        WITH credex
        SET
            credex.declinedAt = Datetime(),
            credex.OutstandingAmount = 0,
            credex.queueStatus = "PROCESSED"
        RETURN credex.credexID AS credexID
    `,
      { credexID }
    );
    await ledgerSpaceSession.close();

    if (result.records.length === 0) {
      console.log(
        `No records found or credex no longer pending for credexID: ${credexID}`
      );
      return false;
    }

    const declinedCredexID = result.records[0].get("credexID");
    console.log(`Offer declined for credexID: ${declinedCredexID}`);
    return declinedCredexID;
  } catch (error) {
    console.log(error);
  }
}



File: ./src/Credex/services/GetLedger.ts
----------------------------------------
/*

returns details to display a ledger list of transactions

requires:
  accountID

requires (with defaults if not included)
  numRows (number of transactions to return, default is 10)
  startRow (number of row to start at, for pagination, default is first row)

returns for each credex:
  credexID
  formattedInitialAmount (string eg 8,546.32 USD)
  counterpartyDisplayname

returns empty array if no credexes

returns error message if numRows or startRows can't be coerced into numbers
returns empty array if accountID not valid

*/

import * as neo4j from "neo4j-driver";
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";

export async function GetLedgerService(
  accountID: string,
  numRows: number = 10,
  startRow: number = 0
) {
  numRows = Math.round(Number(numRows));
  startRow = Math.round(Number(startRow));

  if (Number.isNaN(numRows) || Number.isNaN(startRow)) {
    return "numRows and startRows must be numbers";
  }

  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
            (account:Account{accountID:$accountID})-[transactionType:OWES|CLEARED]-(credex:Credex)-[:OWES|CLEARED]-(counterparty:Account)
        OPTIONAL MATCH (credex)<-[:SECURES]-(securer:Account)
        RETURN
            credex.credexID AS credexID,
            credex.InitialAmount/credex.CXXmultiplier AS InitialAmount,
            credex.Denomination AS Denomination,
            (startNode(transactionType) = account) as debit,
            counterparty.accountName AS counterpartyAccountName
            ORDER BY credex.acceptedAt
            SKIP $startRow
            LIMIT $numRows
    `,
      {
        accountID: accountID,
        numRows: neo4j.int(numRows),
        startRow: neo4j.int(startRow),
      }
    );

    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const credexes = result.records.map((record) => {
      const credexID = record.get("credexID");
      const InitialAmount = record.get("debit")
        ? -parseFloat(record.get("InitialAmount"))
        : record.get("InitialAmount");
      const Denomination = record.get("Denomination");
      const counterpartyAccountName = record.get("counterpartyAccountName");

      const formattedInitialAmount =
        denomFormatter(InitialAmount, Denomination) + " " + Denomination;

      return {
        credexID,
        formattedInitialAmount,
        counterpartyAccountName,
      };
    });

    return credexes;
  } catch (error) {
    console.error("Error in GetLedgerService:", error);
    throw error;
  }
}



File: ./src/Credex/services/AcceptCredex.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function AcceptCredexService(credexID: string, signerID: string) {
  if (!credexID) {
    console.log("credexID required");
    return false;
  }
  if (!signerID) {
    console.log("signerID required");
    return false;
  }
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH
          (issuer:Account)-[rel1:OFFERS]->
          (acceptedCredex:Credex {credexID: $credexID})-[rel2:OFFERS]->
          (acceptor:Account)<-[:AUTHORIZED_FOR]-
          (signer:Member|Avatar { memberID: $signerID })
        DELETE rel1, rel2
        CREATE (issuer)-[:OWES]->(acceptedCredex)-[:OWES]->(acceptor)
        CREATE (acceptedCredex)<-[:SIGNED]-(signer)
        SET acceptedCredex.acceptedAt = datetime()
        RETURN
          acceptedCredex.credexID AS credexID,
          acceptor.accountID AS acceptorAccountID,
          signer.memberID AS signerID
      `,
      { credexID, signerID }
    );

    if (result.records.length === 0) {
      console.log(
        `No records found or credex no longer pending for credexID: ${credexID}`
      );
      return false;
    }

    //hit credex accepted notification endpoint

    const acceptedCredexID = result.records[0].get("credexID");
    const acceptorAccountID = result.records[0].get("acceptorAccountID");
    const acceptorSignerID = result.records[0].get("signerID");

    console.log(`Offer accepted for credexID: ${acceptedCredexID}`);
    return {
      acceptedCredexID: acceptedCredexID,
      acceptorAccountID: acceptorAccountID,
      acceptorSignerID: acceptorSignerID,
    };
  } catch (error) {
    console.error(`Error accepting credex for credexID ${credexID}:`, error);
    throw error; // Optionally rethrow to allow further handling upstream
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/CancelCredex.ts
----------------------------------------
/*
marks a credex as cancelled by changing the relationships
from OFFERS or REQUESTS to CANCELLED

required inputs:
  credexID

on success returns credexID

will return false if:
  credexID not found
  credex does not have OFFERS or REQUESTS relationships (credex already accepted/declined/cancelled)
    
*/

import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function CancelCredexService(credexID: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();
  try {
    const result = await ledgerSpaceSession.run(
      `
        MATCH (issuer:Account)-[rel1:OFFERS|REQUESTS]->(credex:Credex {credexID: $credexID})-[rel2:OFFERS|REQUESTS]->(acceptor:Account)
        DELETE rel1, rel2
        CREATE (issuer)-[:CANCELLED]->(credex)-[:CANCELLED]->(acceptor)
        SET
          credex.cancelledAt = datetime(),
          credex.OutstandingAmount = 0,
          credex.queueStatus = "PROCESSED"
        RETURN credex.credexID AS credexID
      `,
      { credexID }
    );

    if (result.records.length === 0) {
      console.log(
        `No records found or credex no longer pending for credexID: ${credexID}`
      );
      return false;
    }

    const cancelledCredexID = result.records[0].get("credexID");
    console.log(`Offer declined for credexID: ${cancelledCredexID}`);
    return cancelledCredexID;
  } catch (error) {
    console.error(`Error cancelling credex for credexID ${credexID}:`, error);
    throw error; // Optionally rethrow to allow further handling upstream
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Credex/services/GetPendingOffersOut.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";
import moment from "moment-timezone";

interface OfferedCredex {
  credexID: string;
  formattedInitialAmount: string;
  counterpartyAccountName: string;
  dueDate?: string; // optional field
  secured?: boolean; // optional field
}

export async function GetPendingOffersOutService(accountID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
          (account:Account{accountID:$accountID})-[:OFFERS]->(offersOutCredex:Credex)-[:OFFERS]->(counterparty:Account)
        OPTIONAL MATCH
          (offersOutCredex)<-[:SECURES]-(securer:Account)
        RETURN
          offersOutCredex.InitialAmount / offersOutCredex.CXXmultiplier AS InitialAmount,
          offersOutCredex.credexID AS credexID,
          offersOutCredex.Denomination AS Denomination,
          offersOutCredex.dueDate AS dueDate,
          counterparty.accountName AS counterpartyAccountName,
          securer IS NOT NULL as secured
      `,
      { accountID }
    );
    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const offeredCredexData = [];
    for (const record of result.records) {
      const formattedInitialAmount =
        denomFormatter(
          parseFloat("-" + record.get("InitialAmount")),
          record.get("Denomination")
        ) +
        " " +
        record.get("Denomination");

      const thisOfferedCredex: OfferedCredex = {
        credexID: record.get("credexID"),
        formattedInitialAmount: formattedInitialAmount,
        counterpartyAccountName: record.get("counterpartyAccountName"),
      };
      if (record.get("dueDate")) {
        thisOfferedCredex.dueDate = moment(record.get("dueDate"))
          .subtract(1, "months") //because moment uses Jan = 0 and neo4j uses Jan = 1
          .format("YYYY-MM-DD");
      }
      if (record.get("secured")) {
        thisOfferedCredex.secured = record.get("secured");
      }
      offeredCredexData.push(thisOfferedCredex);
    }

    return offeredCredexData;
  } catch (error) {
    console.error("Error in GetPendingOffersOutService:", error);
    throw error;
  }
}



File: ./src/Credex/services/GetPendingOffersIn.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import { denomFormatter } from "../../Core/constants/denominations";
import moment from "moment-timezone";

interface OfferedCredex {
  credexID: string;
  formattedInitialAmount: string;
  counterpartyAccountName: string;
  dueDate?: string; // optional field
  secured?: boolean; // optional field
}

export async function GetPendingOffersInService(accountID: string) {
  try {
    const ledgerSpaceSession = ledgerSpaceDriver.session();
    const result = await ledgerSpaceSession.run(
      `
        OPTIONAL MATCH
          (account:Account{accountID:$accountID})<-[:OFFERS]-(offersInCredex:Credex)<-[:OFFERS]-(counterparty:Account)
        OPTIONAL MATCH
          (offersInCredex)<-[:SECURES]-(securer:Account)
        RETURN
          offersInCredex.InitialAmount / offersInCredex.CXXmultiplier AS InitialAmount,
          offersInCredex.credexID AS credexID,
          offersInCredex.Denomination AS Denomination,
          offersInCredex.dueDate AS dueDate,
          counterparty.accountName AS counterpartyAccountName,
          securer IS NOT NULL as secured
      `,
      { accountID }
    );
    await ledgerSpaceSession.close();

    if (!result.records[0].get("credexID")) {
      return {};
    }

    const offeredCredexData = [];
    for (const record of result.records) {
      const formattedInitialAmount =
        denomFormatter(
          record.get("InitialAmount"),
          record.get("Denomination")
        ) +
        " " +
        record.get("Denomination");

      const thisOfferedCredex: OfferedCredex = {
        credexID: record.get("credexID"),
        formattedInitialAmount: formattedInitialAmount,
        counterpartyAccountName: record.get("counterpartyAccountName"),
      };
      if (record.get("dueDate")) {
        thisOfferedCredex.dueDate = moment(record.get("dueDate"))
          .subtract(1, "months") //because moment uses Jan = 0 and neo4j uses Jan = 1
          .format("YYYY-MM-DD");
      }
      if (record.get("secured")) {
        thisOfferedCredex.secured = record.get("secured");
      }
      offeredCredexData.push(thisOfferedCredex);
    }

    return offeredCredexData;
  } catch (error) {
    console.error("Error in GetPendingOffersInService:", error);
    throw error;
  }
}



File: ./src/index.ts
----------------------------------------
import express from "express";
import MemberRoutes from "./Member/memberRoutes";
import AccountRoutes from "./Account/accountRoutes";
import CredexRoutes from "./Credex/credexRoutes";
import DevAdminRoutes from "./DevAdmin/devAdminRoutes";
import RecurringRoutes from "./Avatar/recurringRoutes";
import { Logger } from "../config/logger";
import bodyParser from "body-parser";
import startCronJobs from "./Core/cronJobs";
import authenticate from "../config/authenticate";
import helmet from "helmet";
import cors from "cors";
import rateLimit from "express-rate-limit";

const app = express();
const port = 5000;

const jsonParser = bodyParser.json();

export const apiVersionOneRoute = "/api/v1/";

app.use(helmet());
app.use(cors());
app.use(Logger);
app.use(apiVersionOneRoute, authenticate);

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
});
app.use(limiter);

startCronJobs();
MemberRoutes(app, jsonParser);
AccountRoutes(app, jsonParser);
CredexRoutes(app, jsonParser);
RecurringRoutes(app, jsonParser);

if (process.env.DEPLOYMENT === "demo") {
  DevAdminRoutes(app, jsonParser);
}

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});



File: ./src/Avatar/recurringRoutes.ts
----------------------------------------
import express from "express";
import { apiVersionOneRoute } from "..";
import { RequestRecurringController } from "./controllers/requestRecurring";
import { AcceptRecurringController } from "./controllers/acceptRecurring";
import { DeclineRecurringController } from "./controllers/cancelRecurring";

export default function RecurringRoutes(
  app: express.Application,
  jsonParser: any
) {
  app.post(
    `${apiVersionOneRoute}requestRecurring`,
    jsonParser,
    RequestRecurringController
  );

  app.put(
    `${apiVersionOneRoute}acceptRecurring`,
    jsonParser,
    AcceptRecurringController
  );

  app.put(
    `${apiVersionOneRoute}cancelRecurring`,
    jsonParser,
    DeclineRecurringController
  );
}



File: ./src/Avatar/controllers/acceptRecurring.ts
----------------------------------------
import express from "express";
import { AcceptRecurringService } from "../services/AcceptRecurring";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";

/**
 * AcceptRecurringController
 * 
 * This controller handles the acceptance of recurring transactions.
 * It validates the required fields, calls the AcceptRecurringService,
 * and returns the result along with updated dashboard data.
 * 
 * @param req - Express request object
 * @param res - Express response object
 */
export async function AcceptRecurringController(
  req: express.Request,
  res: express.Response
) {
  // Validate required fields
  const fieldsRequired = ["avatarID", "signerID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    // Call AcceptRecurringService to process the acceptance
    const acceptRecurringData = await AcceptRecurringService(
      req.body.avatarID,
      req.body.signerID
    );

    // Check if the service call was successful
    if (!acceptRecurringData) {
      return res.status(400).json(acceptRecurringData);
    }

    // Handle errors in recurring transaction creation
    if (typeof acceptRecurringData.recurring == "boolean") {
      throw new Error("Recurring transaction could not be created");
    }

    // If acceptorAccountID exists and is a string, fetch dashboard data
    if (
      acceptRecurringData.recurring.acceptorAccountID &&
      typeof acceptRecurringData.recurring.acceptorAccountID === "string"
    ) {
      const dashboardData = await GetAccountDashboardService(
        req.body.signerID,
        acceptRecurringData.recurring.acceptorAccountID
      );

      // Return the acceptance data and dashboard data
      res.json({
        acceptRecurringData: acceptRecurringData,
        dashboardData: dashboardData,
      });
    } else {
      throw new Error("credexFoundation could not be created");
    }
  } catch (err) {
    console.error("Error in AcceptRecurringController:", err);
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Avatar/controllers/requestRecurring.ts
----------------------------------------
import express from "express";
import { RequestRecurringService } from "../services/RequestRecurring";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";
import { getDenominations } from "../../Core/constants/denominations";

export async function RequestRecurringController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = [
    "signerMemberID",
    "requestorAccountID",
    "counterpartyAccountID",
    "InitialAmount",
    "Denomination",
    "nextPayDate",
    "daysBetweenPays",
  ];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  // Check denomination validity
  if (!getDenominations({ code: req.body.Denomination }).length) {
    const message = "Error: denomination not permitted";
    console.log(message);
    return { recurring: false, message };
  }

  // Validate optional parameters
  if (req.body.securedCredex !== undefined && typeof req.body.securedCredex !== 'boolean') {
    return res.status(400).json({ message: "securedCredex must be a boolean" });
  }

  if (req.body.credspan !== undefined) {
    const credspan = Number(req.body.credspan);
    if (isNaN(credspan) || credspan < 7 || credspan > 35) {
      return res.status(400).json({ message: "credspan must be a number between 7 and 35" });
    }
  }

  if (req.body.remainingPays !== undefined) {
    const remainingPays = Number(req.body.remainingPays);
    if (isNaN(remainingPays) || remainingPays < 0) {
      return res.status(400).json({ message: "remainingPays must be a positive number" });
    }
  }

  // Check securedCredex and credspan relationship
  if (req.body.securedCredex === true && req.body.credspan !== undefined) {
    return res.status(400).json({ message: "credspan must be null when securedCredex is true" });
  }

  if (req.body.securedCredex !== true && req.body.credspan === undefined) {
    return res.status(400).json({ message: "credspan must be provided when securedCredex is not true" });
  }

  try {
    const createRecurringData = await RequestRecurringService(
      req.body.signerMemberID,
      req.body.requestorAccountID,
      req.body.counterpartyAccountID,
      req.body.InitialAmount,
      req.body.Denomination,
      req.body.nextPayDate,
      req.body.daysBetweenPays,
      req.body.securedCredex,
      req.body.credspan,
      req.body.remainingPays,
    );

    if (!createRecurringData) {
      return res.status(400).json(createRecurringData);
    }

    const dashboardData = await GetAccountDashboardService(
      req.body.signerMemberID,
      req.body.requestorAccountID
    );

    res.json({
      avatarMemberID: createRecurringData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in RequestRecurringController:", err);
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Avatar/controllers/cancelRecurring.ts
----------------------------------------
import express from "express";
import { CancelRecurringService } from "../services/CancelRecurring";
import { GetAccountDashboardService } from "../../Account/services/GetAccountDashboard";
//comment here
export async function DeclineRecurringController(
  req: express.Request,
  res: express.Response
) {
  const fieldsRequired = ["signerID", "cancelerAccountID", "avatarID"];
  for (const field of fieldsRequired) {
    if (!req.body[field]) {
      return res
        .status(400)
        .json({ message: `${field} is required` })
        .send();
    }
  }

  try {
    const cancelRecurringData = await CancelRecurringService(
      req.body.signerID,
      req.body.cancelerAccountID,
      req.body.avatarID
    );

    if (!cancelRecurringData) {
      return res.status(400).json(cancelRecurringData);
    }

    const dashboardData = await GetAccountDashboardService(
      req.body.signerID,
      req.body.cancelerAccountID
    );

    res.json({
      cancelRecurringData: cancelRecurringData,
      dashboardData: dashboardData,
    });
  } catch (err) {
    console.error("Error in DeclineRecurringController:", err);
    res.status(500).json({ error: (err as Error).message });
  }
}



File: ./src/Avatar/services/AcceptRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

/**
 * AcceptRecurringService
 * 
 * This service handles the acceptance of a recurring transaction.
 * It updates the database to reflect the acceptance of the recurring avatar.
 * 
 * @param avatarID - The ID of the recurring avatar to be accepted
 * @param signerID - The ID of the member signing (accepting) the recurring transaction
 * @returns An object containing the result of the acceptance operation
 */
export async function AcceptRecurringService(avatarID: string, signerID: string) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Execute Cypher query to validate and update the Recurring avatar
    const acceptRecurringQuery = await ledgerSpaceSession.run(
      `
      MATCH
        (signer:Member { memberID: $signerID })-[:AUTHORIZED_FOR]->
        (acceptor:Account)-[rel1:REQUESTS]->
        (recurring:Avatar { memberID: $avatarID })-[rel2:REQUESTS]->
        (requestor:Account)
      CREATE (signer)-[:SIGNED]->(recurring)
      CREATE (acceptor)<-[:AUTHORIZED_FOR]-(recurring)
      CREATE (acceptor)-[:ACTIVE]->(recurring)-[:ACTIVE]->(requestor)
      DELETE rel1, rel2
      RETURN
        recurring.memberID AS avatarID,
        acceptor.accountID AS acceptorAccountID,
        signer.memberID AS signerID
      `,
      {
        avatarID,
        signerID,
      }
    );

    // Check if the query returned any records
    if (acceptRecurringQuery.records.length === 0) {
      console.log(
        `No records found or recurring transaction no longer pending for avatarID: ${avatarID}`
      );
      return {
        recurring: false,
        message:
          "No records found or recurring transaction no longer pending for avatarID: " + avatarID,
      };
    }

    // TODO: Implement notification for credex acceptance

    // Extract relevant data from the query result
    const acceptedRecurringID = acceptRecurringQuery.records[0].get("avatarID");
    const acceptorAccountID =
      acceptRecurringQuery.records[0].get("acceptorAccountID");
    const acceptorSignerID = acceptRecurringQuery.records[0].get("signerID");

    console.log(`Recurring request accepted for avatarID: ${acceptedRecurringID}`);
    
    // Return the result of the acceptance operation
    return {
      recurring: {
        acceptedRecurringID: acceptedRecurringID,
        acceptorAccountID: acceptorAccountID,
        acceptorSignerID: acceptorSignerID,
      },
      message: "Recurring template created",
    };

  } catch (error) {
    // Handle any errors that occur during the process
    return {
      recurring: false,
      message: "Error accepting recurring template: " + error,
    };
  } finally {
    // Ensure the database session is closed
    await ledgerSpaceSession.close();
  }
}



File: ./src/Avatar/services/CancelRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";

export async function CancelRecurringService(
  signerID: string,
  cancelerAccountID: string,
  avatarID: string
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    // Validate and update the Recurring node
    const cancelRecurringQuery = await ledgerSpaceSession.run(
      `
      MATCH
        (signer:Member { memberID: $signerID })-[:AUTHORIZED_FOR]->
        (cancelingAccount:Account { accountID: $cancelerAccountID })-[rel1:ACTIVE|REQUESTS]-
        (recurring:Avatar { memberID: $avatarID})-[rel2:ACTIVE|REQUESTS]-
        (counterparty:Account)
      MATCH
        (cancelingAccount)<-[authRel1:AUTHORIZED_FOR]-
        (recurring)-[authRel2:AUTHORIZED_FOR]->
        (counterparty)
      WITH cancelingAccount, recurring, counterparty, rel1, rel2, authRel1, authRel2
      CALL apoc.create.relationship(cancelingAccount, 'CANCELED', {}, recurring) YIELD rel as canceledRel1
      CALL apoc.create.relationship(recurring, 'CANCELED', {}, counterparty) YIELD rel as canceledRel2
      DELETE rel1, rel2, authRel1, authRel2
      RETURN recurring.memberID AS deactivatedAvatarID
      `,
      {
        signerID,
        cancelerAccountID,
        avatarID,
      }
    );

    if (cancelRecurringQuery.records.length === 0) {
      return "Recurring template not found or not authorized to cancel";
    }

    const deactivatedAvatarID = cancelRecurringQuery.records[0].get(
      "deactivatedAvatarID"
    );

    return deactivatedAvatarID;
  } catch (error) {
    return error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./src/Avatar/services/RequestRecurring.ts
----------------------------------------
import { ledgerSpaceDriver } from "../../../config/neo4j";
import * as neo4j from "neo4j-driver";

type RecurringParams = {
  signerMemberID: string;
  requestorAccountID: string;
  counterpartyAccountID: string;
  InitialAmount: number;
  Denomination: string;
  nextPayDate: string;
  daysBetweenPays: neo4j.Integer;
  securedCredex?: boolean;
  credspan?: neo4j.Integer;
  remainingPays?: neo4j.Integer;
};

export async function RequestRecurringService(
  signerMemberID: string,
  requestorAccountID: string,
  counterpartyAccountID: string,
  InitialAmount: number,
  Denomination: string,
  nextPayDate: string,
  daysBetweenPays: number,
  securedCredex?: boolean,
  credspan?: number,
  remainingPays?: number,
) {
  const ledgerSpaceSession = ledgerSpaceDriver.session();

  try {
    let cypher = `
      MATCH
        (requestor:Account {accountID: $requestorAccountID})<-[:AUTHORIZED_FOR]-
        (signer:Member|Avatar { memberID: $signerMemberID })
      MATCH (counterparty:Account {accountID: $counterpartyAccountID})
      MATCH (daynode:Daynode { Active: true })
      CREATE (recurring:Avatar)
      SET
        recurring.avatarType = "RECURRING",
        recurring.memberID = randomUUID(),
        recurring.Denomination = $Denomination,
        recurring.InitialAmount = $InitialAmount,
        recurring.nextPayDate = date($nextPayDate),
        recurring.daysBetweenPays = $daysBetweenPays,
        recurring.createdAt = datetime(),
        recurring.memberTier = 3
    `;

    if (securedCredex !== undefined) {
      cypher += `SET recurring.securedCredex = $securedCredex `;
    }

    if (credspan !== undefined) {
      cypher += `SET recurring.credspan = $credspan `;
    }

    if (remainingPays !== undefined) {
      cypher += `SET recurring.remainingPays = $remainingPays `;
    }

    cypher += `
      CREATE (requestor)<-[:REQUESTS]-(recurring)<-[:REQUESTS]-(counterparty)
      CREATE (requestor)<-[:REQUESTED]-(recurring)<-[:REQUESTED]-(counterparty)
      CREATE (requestor)<-[:AUTHORIZED_FOR]-(recurring)
      CREATE (signer)-[:SIGNED]->(recurring)
      CREATE (recurring)-[:CREATED_ON]->(daynode)
      RETURN
        recurring.memberID AS avatarID
    `;

    const params: RecurringParams = {
      signerMemberID,
      requestorAccountID,
      counterpartyAccountID,
      InitialAmount,
      Denomination,
      nextPayDate,
      daysBetweenPays: neo4j.int(daysBetweenPays),
    };

    if (securedCredex !== undefined) params.securedCredex = securedCredex;
    if (credspan !== undefined) params.credspan = neo4j.int(credspan);
    if (remainingPays !== undefined) params.remainingPays = neo4j.int(remainingPays);

    const createRecurringQuery = await ledgerSpaceSession.run(cypher, params);

    return createRecurringQuery.records[0].get("avatarID");
  } catch (error) {
    return "Error creating recurring avatar: " + error;
  } finally {
    await ledgerSpaceSession.close();
  }
}



File: ./nodemon.json
----------------------------------------
{
  "ignore": [".git", "node_modules", "dist", "build"],
  "watch": ["./src"],
  "exec": "ts-node src/index.ts",
  "ext": "ts"
}



File: ./README.Docker.md
----------------------------------------
### Building and running your application

When you're ready, start your application by running:
`docker compose up --build`.

Your application will be available at http://localhost:5000.

### Deploying your application to the cloud

First, build your image, e.g.: `docker build -t myapp .`.
If your cloud uses a different CPU architecture than your development
machine (e.g., you are on a Mac M1 and your cloud provider is amd64),
you'll want to build the image for that platform, e.g.:
`docker build --platform=linux/amd64 -t myapp .`.

Then, push it to your registry, e.g. `docker push myregistry.com/myapp`.

Consult Docker's [getting started](https://docs.docker.com/go/get-started-sharing/)
docs for more detail on building and pushing.

### References
* [Docker's Node.js guide](https://docs.docker.com/language/nodejs/)


File: ./.github/dependabot.yml
----------------------------------------
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for more information:
# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates
# https://containers.dev/guide/dependabot

version: 2
updates:
  - package-ecosystem: "devcontainers"
    directory: "/"
    schedule:
      interval: weekly



File: ./.github/workflows/stage.yml
----------------------------------------
# Documentation https://github.com/appleboy/ssh-action
name: Credex Staging Deployment
on:
  push:
    branches: [stage]

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Executing remote ssh commands using key
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DEMO_SERVER_HOST }}
          username: ${{ secrets.DEMO_SERVER_USER }}
          password: ${{ secrets.DEMO_SERVER_SSH_PASSWORD }}
          port: ${{ secrets.SSH_PORT }}
          command_timeout: 25m
          script: |
            cd credex-core
            git checkout stage
            git pull
            docker compose up --build -d

  post:
    name: Slack Notification Sender
    runs-on: ubuntu-latest
    steps:
      - name: Send custom JSON data to Slack workflow
        id: slack
        uses: slackapi/slack-github-action@v1.23.0
        with:
          # This data can be any valid JSON from a previous step in the GitHub Action
          payload: |
            {
              "text": "${{ github.actor }} created commit.",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": ":desktop_computer:  ${{ github.actor }} created commit:  :desktop_computer:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": " :left_speech_bubble: *Commit Details* :left_speech_bubble:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Commit message: ${{ github.event.commits[0].message }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Repository: ${{ github.repository }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "GitHub Action build result: ${{ job.status }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "See changes: ${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
                  }
                },
                {
                  "type": "divider"
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK



File: ./.github/workflows/prod.yml
----------------------------------------
name: deploy_to_prod
run-name: ${{ github.actor }} pushed to prod_auto_deploy_setup with commit message '${{ github.event.head_commit.message }}'

on:
  push:
    branches:
      - prod

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: "18"

      - name: Install dependencies
        run: npm install
        working-directory: .

      - name: Set up SSH deploy keys
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Set ownership on remote server
        run: |
          echo "${{ secrets.SSH_KEY }}" > private_key.pem
          chmod 600 private_key.pem

          # Create known_hosts file if it doesn't exist
          mkdir -p /home/runner/.ssh
          touch /home/runner/.ssh/known_hosts
          # Clear old key from known_hosts
          ssh-keygen -R ${{ secrets.EC2_IP }} >> /home/runner/.ssh/known_hosts
          ssh-keyscan -H ${{ secrets.EC2_IP }} >> /home/runner/.ssh/known_hosts

          # Run the SSH command
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@${{ secrets.EC2_IP }} \
          "cd credex-core &&
            git checkout prod &&
            docker-compose up --build"
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_KEY }}



File: ./tsconfig.json
----------------------------------------
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./build"
  },
  "include": ["src/**/*.ts", "config/authenticate.ts"],
  "exclude": ["node_modules"]
}



File: ./.devcontainer/devcontainer.json
----------------------------------------
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/typescript-node
{
  "name": "Node.js & TypeScript",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/typescript-node:1-22-bookworm",
  "customizations": {
    "vscode": {
      "extensions": [
        "esbenp.prettier-vscode",
        "Postman.postman-for-vscode",
        "saoudrizwan.claude-dev"
      ]
    }
  },
  // Features to add to the dev container. More info: https://containers.dev/features.
  "features": {
    "node": {
      "version": "18",
      "nodeGypDependencies": true
    }
  },
  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],

  // Use 'postCreateCommand' to run commands after the container is created.
  "postCreateCommand": [
    "/bin/sh",
    "-c",
    "npm install && npm install -g nodemon"
  ]

  // Configure tool-specific properties.
  // "customizations": {},

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}



File: ./README.md
----------------------------------------
# Credex Ecosystem Core API

The codebase in this credex-core repository actualizes two principles:

## Credex Principle

**If I owe you,**\
**and you owe them,**\
**and they owe me,**\
**we're square.**

## Credcoin Principle

**Every human is entitled to one equal share of the value of the natural wealth entering the organic economy.**\
**Every human is responsible to provide value equal to the amount of natural wealth that they consume.**

# Overview

The credex ecosystem actualizes the Credex Principle in the Minute Transaction Queue (MTQ), which tracks payable and receivable invoices for members' accounts, finds loops of value creation, and cancels payable and receivable invoices against each other in "credloops" in which every debt is reduced by an equal value. This is a GAAP-compliant accounting process that any person and any business can benefit from.

The ecosystem actualizes the Credcoin Principle in the Daily Credcoin Offering (DCO), which updates exchange rates across the ecosystem daily. Every 24h, the DCO makes this equation true: one credcoin today equals the number of members participating in the DCO today divided by the value of natural wealth entering the organic economy through the DCO today.

The organic economy is a subset of the credex ecosystem, which is a subset of the global economy, which is the human-enhanced subset of the world that is given to us by nature. The organic economy is an economy in which wealth circulates, profit accumulates, investment is made, and gifts are given in alignment and long-term harmony with the biological environment of our habitat and the physical laws that bind us.

The value of the natural wealth processed by the DCO is split into two portions: gift portion and market portion. Currently, in the mvp version we've developed in this repository, only the gift portion of the DCO is implemented. The market portion will be added later.

The credex ecosystem stores values in credcoin (CXX). In order to natively enable multi-denominational accounting, a CXXmultiplier value is stored alongside every CXX value. Both of these values are updated in every DCO so that the credex remains true to the face value in the denomination specified, and to other values stored in the ecosystem. A value expressed in CXX represents that value in relationship to every other value stored in the ecosystem. A value in CXX divided by its CXX multiplier expresses the value in the chosen denomination (face value).

The system manages the balance between local truth (preserving the face value of contracts in their specified denomination) and global truth (adjusting all values relative to credcoin) through the daily rate and value adjustments in the DCO. This implementation creates a robust ecosystem that manages accounting processes across any denomination, clears debts automatically, and adjusts values dynamically.

## express.js server

The express.js server is initialized with index.ts, which provides the cronjobs and endpoints that power the ecosystem and enable members and client apps to interact with its ledger.

## cronjobs

The Core module hosts the cronjobs.

DailyCredcoinOffering() runs every day at midnight UTC. First, DBinitialization() is run if there is no active daynode in the database. DCOexecute() then runs the Daily Credcoin Offering.

MinuteTransactionQueue() runs every minute, clearing credloops of value creation across the ecosystem.

## endpoints

Controllers for the endpoints are imported, and endpoints created for the various modules: Member, Account, Avatar, Admin, and DevAdmin.

# Daily Credcoin Offering (DCO)

Runs every 24h at midnight UTC, while most of the world's population centres are in darkness.

## DBinitialize.ts

The DBinitialization file sets up the initial state of the database for the Credex ecosystem.

1. Sets up database constraints and indexes for various entities (Daynode, Member, Account).
2. Establishes "day zero" and initializes exchange rates for various currencies against CXX (Credcoin).
3. Creates an initial "daynode" with the day zero exchange rates.
4. Creates an initial member (Ryan Watson) and updates their member tier.
5. Creates several initial accounts:
   - Ryan Watson's personal account
   - Credex Foundation account
   - Great Sun Financial (business account)
   - VimbisoPay (business account)
6. Establishes relationships between these accounts, particularly marking some as "CREDEX_FOUNDATION_AUDITED" to determine which accounts can originally issue secured credexes.
7. Creates an initial Credex transaction to fund the DCO for a year.

This initialization process sets up the basic structure and relationships needed for the Credex ecosystem to function, including the establishment of exchange rates and the creation of foundational accounts and transactions.

## DCOexecute.ts

The DCOexecute function implements the Daily Credcoin Offering (DCO) process.

1. Check if the Minute Transaction Queue (MTQ) is running and wait if it is and retry in a few seconds.
2. Set the DCOrunningNow flag and fetch the current and next date.
3. Perform an end-of-day backup.
4. Process defaulting unsecured credexes and expire pending offers/requests.
5. Fetch current exchange rates for various currencies.
6. Fetch declared DCO participants and filter them based on available secured balance.
7. Calculate new CXX (Credcoin) rates based on the total DCO amount and number of participants.
8. Create a new daynode with the updated CXX rates.
9. Create DCO give transactions from participants to the Credex Foundation.
10. Update credex and asset balances across the system to reflect the new exchange rates.
11. Create DCO receive transactions from the Credex Foundation to participants.
12. Perform a start-of-day backup for the new day.

This process implements the Credcoin Principle by:

- Allowing participants to contribute value to the ecosystem (DCO give transactions).
- Distributing an equal share of the new value to all participants (DCO receive transactions).
- Adjusting the value of Credcoin relative to other currencies based on the total contribution and number of participants.
- Updating all existing balances and transactions to maintain their relative value in the new exchange rate environment.

The DCO process ensures that the value of one Credcoin is always equal to the number of participants divided by the value of natural wealth entering the organic economy through the DCO, as stated in the Credcoin Principle.

This implementation allows for a dynamic, daily adjustment of the ecosystem's internal economy, reflecting the contributions and participation of its members while maintaining the relative value of existing transactions and balances.

# MinuteTransactionQueue (MTQ)

The Minute Transaction Queue is a crucial part of the Credex ecosystem that runs every minute. It links the main ledgerSpace database (the source of truth and full information) to a searchSpace database (optimized to find credloops). New accounts are first added to the searchSpace, then new credexes. After each new credex is added, the ecosystem finds and clears all possible loops created by the new credex.

1. Processing new accounts:

   - Finds accounts with "PENDING_ACCOUNT" status in the ledger space.
   - Creates corresponding accounts in the search space.
   - Updates the account status to "PROCESSED" in the ledger space.

2. Processing new Credexes:
   - Retrieves Credexes with "PENDING_CREDEX" status from the ledger space.
   - Sorts them by acceptance time.
   - For each Credex, it calls the LoopFinder function.

## LoopFinder.ts

Checks if the credex already exists in the search space. If not, it creates it.

1. Finds all loops starting and ending at the specified account.
   - Identifies the loop with the earliest due date.
   - For each node in the loop, it selects the Credex with the earliest due date (or largest amount if tied).
   - Identifies the minimum outstanding amount among all credexes in the loop.
2. If a loop is found:
   - Subtract the minimum amount from all Credexes in the loop.
   - Update the searchSpace, removing fully redeemed credexes and updating the earliest due dates.
   - Update the ledgerSpace, creating a LoopAnchor to represent the cleared loop, update the Credexes' outstanding and redeemed amounts, and create REDEEMED and CREDLOOP relationships.
   - For fully redeemed credexes, replace the OWES relationships with CLEARED relationships in ledgerSpace.
3. Go back to step one until no loop is found.
4. Once no more loops can be found, mark the original Credex as processed and exit the loop.

This implementation actualizes the Credex Principle by finding loops where "If I owe you, and you owe them, and they owe me, we're square." It automatically clears these loops, reducing the outstanding amounts of all involved credexes by the same amount (the minimum amount in the loop).

The LoopFinder is called by the MinuteTransactionQueue for each new Credex, ensuring that loops are found and cleared as soon as possible after new Credexes are created.

# Member

This module handles member-related operations in the Credex ecosystem. It exposes the following endpoints:

1. **onboardMember** (POST)

   - Function: Registers a new member in the Credex ecosystem and creates their personal consumption account.
   - Required variables:
     - firstname: string
     - lastname: string
     - phone: string
   - Optional variables:
     - DCOgiveInCXX: number (for setting up the DCO contribution)
     - DCOdenom: string (denomination for DCO contribution)

2. **getMemberDashboardByPhone** (GET)

   - Function: Retrieves a member's dashboard information and associated account dashboards using their phone number.
   - Required variables:
     - phone: string

3. **getMemberByHandle** (GET)

   - Function: Retrieves member information using their unique handle.
   - Required variables:
     - memberHandle: string

4. **updateMemberTier** (POST)
   - Function: Updates a member's tier status.
   - Required variables:
     - memberID: string
     - newTier: number

These endpoints allow for member registration, information retrieval, and tier management within the Credex ecosystem. The onboardMember endpoint not only creates a new member but also sets up their personal consumption account, integrating the member into the ecosystem. The getMemberDashboardByPhone endpoint provides comprehensive information about the member and their associated accounts, while getMemberByHandle allows for quick member lookup. The updateMemberTier endpoint enables the system to adjust a member's status within the ecosystem.

# Account

This module handles account-related operations in the Credex ecosystem. It exposes the following endpoints:

1. **createAccount** (POST)

   - Function: Creates a new account in the Credex ecosystem.
   - Required variables:
     - ownerID: string
     - accountType: string
     - accountName: string
     - accountHandle: string
     - defaultDenom: string

2. **getAccountByHandle** (GET)

   - Function: Retrieves account information using the account handle.
   - Required variables:
     - accountHandle: string

3. **updateAccount** (PATCH)

   - Function: Updates an existing account's information.
   - Required variables:
     - accountID: string
   - Optional variables:
     - accountName: string
     - accountType: string
     - defaultDenom: string

4. **authorizeForAccount** (POST)

   - Function: Authorizes a member to perform actions on behalf of an account.
   - Required variables:
     - accountID: string
     - memberID: string

5. **unauthorizeForAccount** (POST)

   - Function: Removes authorization for a member to act on behalf of an account.
   - Required variables:
     - accountID: string
     - memberID: string

6. **updateSendOffersTo** (POST)
   - Function: Updates the account's preference for receiving offers.
   - Required variables:
     - accountID: string
     - sendOffersTo: string

These endpoints provide comprehensive account management capabilities within the Credex ecosystem. The createAccount endpoint allows for the creation of new accounts, while getAccountByHandle facilitates easy retrieval of account information. The updateAccount endpoint enables modifications to existing accounts. The authorizeForAccount and unauthorizeForAccount endpoints manage access control for accounts, allowing or revoking permissions for members to act on behalf of an account. Finally, the updateSendOffersTo endpoint allows accounts to specify their preferences for receiving offers, enhancing user control over interactions within the ecosystem.

# Credex

This module handles Credex-related operations in the Credex ecosystem. It exposes the following endpoints:

1. **offerCredex** (POST)

   - Function: Creates a new Credex offer.
   - Required variables:
     - memberID: string
     - issuerAccountID: string
     - receiverAccountID: string
     - Denomination: string
     - InitialAmount: number

2. **acceptCredex** (PUT)

   - Function: Accepts a Credex offer.
   - Required variables:
     - credexID: string
     - signerID: string

3. **acceptCredexBulk** (PUT)

   - Function: Accepts multiple Credex offers in bulk.
   - Required variables:
     - credexIDs: string[] (Array of credex IDs to accept)
     - signerID: string

4. **declineCredex** (PUT)

   - Function: Declines a Credex offer.
   - Required variables:
     - credexID: string

5. **cancelCredex** (PUT)

   - Function: Cancels a Credex offer.
   - Required variables:
     - credexID: string

6. **getCredex** (GET)

   - Function: Retrieves information about a specific Credex.
   - Required variables:
     - credexID: string
     - accountID: string

7. **getLedger** (GET)
   - Function: Retrieves ledger information for an account.
   - Required variables:
     - accountID: string
   - Optional variables:
     - numRows: number
     - startRow: number

These endpoints provide comprehensive Credex management capabilities within the ecosystem. The offerCredex endpoint allows for the creation of new Credex offers, while acceptCredex and acceptCredexBulk facilitate the acceptance of these offers individually or in bulk. The declineCredex and cancelCredex endpoints provide options for rejecting or withdrawing Credex offers. The getCredex endpoint allows for retrieving detailed information about a specific Credex, and getLedger provides access to an account's transaction history. Together, these endpoints enable the full lifecycle management of Credexes within the ecosystem, from creation and acceptance to cancellation and historical tracking.

# Avatar

This module handles operations related to Avatars in the Credex ecosystem. Avatars are nodes that members can delegate signing authority to. Currently, the only Avatar implemented is a Recurring transaction. Once this Avatar is signed by the counterparties, it activates on the schedule agreed by the counterparties to create a Credex using the data agreed between the counterparties. The trail of accountability is maintained because the creation of an Avatar must be signed by the counterparties, and the Avatar signs every Credex it creates.

The Avatar module exposes the following endpoints:

1. **requestRecurring** (POST)

   - Function: Creates a new recurring transaction request.
   - Required variables:
     - signerMemberID: string
     - requestorAccountID: string
     - counterpartyAccountID: string
     - InitialAmount: number
     - Denomination: string
     - credexType: string
     - OFFERSorREQUESTS: string
     - nextPayDate: date
     - daysBetweenPays: number
     - remainingPays: number (optional)

2. **acceptRecurring** (POST)

   - Function: Accepts a recurring transaction request.
   - Required variables:
     - avatarID: string
     - signerID: string

3. **cancelRecurring** (POST)
   - Function: Cancels an active recurring transaction or declines a pending request.
   - Required variables:
     - signerID: string
     - cancelerAccountID: string
     - avatarID: string

These endpoints provide functionality for managing recurring transactions within the Credex ecosystem:

- The requestRecurring endpoint allows for the creation of new recurring transaction requests. It sets up the details of the recurring transaction, including the accounts involved, the amount, denomination, frequency, and duration.

- The acceptRecurring endpoint facilitates the acceptance of these requests. When a recurring transaction is accepted, it becomes active and will automatically create Credex transactions according to the specified schedule.

- The cancelRecurring endpoint enables the cancellation of an active recurring transaction or the declination of a pending request. This provides flexibility for users to modify or end recurring arrangements as needed.

The Avatar module enhances the automation and flexibility of transactions within the Credex ecosystem by allowing members to set up recurring transactions. This feature is particularly useful for regular payments, subscriptions, or any other scenario where periodic transactions are required. The implementation maintains accountability by requiring explicit acceptance of recurring transaction requests and allowing for their cancellation at any time.

# Admin

This module is coming soon.

# DevAdmin

This module is under construction.

# To run the credex ecosystem in your local dev environment

### Prerequisites

Before running this project, make sure you have the following installed:

- Node.js (version 18.X.X or higher)
- npm (version X.X.X or higher)

### Installation

1. Clone the repository:

   ```bash
   git clone https://github.com/Credex/credex-core.git
   ```

2. Navigate to the project directory:

   ```bash
   cd credex-core
   ```

   Create a branch from the 'dev' branch.

3. Install the dependencies:

   ```bash
   npm install
   ```

### Running the Project

To run the project using nodemon, follow these steps:

1. Install nodemon globally (if not already installed):

   ```bash
   npm install -g nodemon
   ```

   This will install nodemon globally on your system.

2. Open a terminal and navigate to the project directory.

3. Run the following command:

   ```bash
   npm run nodemon
   ```

   This command will start the project using nodemon, which will automatically restart the server whenever changes are made to the code.

4. Open postman and visit `http://localhost:5000` to access the project endpoints.

# To run on a Codespaces virtual machine

### Prerequisites and installation

Executed automatically via devcontainer.

### Start the development server

```bash
npm run nodemon
```

This command will start the project using nodemon, which will automatically restart the server whenever changes are made to the code.

### Use Postman for endpoints

1. Click the icon for the Postman extension in the sidebar and sign in. You may need to use the authorization token provided by Postman. Open the Credex Team Workspace.

2. In the codespaces terminal, print the Github Token with

```
echo $GITHUB_TOKEN
```

Copy the token and paste it the "X-Github-Token" field in the credex-core variables in Postman. A new token is created every codespae session. If the codespace stops, this step has to be completed again.

3. After `npm run nodemon`, copy the forwarded port address from the Ports tab and paste it in the "base_url" field in the credex-core variables in Postman. This url will remain constant for this specific codespace, even across multiple sessions.

The github token and base_url are currently saved globally in Postman, so if multiple people are working at the same time, we'll need to update Postman to handle that.

# ledgerSpace schema

```mermaid
graph TB
    D[Daynode]

    subgraph Members
        M1[Member]
        M2[Member]
    end

    subgraph Accounts
        A1[Account]
        A2[Account]
        A3[Account]
    end

    subgraph Credexes
        C1[Credex]
        C2[Credex]
        C3[Credex]
        LA[LoopAnchor]
    end

    M1 --> |OWNS| A1
    M1 --> |OWNS| A2
    M2 --> |OWNS| A3

    A1 --> |OWES/CLEARED| C1
    C1 --> |OWES/CLEARED| A2
    A2 --> |OWES/CLEARED| C2
    C2 --> |OWES/CLEARED| A3
    A3 --> |OWES/CLEARED| C3
    C3 --> |OWES/CLEARED| A1

    A1 --> |OFFERS/REQUESTS| C1
    C1 --> |OFFERS/REQUESTS| A2
    A2 --> |OFFERS/REQUESTS| C2
    C2 --> |OFFERS/REQUESTS| A3
    A3 --> |OFFERS/REQUESTS| C3
    C3 --> |OFFERS/REQUESTS| A1

    A1 --> |OFFERED/REQUESTED| C1
    C1 --> |OFFERED/REQUESTED| A2
    A2 --> |OFFERED/REQUESTED| C2
    C2 --> |OFFERED/REQUESTED| A3
    A3 --> |OFFERED/REQUESTED| C3
    C3 --> |OFFERED/REQUESTED| A1

    C1 --> |REDEEMED| LA
    C2 --> |REDEEMED| LA
    C3 --> |REDEEMED| LA

    C1 --> |CREDLOOP| C2
    C2 --> |CREDLOOP| C3
    C3 --> |CREDLOOP| C1

    M1 --> |CREATED_ON| D
    M2 --> |CREATED_ON| D
    A1 --> |CREATED_ON| D
    A2 --> |CREATED_ON| D
    A3 --> |CREATED_ON| D
    C1 --> |CREATED_ON| D
    C2 --> |CREATED_ON| D
    C3 --> |CREATED_ON| D
    LA --> |CREATED_ON| D
```

\*\* relationship names separated by "/" indicates that only one of those relationship types can exist between the two nodes.

## Node Properties

### Member

- memberID: string
- memberHandle: string
- firstname: string
- lastname: string
- phone: string
- email: string
- memberTier: number

### Account

- accountID: string
- accountHandle: string
- accountName: string
- accountType: string
- DCOgiveInCXX: number
- DCOdenom: string
- queueStatus: string

### Credex

- credexID: string
- InitialAmount: number
- OutstandingAmount: number
- RedeemedAmount: number
- DefaultedAmount: number
- WrittenOffAmount: number
- Denomination: string
- CXXmultiplier: number
- credexType: string
- dueDate: Date
- DateRedeemed: Date
- queueStatus: string

### LoopAnchor

- loopID: string
- loopedAt: DateTime
- LoopedAmount: number
- CXXmultiplier: number
- Denomination: string

### Daynode

- Date: Date
- Active: boolean
- DCOrunningNow: boolean
- MTQrunningNow: boolean
- CXXprior_CXXcurrent: number
- CXX: number
- USD: number
- CAD: number
- ZiG: number

## Relationship Properties

### OWNS

- (No properties)

### OWES/CLEARED

- (No properties)

### OFFERS/REQUESTS

- (No properties)

### OFFERED/REQUESTED

- (No properties)

### REDEEMED

- AmountRedeemed: number
- AmountOutstandingNow: number
- Denomination: string
- CXXmultiplier: number
- createdAt: DateTime
- redeemedRelID: string

### CREDLOOP

- AmountRedeemed: number
- AmountOutstandingNow: number
- Denomination: string
- CXXmultiplier: number
- createdAt: DateTime
- loopID: string
- credloopRelID: string

### CREATED_ON

- (No properties)

### CREATED_ON

- (No properties)

# searchSpace schema

The SearchSpace schema represents a simplified and optimized version of the ledger space, designed for efficient loop finding in the Credex ecosystem. This schema is optimized to facilitate the resource-efficient identification of credloops for the Minute Transaction Queue (MTQ) process.

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#4a4a4a', 'primaryTextColor': '#fff', 'primaryBorderColor': '#7C0000', 'lineColor': '#F8B229', 'secondaryColor': '#006100', 'tertiaryColor': '#fff'}}}%%

graph TD
    %% Nodes
    A1[Account 1]:::accountNode
    A2[Account 2]:::accountNode
    A3[Account 3]:::accountNode
    SA1[FLOATING]:::searchAnchorFloating
    SA2[USD_SECURED]:::searchAnchorUSDSecured
    SA3[CAD_SECURED]:::searchAnchorCADSecured
    C1[Credex 1]:::credexNode
    C2[Credex 2]:::credexNode
    C3[Credex 3]:::credexNode
    C4[Credex 4]:::credexNode

    %% Relationships
    A1 --> |FLOATING| SA1
    SA1 --> |FLOATING| A2
    A2 --> |USD_SECURED| SA2
    SA2 --> |USD_SECURED| A3
    A2 --> |CAD_SECURED| SA3
    SA3 --> |CAD_SECURED| A3
    SA1 --> |SEARCH_SECURED| C1
    SA2 --> |SEARCH_SECURED| C2
    SA3 --> |SEARCH_SECURED| C3
    SA3 --> |SEARCH_SECURED| C4

    %% Styles
    classDef accountNode fill:#3498db,stroke:#2980b9,color:#fff,rx:10,ry:10;
    classDef searchAnchorFloating fill:#006400,stroke:#004d00,color:#fff,rx:10,ry:10;
    classDef searchAnchorUSDSecured fill:#b87333,stroke:#a66a2e,color:#fff,rx:10,ry:10;
    classDef searchAnchorCADSecured fill:#008080,stroke:#006666,color:#fff,rx:10,ry:10;
    classDef credexNode fill:#4B0082,stroke:#3B0062,color:#fff,rx:10,ry:10;

```

## Node properties

### Account

- accountID: string
- accountName: string

### SearchAnchor

- searchAnchorID: string
- earliestDueDate: Date

### Credex

- credexID: string
- outstandingAmount: number
- Denomination: string
- CXXmultiplier: number
- dueDate: Date

## Relationship Properties

### FLOATING

- (No properties)

### USD_SECURED, CAD_SECURED

- (No properties)

### SEARCH_SECURED

- (No properties)

## Explanation

1. **Accounts**: Represented by blue nodes, these are simplified versions of the accounts in the ledger space. They contain only essential information needed for loop finding.

2. **SearchAnchors**: These nodes come in three types:

   - FLOATING (dark green): Represent unsecured credit relationships between accounts.
   - USD_SECURED (copper): Represent secured credit relationships in USD.
   - CAD_SECURED (teal): Represent secured credit relationships in CAD.

3. **Credexes**: Shown as dark purple nodes, these represent individual credit transactions in the system.

4. **Relationships**:
   - FLOATING (dark green): Connects accounts to floating SearchAnchors, representing unsecured credit relationships.
   - USD_SECURED (copper): Connect accounts to USD_SECURED SearchAnchors, representing secured credit relationships in USD.
   - CAD_SECURED (teal): Connect accounts to CAD_SECURED SearchAnchors, representing secured credit relationships in CAD.
   - SEARCH_SECURED (dark purple): Links SearchAnchors to Credexes, allowing for efficient traversal during loop finding.

This optimized structure allows the Minute Transaction Queue to quickly identify potential credit loops by traversing the relationships between Accounts, SearchAnchors, and Credexes. The use of SearchAnchors as intermediary nodes between Accounts and Credexes significantly reduces the complexity of loop finding algorithms, enabling faster processing of transactions in the Credex ecosystem.



File: ./update_combined_code.sh
----------------------------------------
#!/bin/bash

# Define the output file
output_file="combined_code.txt"

# Get the current branch name
current_branch=$(git rev-parse --abbrev-ref HEAD)

# Clear the existing content of the output file
> "$output_file"

# Add the current branch information
echo "Current Branch: $current_branch" >> "$output_file"
echo "----------------------------------------" >> "$output_file"

# Find all files with extensions .ts, .js, .json, .yaml, .yml, .md, and .sh
# Exclude node_modules directory and .git directory
find . -type f \( -name "*.ts" -o -name "*.js" -o -name "*.json" -o -name "*.yaml" -o -name "*.yml" -o -name "*.md" -o -name "*.sh" \) -not -path "*/node_modules/*" -not -path "*/.git/*" | while read -r file; do
    echo "File: $file" >> "$output_file"
    echo "----------------------------------------" >> "$output_file"
    cat "$file" >> "$output_file"
    echo -e "\n\n" >> "$output_file"
done

echo "Combined code file updated: $output_file for branch: $current_branch"


File: ./package-lock.json
----------------------------------------
{
  "name": "credex-core-express",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "credex-core-express",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "@types/cors": "^2.8.17",
        "@types/jsonwebtoken": "^9.0.6",
        "axios": "^1.6.8",
        "bcrypt": "^5.1.1",
        "body-parser": "^1.20.2",
        "cheerio": "^1.0.0-rc.12",
        "cors": "^2.8.5",
        "dotenv": "^16.4.5",
        "express": "^4.19.2",
        "express-rate-limit": "^7.4.0",
        "helmet": "^7.1.0",
        "jsonwebtoken": "^9.0.2",
        "lodash": "^4.17.21",
        "moment-timezone": "^0.5.45",
        "neo4j-driver": "^5.20.0",
        "node-cron": "^3.0.3",
        "uuid": "^10.0.0"
      },
      "devDependencies": {
        "@types/body-parser": "^1.19.5",
        "@types/express": "^4.17.21",
        "@types/lodash": "^4.17.1",
        "@types/node-cron": "^3.0.11",
        "@types/uuid": "^10.0.0",
        "ts-node": "^10.9.2",
        "typescript": "^5.4.5"
      }
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz",
      "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==",
      "dev": true
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@mapbox/node-pre-gyp": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@mapbox/node-pre-gyp/-/node-pre-gyp-1.0.11.tgz",
      "integrity": "sha512-Yhlar6v9WQgUp/He7BdgzOz8lqMQ8sU+jkCq7Wx8Myc5YFJLbEe7lgui/V7G1qB1DJykHSGwreceSaD60Y0PUQ==",
      "dependencies": {
        "detect-libc": "^2.0.0",
        "https-proxy-agent": "^5.0.0",
        "make-dir": "^3.1.0",
        "node-fetch": "^2.6.7",
        "nopt": "^5.0.0",
        "npmlog": "^5.0.1",
        "rimraf": "^3.0.2",
        "semver": "^7.3.5",
        "tar": "^6.1.11"
      },
      "bin": {
        "node-pre-gyp": "bin/node-pre-gyp"
      }
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.11.tgz",
      "integrity": "sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==",
      "dev": true
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.4.tgz",
      "integrity": "sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==",
      "dev": true
    },
    "node_modules/@types/body-parser": {
      "version": "1.19.5",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz",
      "integrity": "sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==",
      "dev": true,
      "dependencies": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/connect": {
      "version": "3.4.38",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
      "dev": true,
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/cors": {
      "version": "2.8.17",
      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.17.tgz",
      "integrity": "sha512-8CGDvrBj1zgo2qE+oS3pOCyYNqCPryMWY2bGfwA0dcfopWGgxs+78df0Rs3rc9THP4JkOhLsAa+15VdpAqkcUA==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/express": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.21.tgz",
      "integrity": "sha512-ejlPM315qwLpaQlQDTjPdsUFSc6ZsP4AN6AlWnogPjQ7CVi7PYF3YVz+CY3jE2pwYf7E/7HlDAN0rV2GxTG0HQ==",
      "dev": true,
      "dependencies": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^4.17.33",
        "@types/qs": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "4.19.5",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.19.5.tgz",
      "integrity": "sha512-y6W03tvrACO72aijJ5uF02FRq5cgDR9lUxddQ8vyF+GvmjJQqbzDcJngEjURc+ZsG31VI3hODNZJ2URj86pzmg==",
      "dev": true,
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/http-errors": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz",
      "integrity": "sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==",
      "dev": true
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.6",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.6.tgz",
      "integrity": "sha512-/5hndP5dCjloafCXns6SZyESp3Ldq7YjH3zwzwczYnjxIT0Fqzk5ROSYVGfFyczIue7IUEj8hkvLbPoLQ18vQw==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/lodash": {
      "version": "4.17.7",
      "resolved": "https://registry.npmjs.org/@types/lodash/-/lodash-4.17.7.tgz",
      "integrity": "sha512-8wTvZawATi/lsmNu10/j2hk1KEP0IvjubqPE3cu1Xz7xfXXt5oCq3SNUz4fMIP4XGF9Ky+Ue2tBA3hcS7LSBlA==",
      "dev": true
    },
    "node_modules/@types/mime": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
      "dev": true
    },
    "node_modules/@types/node": {
      "version": "20.14.12",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.14.12.tgz",
      "integrity": "sha512-r7wNXakLeSsGT0H1AU863vS2wa5wBOK4bWMjZz2wj+8nBx+m5PeIn0k8AloSLpRuiwdRQZwarZqHE4FNArPuJQ==",
      "dependencies": {
        "undici-types": "~5.26.4"
      }
    },
    "node_modules/@types/node-cron": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@types/node-cron/-/node-cron-3.0.11.tgz",
      "integrity": "sha512-0ikrnug3/IyneSHqCBeslAhlK2aBfYek1fGo4bP4QnZPmiqSGRK+Oy7ZMisLWkesffJvQ1cqAcBnJC+8+nxIAg==",
      "dev": true
    },
    "node_modules/@types/qs": {
      "version": "6.9.15",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.15.tgz",
      "integrity": "sha512-uXHQKES6DQKKCLh441Xv/dwxOq1TVS3JPUMlEqoEglvlhR6Mxnlew/Xq/LRVHpLyk7iK3zODe1qYHIMltO7XGg==",
      "dev": true
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
      "dev": true
    },
    "node_modules/@types/send": {
      "version": "0.17.4",
      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz",
      "integrity": "sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==",
      "dev": true,
      "dependencies": {
        "@types/mime": "^1",
        "@types/node": "*"
      }
    },
    "node_modules/@types/serve-static": {
      "version": "1.15.7",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz",
      "integrity": "sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==",
      "dev": true,
      "dependencies": {
        "@types/http-errors": "*",
        "@types/node": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/@types/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-7gqG38EyHgyP1S+7+xomFtL+ZNHcKv6DwNaCZmJmo1vgMugyF3TCnXVg4t1uk89mLNwnLtnY3TpOpCOyp1/xHQ==",
      "dev": true
    },
    "node_modules/abbrev": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz",
      "integrity": "sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q=="
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/acorn": {
      "version": "8.12.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.12.1.tgz",
      "integrity": "sha512-tcpGyI9zbizT9JbV6oYE477V6mTlXvvi0T0G3SNIYE2apm/G5huBa1+K89VGeovbg+jycCrfhl3ADxErOuO6Jg==",
      "dev": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.3.3",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.3.tgz",
      "integrity": "sha512-MxXdReSRhGO7VlFe1bRG/oI7/mdLV9B9JJT0N8vZOhF7gFRR5l3M8W9G8JxmKV+JC5mGqJ0QvqfSOLsCPa4nUw==",
      "dev": true,
      "dependencies": {
        "acorn": "^8.11.0"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/agent-base": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-6.0.2.tgz",
      "integrity": "sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==",
      "dependencies": {
        "debug": "4"
      },
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/agent-base/node_modules/debug": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.6.tgz",
      "integrity": "sha512-O/09Bd4Z1fBrU4VzkhFqVgpPzaGbw6Sm9FEkBT1A/YBXQFGuuSxa1dN2nxgxS34JmKXqYx8CZAwEVoJFImUXIg==",
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/agent-base/node_modules/ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/aproba": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/aproba/-/aproba-2.0.0.tgz",
      "integrity": "sha512-lYe4Gx7QT+MKGbDsA+Z+he/Wtef0BiwDOlK/XkBrdfsh9J/jPPXbX0tE9x9cl27Tmu5gg3QUbUrQYa/y+KOHPQ=="
    },
    "node_modules/are-we-there-yet": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/are-we-there-yet/-/are-we-there-yet-2.0.0.tgz",
      "integrity": "sha512-Ci/qENmwHnsYo9xKIcUJN5LeDKdJ6R1Z1j9V/J5wyq8nh/mYPEpIKJbBZXtZjG04HiK7zV/p6Vs9952MrMeUIw==",
      "deprecated": "This package is no longer supported.",
      "dependencies": {
        "delegates": "^1.0.0",
        "readable-stream": "^3.6.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg=="
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "node_modules/axios": {
      "version": "1.7.2",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.7.2.tgz",
      "integrity": "sha512-2A8QhOMrbomlDuiLeK9XibIBzuHeRcqqNOHp0Cyp5EoJ1IFDh+XZH3A6BkXtv0K4gFGCI0Y4BM7B1wOEi0Rmgw==",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.0",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw=="
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/bcrypt": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/bcrypt/-/bcrypt-5.1.1.tgz",
      "integrity": "sha512-AGBHOG5hPYZ5Xl9KXzU5iKq9516yEmvCKDg3ecP5kX2aB6UqTeXZxk2ELnDgDm6BQSMlLt9rDB4LoSMx0rYwww==",
      "hasInstallScript": true,
      "dependencies": {
        "@mapbox/node-pre-gyp": "^1.0.11",
        "node-addon-api": "^5.0.0"
      },
      "engines": {
        "node": ">= 10.0.0"
      }
    },
    "node_modules/body-parser": {
      "version": "1.20.2",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.2.tgz",
      "integrity": "sha512-ml9pReCu3M61kGlqoTm2umSXTlRTuGTx0bfYj+uIUKKYycG5NtSbeetV3faSU6R7ajOPw0g/J1PvK4qNy7s5bA==",
      "dependencies": {
        "bytes": "3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "on-finished": "2.4.1",
        "qs": "6.11.0",
        "raw-body": "2.5.2",
        "type-is": "~1.6.18",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/boolbase": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/boolbase/-/boolbase-1.0.0.tgz",
      "integrity": "sha512-JZOSA7Mo9sNGB8+UjSgzdLtokWAky1zbztM3WRLCbZ70/3cTANmQmOdR7y2g+J0e2WXywy1yS468tY+IruqEww=="
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/buffer": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz",
      "integrity": "sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.2.1"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA=="
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.7.tgz",
      "integrity": "sha512-GHTSNSYICQ7scH7sZ+M2rFopRoLh8t2bLSW6BbgrtLsahOIB5iyAVJf9GjWK3cYTDaMj4XdBpM1cA6pIS0Kv2w==",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "set-function-length": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/cheerio": {
      "version": "1.0.0-rc.12",
      "resolved": "https://registry.npmjs.org/cheerio/-/cheerio-1.0.0-rc.12.tgz",
      "integrity": "sha512-VqR8m68vM46BNnuZ5NtnGBKIE/DfN0cRIzg9n40EIq9NOv90ayxLBXA8fXC5gquFRGJSTRqBq25Jt2ECLR431Q==",
      "dependencies": {
        "cheerio-select": "^2.1.0",
        "dom-serializer": "^2.0.0",
        "domhandler": "^5.0.3",
        "domutils": "^3.0.1",
        "htmlparser2": "^8.0.1",
        "parse5": "^7.0.0",
        "parse5-htmlparser2-tree-adapter": "^7.0.0"
      },
      "engines": {
        "node": ">= 6"
      },
      "funding": {
        "url": "https://github.com/cheeriojs/cheerio?sponsor=1"
      }
    },
    "node_modules/cheerio-select": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/cheerio-select/-/cheerio-select-2.1.0.tgz",
      "integrity": "sha512-9v9kG0LvzrlcungtnJtpGNxY+fzECQKhK4EGJX2vByejiMX84MFNQw4UxPJl3bFbTMw+Dfs37XaIkCwTZfLh4g==",
      "dependencies": {
        "boolbase": "^1.0.0",
        "css-select": "^5.1.0",
        "css-what": "^6.1.0",
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.3",
        "domutils": "^3.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/chownr": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
      "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/color-support": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/color-support/-/color-support-1.1.3.tgz",
      "integrity": "sha512-qiBjkpbMLO/HL68y+lh4q0/O1MZFj2RX6X/KmMa3+gJD3z+WwI1ZzDHysvqHGS3mP6mznPckpXmw1nI9cJjyRg==",
      "bin": {
        "color-support": "bin.js"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg=="
    },
    "node_modules/console-control-strings": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/console-control-strings/-/console-control-strings-1.1.0.tgz",
      "integrity": "sha512-ty/fTekppD2fIwRvnZAVdeOiGd1c7YXEixbgJTNzqcxJWKQnjJ/V1bNEEE6hygpM3WjwHFUVK6HTjWSzV4a8sQ=="
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.6.0.tgz",
      "integrity": "sha512-U71cyTamuh1CRNCfpGY6to28lxvNwPG4Guz/EVjgf3Jmzv0vlDp1atT9eS5dDjMYHucpHbWns6Lwf3BKz6svdw==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ=="
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true
    },
    "node_modules/css-select": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/css-select/-/css-select-5.1.0.tgz",
      "integrity": "sha512-nwoRF1rvRRnnCqqY7updORDsuqKzqYJ28+oSMaJMMgOauh3fvwHqMS7EZpIPqK8GL+g9mKxF1vP/ZjSeNjEVHg==",
      "dependencies": {
        "boolbase": "^1.0.0",
        "css-what": "^6.1.0",
        "domhandler": "^5.0.2",
        "domutils": "^3.0.1",
        "nth-check": "^2.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/css-what": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/css-what/-/css-what-6.1.0.tgz",
      "integrity": "sha512-HTUrgRJ7r4dsZKU6GjmpfRK1O76h97Z8MfS1G0FozR+oF2kG6Vfe8JE6zwrkbxigziPHinCJ+gCPjA9EaBDtRw==",
      "engines": {
        "node": ">= 6"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/define-data-property": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/define-data-property/-/define-data-property-1.1.4.tgz",
      "integrity": "sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/delegates": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delegates/-/delegates-1.0.0.tgz",
      "integrity": "sha512-bd2L678uiWATM6m5Z1VzNCErI3jiGzt6HGY8OVICs40JQq/HALfbyNJmp0UDakEY4pMMaN0Ly5om/B1VI/+xfQ=="
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.0.3.tgz",
      "integrity": "sha512-bwy0MGW55bG41VqxxypOsdSdGqLwXPI/focwgTYCFMbdUiBAxLg9CFzG08sz2aqzknwiX7Hkl0bQENjg8iLByw==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/dom-serializer": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/dom-serializer/-/dom-serializer-2.0.0.tgz",
      "integrity": "sha512-wIkAryiqt/nV5EQKqQpo3SToSOV9J0DnbJqwK7Wv/Trc92zIAYZ4FlMu+JPFW1DfGFt81ZTCGgDEabffXeLyJg==",
      "dependencies": {
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.2",
        "entities": "^4.2.0"
      },
      "funding": {
        "url": "https://github.com/cheeriojs/dom-serializer?sponsor=1"
      }
    },
    "node_modules/domelementtype": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/domelementtype/-/domelementtype-2.3.0.tgz",
      "integrity": "sha512-OLETBj6w0OsagBwdXnPdN0cnMfF9opN69co+7ZrbfPGrdpPVNBUj02spi6B1N7wChLQiPn4CSH/zJvXw56gmHw==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/fb55"
        }
      ]
    },
    "node_modules/domhandler": {
      "version": "5.0.3",
      "resolved": "https://registry.npmjs.org/domhandler/-/domhandler-5.0.3.tgz",
      "integrity": "sha512-cgwlv/1iFQiFnU96XXgROh8xTeetsnJiDsTc7TYCLFd9+/WNkIqPTxiM/8pSd8VIrhXGTf1Ny1q1hquVqDJB5w==",
      "dependencies": {
        "domelementtype": "^2.3.0"
      },
      "engines": {
        "node": ">= 4"
      },
      "funding": {
        "url": "https://github.com/fb55/domhandler?sponsor=1"
      }
    },
    "node_modules/domutils": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/domutils/-/domutils-3.1.0.tgz",
      "integrity": "sha512-H78uMmQtI2AhgDJjWeQmHwJJ2bLPD3GMmO7Zja/ZZh84wkm+4ut+IUnUdRa8uCGX88DiVx1j6FRe1XfxEgjEZA==",
      "dependencies": {
        "dom-serializer": "^2.0.0",
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.3"
      },
      "funding": {
        "url": "https://github.com/fb55/domutils?sponsor=1"
      }
    },
    "node_modules/dotenv": {
      "version": "16.4.5",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-16.4.5.tgz",
      "integrity": "sha512-ZmdL2rui+eB2YwhsWzjInR8LldtZHGDoQ1ugH85ppHKwpUHL7j7rN0Ti9NCnGiQbhaZ11FpR+7ao1dNsmduNUg==",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow=="
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A=="
    },
    "node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/entities": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/entities/-/entities-4.5.0.tgz",
      "integrity": "sha512-V0hjH4dGPh9Ao5p0MoRY6BVqtwCjhz6vI5LT8AJ55H+4g9/4vbHx1I54fS0XuclLhDHArPQCiMjDxjaL8fPxhw==",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.0.tgz",
      "integrity": "sha512-jxayLKShrEqqzJ0eumQbVhTYQM27CfT1T35+gCgDFoL82JLsXqTJ76zv6A0YLOgEnLUMvLzsDsGIrl8NFpT2gQ==",
      "dependencies": {
        "get-intrinsic": "^1.2.4"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow=="
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "4.19.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.19.2.tgz",
      "integrity": "sha512-5T6nhjsT+EOMzuck8JjBHARTHfMht0POzlA60WV2pMD3gyXw2LZnZ+ueGdNxG+0calOJcWKbpFcuzLZ91YWq9Q==",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "1.20.2",
        "content-disposition": "0.5.4",
        "content-type": "~1.0.4",
        "cookie": "0.6.0",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.2.0",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "merge-descriptors": "1.0.1",
        "methods": "~1.1.2",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.7",
        "proxy-addr": "~2.0.7",
        "qs": "6.11.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "0.18.0",
        "serve-static": "1.15.0",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      }
    },
    "node_modules/express-rate-limit": {
      "version": "7.4.0",
      "resolved": "https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-7.4.0.tgz",
      "integrity": "sha512-v1204w3cXu5gCDmAvgvzI6qjzZzoMWKnyVDk3ACgfswTQLYiGen+r8w0VnXnGMmzEN/g8fwIQ4JrFFd4ZP6ssg==",
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "url": "https://github.com/sponsors/express-rate-limit"
      },
      "peerDependencies": {
        "express": "4 || 5 || ^5.0.0-beta.1"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.2.0.tgz",
      "integrity": "sha512-5uXcUVftlQMFnWC9qu/svkWv3GTd2PfUhK/3PLkYNAe7FbqJMt3515HaxE6eRL74GdsriiwujiawdaB1BpEISg==",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "2.0.1",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/follow-redirects": {
      "version": "1.15.6",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.6.tgz",
      "integrity": "sha512-wWN62YITEaOpSK584EZXJafH1AGpO8RVgElfkuXbTOrPX4fIfOyEpW/CsiNd8JdYrAoOvafRTOEnvsO++qCqFA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.0.tgz",
      "integrity": "sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fs-minipass": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-2.1.0.tgz",
      "integrity": "sha512-V/JgOLFCS+R6Vcq0slCuaeWEdNC3ouDlJMNIsacH2VtALiu9mV4LPrHc5cDl8k5aw6J8jwgWWpiTo5RYhmIzvg==",
      "dependencies": {
        "minipass": "^3.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/fs-minipass/node_modules/minipass": {
      "version": "3.3.6",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.3.6.tgz",
      "integrity": "sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw=="
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gauge": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/gauge/-/gauge-3.0.2.tgz",
      "integrity": "sha512-+5J6MS/5XksCuXq++uFRsnUd7Ovu1XenbeuIuNRJxYWjgQbPuFhT14lAvsWfqfAmnwluf1OwMjz39HjfLPci0Q==",
      "deprecated": "This package is no longer supported.",
      "dependencies": {
        "aproba": "^1.0.3 || ^2.0.0",
        "color-support": "^1.1.2",
        "console-control-strings": "^1.0.0",
        "has-unicode": "^2.0.1",
        "object-assign": "^4.1.1",
        "signal-exit": "^3.0.0",
        "string-width": "^4.2.3",
        "strip-ansi": "^6.0.1",
        "wide-align": "^1.1.2"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.2.4.tgz",
      "integrity": "sha512-5uYhsJH8VJBTv7oslg4BznJYhDoRI6waYCxMmCdnTrcCrHA/fCFKoTFz2JKKE0HdDFUF7/oQuhzumXJK7paBRQ==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "has-proto": "^1.0.1",
        "has-symbols": "^1.0.3",
        "hasown": "^2.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "deprecated": "Glob versions prior to v9 are no longer supported",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/gopd": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz",
      "integrity": "sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==",
      "dependencies": {
        "get-intrinsic": "^1.1.3"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-property-descriptors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.2.tgz",
      "integrity": "sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==",
      "dependencies": {
        "es-define-property": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-proto": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has-proto/-/has-proto-1.0.3.tgz",
      "integrity": "sha512-SJ1amZAJUiZS+PhsVLf5tGydlaVB8EdFpaSO4gmiUKUOxk8qzn5AIy4ZeJUmh22znIdk/uMAUT2pl3FxzVUH+Q==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-unicode": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/has-unicode/-/has-unicode-2.0.1.tgz",
      "integrity": "sha512-8Rf9Y83NBReMnx0gFzA8JImQACstCYWUplepDa9xprwwtmgEZUF0h/i5xSA625zB/I37EtrswSST6OXxwaaIJQ=="
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/helmet": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/helmet/-/helmet-7.1.0.tgz",
      "integrity": "sha512-g+HZqgfbpXdCkme/Cd/mZkV0aV3BZZZSugecH03kl38m/Kmdx8jKjBikpDj2cr+Iynv4KpYEviojNdTJActJAg==",
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/htmlparser2": {
      "version": "8.0.2",
      "resolved": "https://registry.npmjs.org/htmlparser2/-/htmlparser2-8.0.2.tgz",
      "integrity": "sha512-GYdjWKDkbRLkZ5geuHs5NY1puJ+PXwP7+fHPRz06Eirsb9ugf6d8kkXav6ADhcODhFFPMIXyxkxSuMf3D6NCFA==",
      "funding": [
        "https://github.com/fb55/htmlparser2?sponsor=1",
        {
          "type": "github",
          "url": "https://github.com/sponsors/fb55"
        }
      ],
      "dependencies": {
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.3",
        "domutils": "^3.0.1",
        "entities": "^4.4.0"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-5.0.1.tgz",
      "integrity": "sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==",
      "dependencies": {
        "agent-base": "6",
        "debug": "4"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/https-proxy-agent/node_modules/debug": {
      "version": "4.3.6",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.6.tgz",
      "integrity": "sha512-O/09Bd4Z1fBrU4VzkhFqVgpPzaGbw6Sm9FEkBT1A/YBXQFGuuSxa1dN2nxgxS34JmKXqYx8CZAwEVoJFImUXIg==",
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/https-proxy-agent/node_modules/ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jsonwebtoken/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "node_modules/jwa": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.1.tgz",
      "integrity": "sha512-qiLX/xhEEFKUAJ6FiBMbes3w9ATzyk5W7Hvzpa/SLYdxNtng+gcurvrI7TbACjIXlsJyr05/S1oUhZrc63evQA==",
      "dependencies": {
        "buffer-equal-constant-time": "1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w=="
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg=="
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA=="
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw=="
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA=="
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw=="
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg=="
    },
    "node_modules/make-dir": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-3.1.0.tgz",
      "integrity": "sha512-g3FeP20LNwhALb/6Cz6Dd4F2ngze0jz7tbzrD2wAV+o9FeNHe4rL+yK2md0J/fiSf1sa1ADhXqi5+oVwOM/eGw==",
      "dependencies": {
        "semver": "^6.0.0"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-dir/node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.1.tgz",
      "integrity": "sha512-cCi6g3/Zr1iqQi6ySbseM1Xvooa98N0w31jzUYrXPX2xqObmFGHJ0tQ5u74H3mVh7wLouTseZyYIq39g8cNp1w=="
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minipass": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-5.0.0.tgz",
      "integrity": "sha512-3FnjYuehv9k6ovOEbyOswadCDPX1piCfhV8ncmYtHOjuPwylVWsghTLo7rabjC3Rx5xD4HDx8Wm1xnMF7S5qFQ==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/minizlib": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-2.1.2.tgz",
      "integrity": "sha512-bAxsR8BVfj60DWXHE3u30oHzfl4G7khkSuPW+qvpd7jFRHm7dLxOjUk1EHACJ/hxLY8phGJ0YhYHZo7jil7Qdg==",
      "dependencies": {
        "minipass": "^3.0.0",
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/minizlib/node_modules/minipass": {
      "version": "3.3.6",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.3.6.tgz",
      "integrity": "sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/mkdirp": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
      "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
      "bin": {
        "mkdirp": "bin/cmd.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/moment": {
      "version": "2.30.1",
      "resolved": "https://registry.npmjs.org/moment/-/moment-2.30.1.tgz",
      "integrity": "sha512-uEmtNhbDOrWPFS+hdjFCBfy9f2YoyzRpwcl+DqpC6taX21FzsTLQVbMV/W7PzNSX6x/bhC1zA3c2UQ5NzH6how==",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/moment-timezone": {
      "version": "0.5.45",
      "resolved": "https://registry.npmjs.org/moment-timezone/-/moment-timezone-0.5.45.tgz",
      "integrity": "sha512-HIWmqA86KcmCAhnMAN0wuDOARV/525R2+lOLotuGFzn4HO+FH+/645z2wx0Dt3iDv6/p61SIvKnDstISainhLQ==",
      "dependencies": {
        "moment": "^2.29.4"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A=="
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/neo4j-driver": {
      "version": "5.23.0",
      "resolved": "https://registry.npmjs.org/neo4j-driver/-/neo4j-driver-5.23.0.tgz",
      "integrity": "sha512-jqAyvIIpD1dl0+GuSXfF7Hzy+bscBIRvO2hrMqQji4Gq2baBaRMcsG/8CRhkF7Hm1bUeBUnnArnUNUGO/c+kow==",
      "dependencies": {
        "neo4j-driver-bolt-connection": "5.23.0",
        "neo4j-driver-core": "5.23.0",
        "rxjs": "^7.8.1"
      }
    },
    "node_modules/neo4j-driver-bolt-connection": {
      "version": "5.23.0",
      "resolved": "https://registry.npmjs.org/neo4j-driver-bolt-connection/-/neo4j-driver-bolt-connection-5.23.0.tgz",
      "integrity": "sha512-d8aLeeS33KMmUnGCGj/U07AUOch8IVc6hA8Lit/4ExaHnhRoSgEOPAK6/RAbYAfABlVqFfErtV85s1OnrJu64g==",
      "dependencies": {
        "buffer": "^6.0.3",
        "neo4j-driver-core": "5.23.0",
        "string_decoder": "^1.3.0"
      }
    },
    "node_modules/neo4j-driver-core": {
      "version": "5.23.0",
      "resolved": "https://registry.npmjs.org/neo4j-driver-core/-/neo4j-driver-core-5.23.0.tgz",
      "integrity": "sha512-kypv0cym8vB9t36MRKSt/mtNZuvCACg6S47yJMDjJx5XSWx69QbBaLNvoa/2//7NPCCj0Fn0i5HCKqBkcBRa2Q=="
    },
    "node_modules/node-addon-api": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/node-addon-api/-/node-addon-api-5.1.0.tgz",
      "integrity": "sha512-eh0GgfEkpnoWDq+VY8OyvYhFEzBk6jIYbRKdIlyTiAXIVJ8PyBaKb0rp7oDtoddbdoHWhq8wwr+XZ81F1rpNdA=="
    },
    "node_modules/node-cron": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/node-cron/-/node-cron-3.0.3.tgz",
      "integrity": "sha512-dOal67//nohNgYWb+nWmg5dkFdIwDm8EpeGYMekPMrngV3637lqnX0lbUcCtgibHTz6SEz7DAIjKvKDFYCnO1A==",
      "dependencies": {
        "uuid": "8.3.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/node-cron/node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/nopt": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/nopt/-/nopt-5.0.0.tgz",
      "integrity": "sha512-Tbj67rffqceeLpcRXrT7vKAN8CwfPeIBgM7E6iBkmKLV7bEMwpGgYLGv0jACUsECaa/vuxP0IjEont6umdMgtQ==",
      "dependencies": {
        "abbrev": "1"
      },
      "bin": {
        "nopt": "bin/nopt.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/npmlog": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/npmlog/-/npmlog-5.0.1.tgz",
      "integrity": "sha512-AqZtDUWOMKs1G/8lwylVjrdYgqA4d9nu8hc+0gzRxlDb1I10+FHBGMXs6aiQHFdCUUlqH99MUMuLfzWDNDtfxw==",
      "deprecated": "This package is no longer supported.",
      "dependencies": {
        "are-we-there-yet": "^2.0.0",
        "console-control-strings": "^1.1.0",
        "gauge": "^3.0.0",
        "set-blocking": "^2.0.0"
      }
    },
    "node_modules/nth-check": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/nth-check/-/nth-check-2.1.1.tgz",
      "integrity": "sha512-lqjrjmaOoAnWfMmBPL+XNnynZh2+swxiX3WUE0s4yEHI6m+AwrK2UZOimIRl3X/4QctVqS8AiZjFqyOGrMXb/w==",
      "dependencies": {
        "boolbase": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/fb55/nth-check?sponsor=1"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.2.tgz",
      "integrity": "sha512-IRZSRuzJiynemAXPYtPe5BoI/RESNYR7TYm50MC5Mqbd3Jmw5y790sErYw3V6SryFJD64b74qQQs9wn5Bg/k3g==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/parse5": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/parse5/-/parse5-7.1.2.tgz",
      "integrity": "sha512-Czj1WaSVpaoj0wbhMzLmWD69anp2WH7FXMB9n1Sy8/ZFF9jolSQVMu1Ij5WIyGmcBmhk7EOndpO4mIpihVqAXw==",
      "dependencies": {
        "entities": "^4.4.0"
      },
      "funding": {
        "url": "https://github.com/inikulin/parse5?sponsor=1"
      }
    },
    "node_modules/parse5-htmlparser2-tree-adapter": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/parse5-htmlparser2-tree-adapter/-/parse5-htmlparser2-tree-adapter-7.0.0.tgz",
      "integrity": "sha512-B77tOZrqqfUfnVcOrUvfdLbz4pu4RopLD/4vmu3HUPswwTA8OH0EMW9BlWR2B0RCoiZRAHEUu7IxeP1Pd1UU+g==",
      "dependencies": {
        "domhandler": "^5.0.2",
        "parse5": "^7.0.0"
      },
      "funding": {
        "url": "https://github.com/inikulin/parse5?sponsor=1"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.7.tgz",
      "integrity": "sha512-5DFkuoqlv1uYQKxy8omFBeJPQcdoE07Kv2sferDCrAq1ohOU+MSDswDIbnx3YAM60qIOnYa53wBhXW0EbMonrQ=="
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg=="
    },
    "node_modules/qs": {
      "version": "6.11.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.11.0.tgz",
      "integrity": "sha512-MvjoMCJwEarSbUYk5O+nmoSzSutSsTwF85zcHPQ9OrlFoZOYIjaqBAJIqIXjptyD5vThxGq52Xu/MaJzRkIk4Q==",
      "dependencies": {
        "side-channel": "^1.0.4"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.2.tgz",
      "integrity": "sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "deprecated": "Rimraf versions prior to v4 are no longer supported",
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/rxjs": {
      "version": "7.8.1",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.8.1.tgz",
      "integrity": "sha512-AA3TVj+0A2iuIoQkWEK/tqFjBq2j+6PO6Y0zJcvzLAFhEFIO3HL0vls9hWLncZbAAbK0mar7oZ4V079I/qPMxg==",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "node_modules/semver": {
      "version": "7.6.3",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.6.3.tgz",
      "integrity": "sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "0.18.0",
      "resolved": "https://registry.npmjs.org/send/-/send-0.18.0.tgz",
      "integrity": "sha512-qqWzuOjSFOuqPjFe4NOsMLafToQQwBSOEpS+FwEt3A2V3vKubTquT3vmLTQpFgMXp8AlFWFuP1qKaJZOtPpVXg==",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "2.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "node_modules/serve-static": {
      "version": "1.15.0",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.15.0.tgz",
      "integrity": "sha512-XGuRDNjXUijsUL0vl6nSD7cwURuzEgglbOaFuZM9g3kwDXOWVTck0jLzjPzGD+TazWbboZYu52/9/XPdUgne9g==",
      "dependencies": {
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.18.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/set-blocking": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz",
      "integrity": "sha512-KiKBS8AnWGEyLzofFfmvKwpdPzqiy16LvQfK3yv/fVH7Bj13/wl3JSR1J+rfgRE9q7xUJK4qvgS8raSOeLUehw=="
    },
    "node_modules/set-function-length": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/set-function-length/-/set-function-length-1.2.2.tgz",
      "integrity": "sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "gopd": "^1.0.1",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/side-channel": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.0.6.tgz",
      "integrity": "sha512-fDW/EZ6Q9RiO8eFG8Hj+7u/oW+XrPTIChwCOM2+th2A6OblDtYYIpve9m+KvI9Z4C9qSEXlaGR6bTEYHReuglA==",
      "dependencies": {
        "call-bind": "^1.0.7",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.4",
        "object-inspect": "^1.13.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ=="
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/tar": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/tar/-/tar-6.2.1.tgz",
      "integrity": "sha512-DZ4yORTwrbTj/7MZYq2w+/ZFdI6OZ/f9SFHR+71gIVUZhOQPHzVCLpvRnPgyaMpfWxxk/4ONva3GQSyNIKRv6A==",
      "dependencies": {
        "chownr": "^2.0.0",
        "fs-minipass": "^2.0.0",
        "minipass": "^5.0.0",
        "minizlib": "^2.1.1",
        "mkdirp": "^1.0.3",
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "node_modules/ts-node": {
      "version": "10.9.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
      "dev": true,
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/tslib": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.6.3.tgz",
      "integrity": "sha512-xNvxJEOUiWPGhUuUdQgAJPKOOJfGnIyKySOc09XkKsgdUV/3E2zvwZYdejjmRgPCgcym1juLH3226yA7sEFJKQ=="
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typescript": {
      "version": "5.5.4",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.5.4.tgz",
      "integrity": "sha512-Mtq29sKDAEYP7aljRgtPOpTvOfbwRWlS6dPRzwjdE+C0R4brX/GUyhHSecbHMFLNBLcJIPt9nl9yG5TZ1weH+Q==",
      "dev": true,
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "5.26.5",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-5.26.5.tgz",
      "integrity": "sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA=="
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw=="
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-8XkAphELsDnEGrDxUOHB3RGvXz6TeuYSGEZBOjtTtPm2lwhGBjLgOzLHB63IUWfBpNucQjND6d3AOudO+H3RWQ==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "node_modules/wide-align": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/wide-align/-/wide-align-1.1.5.tgz",
      "integrity": "sha512-eDMORYaPNZ4sQIuuYPDHdQvf4gyCF9rEEV/yPxGfwPkRodwEgiMUUXTx/dex+Me0wxx53S+NgUHaP7y3MGlDmg==",
      "dependencies": {
        "string-width": "^1.0.2 || 2 || 3 || 4"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ=="
    },
    "node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    }
  }
}



File: ./compose.yaml
----------------------------------------
# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Docker Compose reference guide at
# https://docs.docker.com/go/compose-spec-reference/

# Here the instructions define your application as a service called "server".
# This service is built from the Dockerfile in the current directory.
# You can add other services your application may depend on here, such as a
# database or a cache. For examples, see the Awesome Compose repository:
# https://github.com/docker/awesome-compose
services:
  server:
    build:
      context: .
    environment:
      NODE_ENV: production
      WHATSAPP_BOT_API_KEY: ${WHATSAPP_BOT_API_KEY}
      NEO_4J_LEDGER_SPACE_BOLT_URL: ${NEO_4J_LEDGER_SPACE_BOLT_URL}
      NEO_4J_LEDGER_SPACE_USER: ${NEO_4J_LEDGER_SPACE_USER}
      NEO_4J_LEDGER_SPACE_PASS: ${NEO_4J_LEDGER_SPACE_PASS}
      NEO_4J_SEARCH_SPACE_BOLT_URL: ${NEO_4J_SEARCH_SPACE_BOLT_URL}
      NEO_4J_SEARCH_SPACE_USER: ${NEO_4J_SEARCH_SPACE_USER}
      NEO_4J_SEARCH_SPACE_PASS: ${NEO_4J_SEARCH_SPACE_PASS}
      DEPLOYMENT: ${DEPLOYMENT}
      OPEN_EXCHANGE_RATES_API: ${OPEN_EXCHANGE_RATES_API}      
    ports:
      - 5000:5000
# The commented out section below is an example of how to define a PostgreSQL
# database that your application can use. `depends_on` tells Docker Compose to
# start the database before your application. The `db-data` volume persists the
# database data between container restarts. The `db-password` secret is used
# to set the database password. You must create `db/password.txt` and add
# a password of your choosing to it before running `docker-compose up`.
#     depends_on:
#       db:
#         condition: service_healthy
#   db:
#     image: postgres
#     restart: always
#     user: postgres
#     secrets:
#       - db-password
#     volumes:
#       - db-data:/var/lib/postgresql/data
#     environment:
#       - POSTGRES_DB=example
#       - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
#     expose:
#       - 5432
#     healthcheck:
#       test: [ "CMD", "pg_isready" ]
#       interval: 10s
#       timeout: 5s
#       retries: 5
# volumes:
#   db-data:
# secrets:
#   db-password:
#     file: db/password.txt




File: ./config/logger.ts
----------------------------------------
import express from "express";

export function Logger(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction,
) {
  const today = new Date(Date.now());
  console.log(`├── [${today.toISOString()}] ROUTE[${req.originalUrl}]`);
  next();
}



File: ./config/authenticate.ts
----------------------------------------
import { Request, Response, NextFunction } from "express";

interface UserRequest extends Request {
  user?: any;
}

const authenticate = (req: UserRequest, res: Response, next: NextFunction) => {
  const apiKeySubmitted = req.header("whatsappBotAPIkey");
  const validApiKey = process.env.WHATSAPP_BOT_API_KEY;

  if (!validApiKey) {
    console.error(
      "WHATSAPP_BOT_API_KEY is not defined in environment variables"
    );
    return false;
  }

  if (apiKeySubmitted) {
    if (apiKeySubmitted === validApiKey) {
      next();
    } else {
      return res.status(401).json({ message: "Unauthorized" });
    }
  }
};

export default authenticate;



File: ./config/neo4j.ts
----------------------------------------
import * as neo4j from "neo4j-driver";

require('dotenv').config()

const ledgerSpace_url = `${process.env.NEO_4J_LEDGER_SPACE_BOLT_URL}`;
const ledgerSpace_user = `${process.env.NEO_4J_LEDGER_SPACE_USER}`;
const ledgerSpace_password = `${process.env.NEO_4J_LEDGER_SPACE_PASS}`;
const searchSpace_url = `${process.env.NEO_4J_SEARCH_SPACE_BOLT_URL}`;
const searchSpace_user = `${process.env.NEO_4J_SEARCH_SPACE_USER}`;
const searchSpace_password = `${process.env.NEO_4J_SEARCH_SPACE_PASS}`;

export const ledgerSpaceDriver = neo4j.driver(
  ledgerSpace_url,
  neo4j.auth.basic(ledgerSpace_user, ledgerSpace_password),
  {
    encrypted: true,
  }
);

export const searchSpaceDriver = neo4j.driver(
  searchSpace_url,
  neo4j.auth.basic(searchSpace_user, searchSpace_password),
  {
    encrypted: true,
  }
);



