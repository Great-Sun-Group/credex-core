name: Initial Deployment to AWS

on:
  workflow_dispatch:

jobs:
  deploy:
    name: Initial AWS Deployment
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/prod' && 'production' || github.ref == 'refs/heads/stage' && 'staging' || 'development' }}
    env:
      TF_VAR_domain_base: mycredex.app
      TF_VAR_subdomain_development: dev.api
      TF_VAR_subdomain_staging: stage.api
      TF_VAR_subdomain_production: api
      TF_VAR_neo4j_instance_count_development: 2
      TF_VAR_neo4j_instance_count_staging: 2
      TF_VAR_neo4j_instance_count_production: 2
      TF_VAR_neo4j_instance_type_development: t3.xlarge
      TF_VAR_neo4j_instance_type_staging: r5.2xlarge
      TF_VAR_neo4j_instance_type_production: r5.12xlarge
      TF_VAR_log_level_development: debug
      TF_VAR_log_level_staging: info
      TF_VAR_log_level_production: info

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set Environment
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/prod" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
          fi
          echo "NODE_ENV=$ENVIRONMENT" >> $GITHUB_ENV
          echo "TF_VAR_environment=$ENVIRONMENT" >> $GITHUB_ENV
          echo "Setting environment to: ${{ env.ENVIRONMENT }}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Debug - Print Environment Variables
        run: |
          echo "NODE_ENV: ${{ env.NODE_ENV }}"
          echo "TF_VAR_environment: ${{ env.TF_VAR_environment }}"
          echo "GitHub Environment: ${{ env.ENVIRONMENT }}"
          echo "AWS_REGION: ${{ secrets.AWS_REGION }}"
          echo "OPEN_EXCHANGE_RATES_API is set: ${{ secrets.OPEN_EXCHANGE_RATES_API != '' }}"
          echo "NEO4J_ENTERPRISE_LICENSE is set: ${{ secrets.NEO4J_ENTERPRISE_LICENSE != '' }}"

      - name: Check Required Secrets
        run: |
          missing_secrets=()
          
          if [ -z "${{ secrets.AWS_ACCESS_KEY }}" ]; then
            missing_secrets+=("AWS_ACCESS_KEY")
          fi
          if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            missing_secrets+=("AWS_SECRET_ACCESS_KEY")
          fi
          if [ -z "${{ secrets.AWS_REGION }}" ]; then
            missing_secrets+=("AWS_REGION")
          fi
          if [ -z "${{ secrets.OPEN_EXCHANGE_RATES_API }}" ]; then
            missing_secrets+=("OPEN_EXCHANGE_RATES_API")
          fi
          if [ -z "${{ secrets.NEO4J_ENTERPRISE_LICENSE }}" ]; then
            missing_secrets+=("NEO4J_ENTERPRISE_LICENSE")
          fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "Error: The following required secrets are missing: ${missing_secrets[*]}"
            echo "Please set these secrets in your GitHub repository settings."
            exit 1
          fi

      - name: Debug - Check AWS Configuration
        run: |
          echo "Checking AWS credentials..."
          if aws sts get-caller-identity &> /dev/null; then
            echo "AWS credentials are valid"
            aws sts get-caller-identity
          else
            echo "Error: AWS credentials are invalid or not set correctly"
            echo "AWS_ACCESS_KEY is set: ${{ secrets.AWS_ACCESS_KEY != '' }}"
            echo "AWS_SECRET_ACCESS_KEY is set: ${{ secrets.AWS_SECRET_ACCESS_KEY != '' }}"
            echo "AWS_REGION is set: ${{ secrets.AWS_REGION != '' }}"
            exit 1
          fi
          aws configure list

      - name: Generate Secrets
        run: |
          chmod +x .github/workflows/generate_secrets.sh
          ./.github/workflows/generate_secrets.sh ${{ env.NODE_ENV }}

      - name: Create Terraform Variables File
        run: |
          cat << EOF > terraform/terraform.tfvars
          environment = "${{ env.ENVIRONMENT }}"
          jwt_secret = "${{ secrets.JWT_SECRET }}"
          open_exchange_rates_api = "${{ secrets.OPEN_EXCHANGE_RATES_API }}"
          neo4j_enterprise_license = "${{ secrets.NEO4J_ENTERPRISE_LICENSE }}"
          neo4j_ledger_space_user = "${{ secrets.NEO4J_LEDGER_SPACE_USER }}"
          neo4j_ledger_space_pass = "${{ secrets.NEO4J_LEDGER_SPACE_PASS }}"
          neo4j_search_space_user = "${{ secrets.NEO4J_SEARCH_SPACE_USER }}"
          neo4j_search_space_pass = "${{ secrets.NEO4J_SEARCH_SPACE_PASS }}"
          neo4j_public_key = "${{ secrets.NEO4J_PUBLIC_KEY }}"
          EOF

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Pre-deployment Checks
        id: pre_deployment_checks
        run: |
          cd terraform

          # Function to check if a resource exists in AWS
          resource_exists() {
            local resource_type=$1
            local resource_name=$2
            
            case $resource_type in
              "aws_acm_certificate")
                aws acm list-certificates --query 'CertificateSummaryList[?DomainName==`'"$resource_name"'`].CertificateArn' --output text | grep -q .
                ;;
              "aws_security_group")
                aws ec2 describe-security-groups --filters "Name=group-name,Values=$resource_name" --query 'SecurityGroups[0].GroupId' --output text | grep -q .
                ;;
              "aws_instance")
                aws ec2 describe-instances --filters "Name=tag:Name,Values=$resource_name" "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].[InstanceId]' --output text | grep -q .
                ;;
              "aws_ecs_cluster")
                aws ecs list-clusters --query "clusterArns[?contains(@, '$resource_name')]" --output text | grep -q .
                ;;
              "aws_ecs_service")
                aws ecs list-services --cluster "credex-cluster-${{ env.TF_VAR_environment }}" --query "serviceArns[?contains(@, '$resource_name')]" --output text | grep -q .
                ;;
              "aws_lb")
                aws elbv2 describe-load-balancers --query "LoadBalancers[?LoadBalancerName=='$resource_name'].LoadBalancerArn" --output text | grep -q .
                ;;
              *)
                echo "Unknown resource type: $resource_type"
                return 1
                ;;
            esac
          }

          # Check for existing resources
          echo "Checking for existing resources..."

          if resource_exists "aws_acm_certificate" "${TF_VAR_domain_base}" || \
             resource_exists "aws_security_group" "credex-alb-sg-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_security_group" "credex-core-ecs-tasks-sg-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_security_group" "credex-neo4j-sg-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_ecs_cluster" "credex-cluster-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_ecs_service" "credex-core-service-${{ env.TF_VAR_environment }}" || \
             resource_exists "aws_lb" "credex-alb-${{ env.TF_VAR_environment }}"; then
            echo "Error: Some resources already exist. This script is intended for initial deployment only."
            exit 1
          fi

          # Check for Neo4j instances
          neo4j_instance_count=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=Neo4j-${{ env.TF_VAR_environment }}-*" "Name=instance-state-name,Values=running" --query 'length(Reservations[].Instances[])' --output text)

          if [ "$neo4j_instance_count" -gt 0 ]; then
            echo "Error: Neo4j instances already exist. This script is intended for initial deployment only."
            exit 1
          fi

      - name: Terraform Init and Workspace Selection
        run: |
          cd terraform
          terraform init
          terraform workspace select ${{ env.TF_VAR_environment }} || terraform workspace new ${{ env.TF_VAR_environment }}

      - name: Terraform Plan (Infrastructure)
        id: plan_infra
        run: |
          cd terraform
          terraform plan -out=tfplan_infra -target=module.neo4j -target=module.networking -var-file=terraform.tfvars

      - name: Terraform Apply (Infrastructure)
        run: |
          cd terraform
          terraform apply -auto-approve tfplan_infra

      - name: Get Terraform Outputs
        id: tf-outputs
        run: |
          cd terraform
          echo "Retrieving Terraform outputs..."
          terraform output -json > tf_outputs.json
          echo "tf_outputs=$(cat tf_outputs.json | jq -c .)" >> $GITHUB_OUTPUT

      - name: Set Neo4j Bolt URLs
        run: |
          NEO4J_LEDGER_IP=$(echo '${{ steps.tf-outputs.outputs.tf_outputs }}' | jq -r '.neo4j_ledger_space_bolt_url.value' | sed 's|bolt://||' | sed 's|:7687||')
          NEO4J_SEARCH_IP=$(echo '${{ steps.tf-outputs.outputs.tf_outputs }}' | jq -r '.neo4j_search_space_bolt_url.value' | sed 's|bolt://||' | sed 's|:7687||')
          gh secret set NEO_4J_LEDGER_SPACE_BOLT_URL -b"bolt://${NEO4J_LEDGER_IP}:7687" --env ${{ env.TF_VAR_environment }}
          gh secret set NEO_4J_SEARCH_SPACE_BOLT_URL -b"bolt://${NEO4J_SEARCH_IP}:7687" --env ${{ env.TF_VAR_environment }}
          echo "TF_VAR_neo4j_ledger_space_bolt_url=bolt://${NEO4J_LEDGER_IP}:7687" >> $GITHUB_ENV
          echo "TF_VAR_neo4j_search_space_bolt_url=bolt://${NEO4J_SEARCH_IP}:7687" >> $GITHUB_ENV

      - name: Terraform Plan (ECS)
        id: plan_ecs
        run: |
          cd terraform
          terraform plan -out=tfplan_ecs -target=module.ecs -var-file=terraform.tfvars

      - name: Terraform Apply (ECS)
        run: |
          cd terraform
          terraform apply -auto-approve tfplan_ecs

      - name: Update ECS Task Definition
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          TASK_DEF=$(aws ecs describe-task-definition --task-definition credex-core-${{ env.TF_VAR_environment }} --query taskDefinition)
          NEW_TASK_DEF=$(echo $TASK_DEF | jq '.containerDefinitions[0].environment += [
            {"name": "NEO_4J_LEDGER_SPACE_BOLT_URL", "value": "${{ env.TF_VAR_neo4j_ledger_space_bolt_url }}"},
            {"name": "NEO_4J_SEARCH_SPACE_BOLT_URL", "value": "${{ env.TF_VAR_neo4j_search_space_bolt_url }}"},
            {"name": "NEO_4J_LEDGER_SPACE_USER", "value": "${{ secrets.NEO4J_LEDGER_SPACE_USER }}"},
            {"name": "NEO_4J_LEDGER_SPACE_PASS", "value": "${{ secrets.NEO4J_LEDGER_SPACE_PASS }}"},
            {"name": "NEO_4J_SEARCH_SPACE_USER", "value": "${{ secrets.NEO4J_SEARCH_SPACE_USER }}"},
            {"name": "NEO_4J_SEARCH_SPACE_PASS", "value": "${{ secrets.NEO4J_SEARCH_SPACE_PASS }}"},
            {"name": "JWT_SECRET", "value": "${{ secrets.JWT_SECRET }}"},
            {"name": "OPEN_EXCHANGE_RATES_API", "value": "${{ secrets.OPEN_EXCHANGE_RATES_API }}"}
          ]')
          echo $NEW_TASK_DEF > new-task-def.json
          aws ecs register-task-definition --cli-input-json file://new-task-def.json

      - name: Deploy Application
        env:
          TF_OUTPUTS: ${{ steps.tf-outputs.outputs.tf_outputs }}
        run: |
          echo "Deploying application to ${{ env.TF_VAR_environment }} from branch ${{ github.ref_name }}"
          aws ecs update-service --cluster credex-cluster-${{ env.TF_VAR_environment }} --service credex-core-service-${{ env.TF_VAR_environment }} --task-definition credex-core-${{ env.TF_VAR_environment }}
          
          # Wait for the service to stabilize
          aws ecs wait services-stable --cluster credex-cluster-${{ env.TF_VAR_environment }} --services credex-core-service-${{ env.TF_VAR_environment }}
          
          # Get the latest task ARN
          TASK_ARN=$(aws ecs list-tasks --cluster credex-cluster-${{ env.TF_VAR_environment }} --service-name credex-core-service-${{ env.TF_VAR_environment }} --query 'taskArns[0]' --output text)
          
          # Get the task details
          TASK_DETAILS=$(aws ecs describe-tasks --cluster credex-cluster-${{ env.TF_VAR_environment }} --tasks $TASK_ARN)
          
          # Print task details for debugging
          echo "Task Details:"
          echo "$TASK_DETAILS" | jq .
          
          # Get the latest events from the ECS service
          echo "ECS Service Events:"
          aws ecs describe-services --cluster credex-cluster-${{ env.TF_VAR_environment }} --services credex-core-service-${{ env.TF_VAR_environment }} --query 'services[0].events[0:5]' | jq .

      - name: Debug - Print Final Environment Variables
        run: |
          echo "Final Environment Variables:"
          env | grep -E "TF_VAR_|AWS_|NODE_ENV|GITHUB_ENV"
